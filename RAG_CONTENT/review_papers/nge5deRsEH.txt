On the Power of Decision Trees
in Auto-Regressive Language Modeling
Yulu Gan
Massachusetts Institute of Technology
yulu@csail.mit.eduTomer Galanti
Texas A&M University
galanti@tamu.edu
Tomaso Poggio
Massachusetts Institute of Technology
tp@csail.mit.eduEran Malach
Harvard University
eran.malach@gmail.com
Abstract
Originally proposed for handling time series data, Auto-regressive Decision Trees
(ARDTs) have not yet been explored for language modeling. This paper explores
both the theoretical and practical applications of ARDTs in this new context. We
theoretically demonstrate that ARDTs can compute complex functions, such as
simulating automata, Turing machines, and sparse circuits, by leveraging ‚Äúchain-
of-thought‚Äù computations. Our analysis provides bounds on the size, depth, and
computational efficiency of ARDTs, highlighting their surprising computational
power. Empirically, we train ARDTs on simple language generation tasks, showing
that they can learn to generate coherent and grammatically correct text on par
with a smaller Transformer model. Additionally, we show that ARDTs can be
used on top of transformer representations to solve complex reasoning tasks. This
research reveals the unique computational abilities of ARDTs, aiming to broaden
the architectural diversity in language model development.
1 Introduction
In recent years, Large Language Models (LLMs) have achieved outstanding results in tasks such as
natural language understanding, coding, and mathematical reasoning. LLMs predominantly utilize the
Transformer architecture Vaswani et al. (2023), establishing it as the standard in this field. However,
recent initiatives (Gu & Dao, 2023; Sun et al., 2023; Ma et al., 2023; De et al., 2024) have begun to
challenge the dominance of Transformers. These alternatives, while not yet matching Transformer
performance, offer advantages in terms of inference time efficiency. Moreover, some works are
revisiting traditional non-neural network models for language modeling, such as classical symbolic
models (Wong et al., 2023). These developments indicate a shift towards diverse, efficient, and
interpretable language modeling methodologies.
Tree-based models, particularly favored for handling tabular data (Grinsztajn et al., 2022), continue
to hold significant importance. While tree-based methods are mostly used for classification and
regression tasks, Auto-regressive Decision Trees (ARDTs) (Meek et al., 2002) have been studied for
time-series prediction, offering a simpler and more interpretable alternative to complex nonlinear
approaches. Although the ARDT approach was not originally designed for language tasks, it has
demonstrated considerable promise in various time-series datasets, outperforming traditional auto-
regressive models while maintaining ease of interpretation. Motivated by these results, our study
seeks to explore the potential of ARDTs for language prediction tasks, assessing whether they could
serve as a viable, interpretable alternative to complex, resource-intensive language models.
Submitted to 38th Conference on Neural Information Processing Systems (NeurIPS 2024). Do not distribute.Outputs: InputPrompt:
(b)(a)there was a little girl named Lily. She loved to play outside in the sunshine. One day, she saw a big tree in the garden. She was so excited about it.Once upon a time,
NY
Y
YY
YYYNN
NNNN. . .. . .. . .Figure 1: (a) An example of story continuation generated by our Auto-Regressive Decision Trees.
We use decision trees and, remarkably, attain results comparable to Transformer-based models in
terms of linguistic fluency. (b) The decision process of the decision trees. We visualize part of the
tree ensemble, and can observe which word is most relevant for the splitting rule at each node.
To understand the power of ARDTs, we first conduct theoretical studies demonstrating that ARDTs,
using decision trees as next-token predictors, can compute more complex functions than traditional
decision trees. We explore the classes of functions ARDTs can compute, showing their ability to
simulate functions computed by automata, Turing machines, or sparse circuits through intermediate
‚Äúchain-of-thought‚Äù computations. We provide bounds on the size, depth, and run-time (measured
by the number of intermediate tokens) required for ARDTs to simulate these function classes. Our
findings highlight the surprising computational capabilities of ARDTs, underscoring their potential
as a powerful and interpretable alternative for language prediction tasks requiring complex function
computations.
Our experimental results further demonstrate the practical utility of ARDTs in language generation
tasks. Utilizing standard auto-regressive inference methods, these models generate output sequences
token-by-token, appending each new token to the input of the subsequent iteration. When trained on
the TinyStories dataset Eldan & Li (2023), ARDTs produce coherent and grammatically accurate text
(see in Fig 1). Notably, decision tree ensembles with approximately 0.3 million parameters outperform
a Transformer model with around 1 million parameters on the same Tinystories dataset, highlighting
their efficiency despite a smaller size. We discuss our approach to training interpretable decision
trees, which enhances the transparency of the decision-making process in language generation.
Furthermore, we assess the ability of tree-based models to execute various logical reasoning tasks.
Notably, tree ensembles built on top of transformer embeddings and trained on specific downstream
tasks perform comparably to larger general models like InstructGPT Ouyang et al. (2022) and
PaLM-540B Chowdhery et al. (2022), under the conditions of these particular tasks.
Our contribution can be summarized as follows:
‚Ä¢We extend the application of ARDTs to language prediction tasks, adopting a novel approach
that capitalizes on their inherent simplicity and interpretability. This aims to broaden the
architectural diversity in language model development.
‚Ä¢Through theoretical analysis, we demonstrate that ARDTs can compute a broader array
of complex functions than previously recognized, including the simulation of automata,
Turing machines, and sparse circuits. These theoretical findings deepen our understanding
of ARDTs‚Äô computational capabilities.
‚Ä¢Our experimental results offer empirical evidence that ARDTs are capable of generating
coherent and grammatically correct text, perform well compared to more complex models
like small Transformers, and demonstrate solid reasoning abilities.
22 Related Work
Decision Trees. Tree based models have been widely used for solving different classification and
regression tasks in machine learning (Navada et al., 2011). The ID3 algorithm was introduced by
Quinlan (1986), and has been widely used for decision tree learning, along with the CART (Breiman
et al., 1984; Lewis, 2000) algorithm. Decision tree ensembles, such as random forests (Breiman,
2001) and gradient boosted trees (Friedman, 2002), are also very popular. Despite continuous
advancements in deep learning, decision tree ensembles still outperform neural network based models
on tabular datasets (Shwartz-Ziv & Armon, 2022). Different from traditional decision trees, we use
auto-regressive decision trees to perform language prediction tasks more efficiently.
Learning Theory for Decision Trees. There are a few theoretical works studying the power of
decision trees in solving machine learning problems. The work of Brutzkus et al. (2020) shows that
the ID3 algorithm can learn sparse functions in some setting. Kearns & Mansour (1996) show that
decision trees are equivalent to boosting methods for amplifying the performance of weak learners
on the distribution. Other works focus on other aspects of decision tree learnability (Rivest, 1987;
Blum, 1992; Ehrenfeucht & Haussler, 1989; Bshouty & Burroughs, 2003). We note that from the
approximation point of view, decision trees can be regarded as splines with free knots. For instance,
piecewise constant hierarchical splines functions, similar to neural networks with threshold activation
can also be seen as decision trees. Note that ReLU networks can be viewed as piecewise hierarchical
linear splines (Anselmi et al., 2015; Yarotsky, 2016), and so decision trees can represent ReLU
networks (see Aytekin (2022)), though possibly with an exponential number of parameters. We note
that none of the works mentioned above studies the theory of auto-regressive decision trees, which is
a novel contribution of our paper.
Decision Trees for Language. Despite gaining popularity in several fields of machine learning, tree
based models are not widely used for language generation. Past works have utilized auto-regressive
decision trees for time-series analysis (Meek et al., 2002), or use trees for basic language modeling
(Potamianos & Jelinek, 1998). Decision trees were also used in parsing (Magerman, 1995; Heeman,
1999; Nallapati & Allan, 2002), modeling syntax (Filimonov, 2011) and language identification
(Hakkinen & Tian, 2001).
3 Theory
To explore the capabilities of ARDTs, we initially undertake theoretical studies demonstrating that
using decision trees as next-token predictors enables ARDTs to process significantly more complex
functions than ‚Äústandard‚Äù decision trees. Firstly, we define the theoretical setting of our analysis
in Section 3.1. We then examine the various classes of functions that an ARDT can compute, as
discussed in Sections 3.2, 3.3, and 3.4. Here, the computation involves the ARDT receiving an
input sequence, such as a question, generating a series of intermediate tokens that describe the
thought process, and finally producing the output token. Specifically, we demonstrate that functions
computed by Automata, Turing machines, or sparse circuits can be emulated by an ARDT using
these intermediate ‚Äúchain-of-thought‚Äù computations. Additionally, we provide bounds on the size,
depth, and runtime (measured by the number of intermediate tokens) required for ARDTs to simulate
these classes of interest. Our findings affirm that ARDTs, by leveraging decision trees for next-token
prediction, can handle far more complex functions than ‚Äústandard‚Äù decision trees.
Comment 1. The results in this section are representation results. That is, we study which functions
can, in theory, be represented by auto-regressive decision trees. We do not provide any formal results
on whether such functions can be learned from data. The question of how decision trees can be
trained to produce ‚Äúchain-of-thought‚Äù responses to input questions is beyond the scope of this work.
3.1 Setting
We adapt the standard definition of a decision tree, as described by Quinlan (1986), to include
modifications that allow for the processing of vector sequences of arbitrary lengths. Firstly, we
establish a vocabulary D, which serves as our token dictionary. Next, we define an input embedding
Œ® :D‚ÜíRd. For any sequence of tokens s‚ààDn,Œ®(s)‚ààRn√ódrepresents the embedding applied
individually to each token. The space comprising sequences of d-dimensional vectors is denoted by
3X=R‚àó√ód. Subsequently, we define a decision tree Tthat receives an input x‚àà X and outputs a
token y‚ààD.
In our experiments, detailed in Section 4, we apply a weighted-average operator to the word vectors of
the sequence, where the average vectors are used as an input to the decision trees. For the theoretical
analysis we study a different approach for using decision trees over vector sequences, where instead
of averaging word vectors we ‚Äúconcatenate‚Äù them. That is, the decision tree is applied to the L
most recent words, in a ‚Äúsliding window‚Äù fashion. We note that experimentally we observed that
both the ‚Äúsliding-window‚Äù and the weighted-average approach produced similar results, and use the
weighted-average technique in our experiments for computational reasons.
We start by defining a decision tree Tthat gets inputs of a fixed length L, namely T:RL√ód‚ÜíD.
We refer to the value Las the context length ofT, and this value will correspond to the maximal
length of a sequence that affects the computation of the tree. In this case, we treat the input x‚ààRL√ód
as a vector, and let Tbe a standard decision tree operating on vectors of size L¬∑d. Namely, Tis
defined by a binary tree, where each node corresponds to an input feature xi,jand some threshold
œÑ‚ààR. Each leaf corresponds to some output token y‚ààD. The output of the tree Tis computed
by starting at the root, and for each internal node with feature xi,jand threshold œÑ, moving to the
right node if xi,j‚â•œÑand otherwise moving to the left node. When reaching a leaf, we output the
value y‚ààDcorresponding to the leaf. The sizeof the tree Tis the number of leaves in the tree, and
itsdepth is the maximum length of a path from root to leaf. Note that the runtime of computing the
output of Tcorresponds to the depth of the tree.
Now, given some tree over length- Linputs T:RL√ód‚ÜíD, we apply Tto an input of arbitrary
length x‚àà X using the following simple rule: if xhas length shorter than L, we pad it to length L
by prepending the input, adding additional padding ( ‚ü®PAD‚ü©) tokens at the beginning; if xis longer
thanL, we apply Tonly to the last Ltokens in x. This induces a decision tree with arbitrary length
inputs T:X ‚ÜíD.
Finally, we use the tree Tas a next-token predictor function, applied over some input using auto-
regressive computation. That is, we define a sequence-to-sequence predictor TAR:D‚àó‚ÜíD‚àó
induced from the tree Tas follows: for every input s‚ààDn, recursively define sn+i+1=
T(Œ®(s1, . . . , s n+i)), and let TAR(s1, . . . , s n) = (sn+1, sn+2, . . .). We call TARanauto-regressive
decision tree (ARDT).
In the rest of this section, we will analyze the capacity of ARDTs to simulate some function classes.
Following Malach (2023), we give the following definition:
Definition 2. For some class Fof functions f:Dn‚ÜíD, we say Fcan be simulated by
auto-regressive decision-trees in length complexity T, if for every f‚àà F there exists TAR
s.t. for all s‚ààDn, we have TAR
T(s) =f(s)(where TAR
Tindicates the output of TARat
iteration T).
In other words, we say that the tree TARcan compute the function f, if given some input sequence
s, it generates Ttokens followed by the correct output f(s). That is, we allow the tree to use T
intermediate tokens as ‚Äúchain-of-thought‚Äù before outputting the correct answer.
3.2 Simulating Automata
An automaton Ais defined over an alphabet Œ£, using a set of states Q, an initial state q0‚ààQand a
transition function Œ¥:Q√óŒ£‚ÜíQ. We always assume that |Œ£| ‚â•2and|Q| ‚â•2. The automaton A
gets an input string x‚ààŒ£‚àó, and computes an output state A(x)‚ààQby starting at state q0and at
each iteration itransitioning to the next state based on the i-th token xi, namely qi=Œ¥(qi‚àí1, xi).
The automaton then returns the state reached at the final iteration.
LetFAut
nis the class of all functions computed by automata over strings of length n. Namely,
FAut
nis the class of functions f: Œ£n‚ÜíQs.t. for all f‚àà FAut
nthere exists an automaton As.t.
A(x) =f(x)for all x‚ààŒ£n.
The class of functions computed by Automata has been well-studied from the early days computer
science theory (Hopcroft et al., 2001), and has various important connections to language problems.
This class of functions is also interesting in the context of reasoning tasks for language modeling. For
4example, the Web-of-Lies andNavigate problems in the Big-Bench Hard dataset (Srivastava et al.,
2023) can be solved by finite state Automata.
We show that ARDTs can simulate Automata:
Theorem 3. LetD= Œ£‚à™Q‚à™ {‚ü®PAD‚ü©}. Then, FAut
ncan be simulated by ARDTs of size
O
|D|2
, depth O(log|D|)and context length L‚â•n, in length complexity O(n).
Note that ARDTs simulate Automata very efficiently: the total run-time of the ARDT guaranteed by
Theorem 3 is O(nlog|D|), which corresponds to the time it takes to read all the input bits. In this
sense, no algorithm can simulate Automata significantly faster than ARDT.
In the proof, we construct an ARDT that, at every iteration i, outputs the state of the Automaton at
stepi(denoted qi). The state at step i+ 1is only a function of the i-th state, given by the most recent
token generated by the model; and the i-th input, which is always given by looking back n+ 1tokens.
Therefore, a simple tree, applied as a sliding-window over the input, can compute the transition matrix
to find the next state. The full proof is given in Appendix A.
Next, we show that the above result implies a separation between ARDTs and standard decision trees.
Specifically, we show that if we use a decision-tree over the input to directly predict the final output
of the Automata, without outputting intermediate states, then the size of the decision tree must be
exponential in the length of the input:
Theorem 4. There exists some f‚àà FAut
ns.t. any decision tree that computes fhas size
‚â•‚Ñ¶(2n).
This shows that the fact that ARDTs can perform intermediate computations auto-regressively (e.g.,
perform chain-of-thought ) significantly improves their efficiency1. To prove the result, we show that
computing the parity of a sequence of bits (i.e., whether the number of bits is even or odd) requires a
tree of exponential size, but can be easily computed by a simple 2-state Automaton.
Proof of Theorem 4. Consider the binary alphabet Œ£ ={0,1}and the state set Q={even,odd},
with|Œ£|= 2and|Q|= 2. We define a function f: Œ£n‚ÜíQas follows:
f(x) =even ifPximod 2 = 0 ,
odd otherwise .
The function fdescribes the parity of the sum of bits in xand can be efficiently computed by an
automaton that toggles between states even and odd upon encountering a 1.
Suppose a decision tree Tcomputes f. We claim that the size of Tmust be at least 2n. Assume for
contradiction that Thas fewer than 2nleaves. Since Tis a decision tree, we assume that all its leaves
are reachable by some input x‚àà {0,1}n.
Consider a leaf lofTreached by some input x, at a depth less than n. This implies that there exists
at least one bit index j‚àà[n]such that no decision node in Tqueries xjon the path to l. Define
x‚Ä≤‚àà {0,1}nby flipping xjinx, while keeping all other bits unchanged:
x‚Ä≤
i=xi ifiÃ∏=j,
¬¨xjifi=j.
Since x‚Ä≤alters xonly at the unqueried index j, it follows the same path in Tand reaches the same leaf
l. Therefore, T(x) =T(x‚Ä≤). However, the definition of fguarantees f(x)Ã∏=f(x‚Ä≤)as their parities
are different, leading to a contradiction. Thus Tcannot compute fwith fewer than 2nleaves.
1This is an example of how compositional sparsity can defeat the curse of dimensionality (Poggio, 2022). A
function may not be approximated by a decision tree without an exponential number of parameters but may be
represented efficiently by composing intermediate sparse functions, as ARDTs do.
53.3 Simulating Turing Machines
A Turing machine Mis defined over an alphabet Œ£, using a space set Q, initial state q0‚ààQand
transition function Œ¥:Q√óŒ£‚ÜíQ√óŒ£√ó {‚ü®LEFT ‚ü©,‚ü®RIGHT ‚ü©}. The Turing machine has a tape,
where each cell contains a symbol from Œ£. The head of the Turing machine is initialized at the
leftmost cell on the tape in state q0‚ààQ. At each iteration of the machine, it reads the symbol s‚ààŒ£
and given the head state q‚ààQusesŒ¥(q, s)to determined the new state of the head, the symbol to
write under the head, and whether to move the head left or right on the tape.
In our setting, we consider Turing machines with fixed memory M, i.e. Turing machines with access
to a tape with Mcells. In particular, this means that the Turing machine Moperate on inputs with
< M tokens. At the initial step, the input is written on the tape. If the input size is shorter than M,
we add empty tokens {‚àÖ} ‚àà Œ£after the input sequence. We consider Turing machines with fixed
runtime T, namely we let the machine run for Titerations and then halt it. The output of the machine
is the rightmost symbol on the tape after Titerations. So, we define M: Œ£M‚ÜíŒ£to be the function
computed by the machine after Tsteps. We denote by FTuring
M,T the class of functions computed by
Turing machines with memory of size Mand runtime T.
Comment 5. Turing machines are typically defined with infinite number of tape cells, and are
allowed to run arbitrarily long before halting. However, for every given input length, any computable
function always uses a fixed memory and run-time (which depend on the input length).
We now show any Turing machine with fixed memory and run-time can be simulated by an ARDT:
Theorem 6. LetD= Œ£‚à™Q‚à™{‚ü®PAD‚ü©,‚ü®SEP‚ü©}2. Then, FTuring
M,T can be simulated by ARDTs
of size O
|D|4
, depth O(log|D|)and context length L=M+ 3, with length complexity
O(MT).
To prove the result, we show that an ARDT can compute the state of the Turing machine at each
iteration. Specifically, we encode the state of the machine as a sequence of tokens from D, where we
put a token q‚ààQ‚äÜDindicating the state of the head before the token that the head reads. This
way, the transition between states is a function that only depends locally on the tokens surrounding
the position of the head, where all other (non-state) tokens can be copied as-is from one state to
the next. Similarly to the proof in the previous section, this operation can be realized by a small
sliding-window tree. The full proof is given in Appendix A.
3.4 Simulating Sparse Circuits
A circuit Cover some alphabet Œ£is defined as a directed-acyclic-graph (DAG), with ninput nodes
and one output node. Each internal (non-input) node with kincoming edges corresponds to some
function g: Œ£k‚ÜíŒ£computed by the node over its incoming inputs. For some input x‚ààŒ£n, the
output of the circuit Cis the value of the output node, when setting the input nodes of Ctox1, . . . , x n.
The size of the circuit Cis the number of nodes in the computational graph. We say that Cisk-sparse,
if the maximal in-degree of every node in the graph is k. Denote by FCircuit
N,k the class of functions
computed by k-sparse circuits of size N.
We note that sparse circuits are an extension of sparse Boolean circuits, and so can represent Turing
machines with bounded memory (Arora & Barak, 2009). In this sense, this class is ‚Äúequivalent‚Äù to the
class of functions computed by Turing machines. However, some functions may be more efficient to
compute using sparse circuits, and so it is interesting to understand how ARDTs can directly simulate
sparse circuits, as demonstrated in the following theorem:
Theorem 7. LetD= Œ£‚à™ {‚ü®PAD‚ü©}. Then, FCircuit
N,k can be simulated by ARDTs of size
O
N|D|klog|D|
and context length L‚â•N, in length complexity O(N).
2We introduce a new separator token ‚ü®SEP‚ü©, that is used during the generation of the ARDT, but is not part
of the alphabet or state set of the Turing machine.
6Proof of Theorem 7. Consider a k-sparse circuit CwithNtotal nodes, where N‚àínare internal
nodes. Let g1, . . . , g N‚àín: Œ£k‚ÜíŒ£be the functions computed at the internal nodes, ordered
topologically so that each function depends only on the inputs or the results of preceding nodes. Let
gN‚àíndenote the function computed by the output node.
Define fi: Œ£n+i‚àí1‚ÜíŒ£as the output of the i-th node in this ordering, considering all inputs and
outputs from previous nodes. Each fiis effectively a k-Junta. By Lemma 10, there exists a decision
treeTiof size O 
|D|k
such that Ti(Œ®(x)) =fi(x)for all x‚ààŒ£n+i‚àí1.
To accommodate inputs x‚ààŒ£N, we modify each tree Tito ignore the first N‚àín‚àíi+ 1inputs.
This adaptation does not affect the size of the tree.
Letz= Œ®(‚ü®PAD‚ü©)‚àà {0,1}d. Construct a tree as follows: begin with the rightmost branch of the
tree, using functions h1,1, . . . , h 1,d, . . . , h N‚àín,1, . . . , h N‚àín,d. For each node i‚àà[N‚àín]and each
bitj‚àà[d], define:
hi,j=1{Œ®(x)i,j‚â•1}ifzj= 1,
1{Œ®(x)i,j<1}ifzj= 0.
Attach tree TN‚àín‚àíi+1at each left node (i, j).
Observe that during the i-th iteration, the string begins with N‚àín‚àíi‚ü®PAD‚ü©tokens, allowing Ti
to process the pertinent part of the input. After N‚àíniterations, the constructed tree calculates the
output token as specified by C.
4 Experiments
In this section, we experimentally validate the capabilities of ARDTs as demonstrated in the previous
section and prove their language modeling potential. In Section 4.2, we first train a model based
on ARDTs and test its ability to continue stories on Tinystories Eldan & Li (2023), which involves
extending narratives similar to a finite state automaton. ARDTs generate coherent text that builds on
existing stories, also requiring the interpretation of complex contexts and emotions. This showcases
the effectiveness of sparse circuits in managing significant yet limited inputs.
Additionally, in Section 4.3, we assess the model‚Äôs reasoning abilities on the Big-Bench-Hard Suzgun
et al. (2022) dataset, where tasks often involve evaluating the truthfulness of propositions, effectively
emulating a Turing machine as it processes inputs to determine a definitive outcome (true or false).
4.1 Setting
To align with the theory section, we designed our experiments to closely mirror the theoretical
settings as closely as possible. We here provide a detailed description of our implementation of
Auto-regressive Decision Trees (ARDTs) for next-token prediction tasks. Our objective is to utilize
ARDTs as a language model that receives a sequence of input tokens x1, . . . , x nand predicts the
subsequent token xn+1. Initially, we employ a Word2Vec embedding Mikolov et al. (2013), denoted
byŒ®, to convert the sequence tokens into word embeddings Œ®(x1), . . . , Œ®(xn),Œ®(xn+1)‚ààR100.
We then compute a weighted average of these embeddings with exponential decay, prioritizing the
most recent tokens: v=Pn
i=1Œ±n‚àíi+1Œ®(xi), where Œ±‚àà(0,1). Using XGBoost Chen & Guestrin
(2016), we train an ensemble of decision trees, T, which takes the input vector vand predicts the
embedding of the next token Œ®(xn+1), aiming to minimize the mean squared error (MSE) loss. We
train this model using sequences of varying lengths sampled from our dataset. During inference,
the model generates text auto-regressively. At each step, it receives the current sequence v, outputs
the predicted embedding of the next token ÀÜu=T(v), and identifies the token whose embedding is
closest to this prediction, i.e., ÀÜx= arg min x‚à•Œ®(x)‚àíÀÜu‚à•2. This token is then used as the next token
in the sequence. The input vector is updated with the new token using v‚ÜêŒ±v+ Œ®(ÀÜ x), and the
process repeats for the next iteration. Figure 2 illustrates the training and inference pipeline.
Comment 8. We note that the setting described above deviates from the theory setting. 1) While
the theoretical analysis focuses on the representational power of a single auto-regressive decision
tree, the experiments utilize ensembles of decision trees. Notably, tree ensembles are more expressive,
which suggests that our positive findings should also extend to these ensembles. 2) For simplicity,
our theoretical study examines trees that generate a single output token in each iteration, rather
than producing a word vector, which is the approach used in the experiments. 3) The decision trees
7Once upon a time, 
OriginalData Anna and Ben are playing with balls ..Sliding WindowNext TokenModelDecision TreesTrainInference
Input Prompt: Onceupon a time,a ModelDecision Trees.. .GirlBuildDataset-> X
Weighted Average.  .SheTomSimilarity RankingTop1
Vectors (any colors)ProcessWord2VecWeighted AverageWeighted Averageùë¶!ùë¶"ùë•!ùë•"ùë•". . .ùë•#
ùë•!-> Yùë¶!ùë¶". . .ùë¶#....Word2Vec Embeddings<-Step 1: generate ‚Äòa‚ÄôStep 2Step n
a         girl         ?    ...       ?         ?Step 3XGBoost
XGBoostFigure 2: The Pipeline of Our Method. (a) Training. First, we employ a Word2Vec model to
convert words into embeddings. Next, we utilize a sliding window approach to construct a dataset for
training decision trees. Within this window, we performed a weighted average calculation, and the
following token after the window was used as the label. (b) Inference. We use our trained Decision
Trees for the purpose of next-token prediction.
discussed theoretically operate on concatenated token vectors within a sliding window, in contrast to
the use of vector averages in the experimental setting.
4.2 The Ability to Generate Coherent Stories
We test ARDTs‚Äô ability to generate stories with the TinyStories Eldan & Li (2023) dataset, which is a
widely-used high-quality synthetic dataset of short stories that contain words that a 3 to 4-year-old
child can understand, generated by GPT-3.5 and GPT-4. Details can be found in Appendix B.2.
For experiments conducted on TinyStories, we strictly follow Eldan & Li (2023) and employ the
multidimensional score provided by GPT-4, as detailed in Appendix B.5.
For baselines to compare with ARDTs, we selected several Transformer-based models. These
include two small Transformers trained on the TinyStories dataset (TinyStories-1M and TinyStories-
33M Eldan & Li (2023)), as well as GPT-4 OpenAI et al. (2023), to illustrate the performance
differences between non-neural network methods and the Transformer architecture.
For our evaluation, we provide the models with 100 story beginnings (refer to examples in Ap-
pendix B.4), each consisting of fewer than 6 words, generated by GPT-4. We use these beginnings as
inputs to the model, allowing the it to perform next token prediction, ultimately generating outputs of
20 words. For the ground truth row in Table 1, we grade complete stories from the dataset.
As shown in Table 1, ARDTs achieved performance comparable to GPT-4 and TinyStories-33M
on four metrics: grammar, creativity, consistency, and plot. Our model outperforms TinyStories-
1M, a Transformer-based model with 1M parameters, despite being smaller in size. These results
demonstrate that although tree-based models are generally considered inferior to large neural networks,
surprisingly, they can compete with small Transformers when trained on the TinyStories dataset.
4.3 Evaluating ARDTs in Language Reasoning Tasks
We now explore the potential of using decision trees for logical reasoning tasks using the Big-Bench-
Hard dataset. The Big-Bench-Hard dataset, detailed in Appendix B.2, contains 23 challenging
8Table 1: Experiment Results on TinyStories: The results show that an auto-regressive tree can achieve
better performance as the GPT-Neo architecture and exhibit competitive performance compared to
both GPT-4 and TinyStories-33M.
Model Architecture Parameters‚àóGrammar ‚Ä†Creativity ‚Ä†Consistency ‚Ä†Plot‚Ä†
TinyStories-1M GPT-Neo 1M 4.42 2.70 6.32 3.65
TinyStories-33M GPT-Neo 33M 7.80 6.87 9.10 7.65
GPT-4 GPT-4 1800B 9.93 8.51 9.32 8.24
Ground Truth / / 8.21 6.32 7.87 7.56
ARDTs (Ours) Decision Tree 0.3M 7.85 4.10 7.36 5.39
‚àóFor our decision trees, we report the total number of tree nodes in the ensemble as the parameter count.
‚Ä†To minimize the impact of inconsistency on our results and enhance the robustness of our evaluation
metrics, we calculated the average scores from ten assessments for each of the 100 stories. Each story was
evaluated ten times using the same prompt provided to GPT-4.
reasoning tasks from the BIG-Bench benchmark. We selected four representative reasoning tasks for
evaluation, with examples provided in Appendix B.2.
Each task involves training a separate decision tree ensemble. These ensembles utilize a weighted
average of input word embeddings, as described in Section 4.1, using the word embedding layer
from a pre-trained GPT-2 model trained on WebText. Each model is trained with 200 examples
and tested on 50 examples. We also experiment with decision trees trained on top of a pre-trained
GPT-2 Transformer model, where the output vectors from GPT-2 serve as input features for the
decision trees, combining GPT-2‚Äôs advanced language understanding with the analytical capabilities
of decision trees.
For establishing baselines, we follow the methodology of Suzgun et al. (2022) and use accuracy as
the metric. InstructGPT, Codex, and PaLM 540B are used as baselines.
As presented in Table 2, our model demonstrates substantial effectiveness in reasoning tasks, with
performance comparable to state-of-the-art methods. For instance, we observe improvements of
7.4% in Boolean Expression tasks, 2% in Navigate tasks, and 7.8% in Sports Understanding tasks.
Moreover, we find that further enhancements are possible by integrating decision trees with the GPT-2
Transformer, underscoring the significant impact of word embeddings on performance. However, his
paper focuses on highlighting the potential of the ARDTs architecture, not word embeddings. Our
results show that the ARDTs model has strong reasoning abilities.
Table 2: Experimental Results on BIG-Bench-Hard. Lin: Linear Embedding; GPT: GPT-2 Embedding.
The results demonstrate that ARDTs possess good reasoning capabilities.
BIG-Bench HardSrivastava et al. (2023)
Human-Rater InstructGPT Codex PaLM 540BOurs
Random SOTA Lin GPT
Boolean Expressions 50 68.5 79.4 90 88.4 83.2 72.0 85.3
Navigate 50 56 81.9 68 50.4 62.4 55.4 69.2
Web-of-Lies 50 59.6 81.3 51.6 51.6 51.2 53.2 71.1
Sports Understanding 50 68.1 70.8 71.6 72.8 80.4 72.3 83.9
All Tasks (avg) 50 63.1 78.4 70.3 65.8 69.3 63.2 77.4
5 Discussion
The findings in this paper demonstrate that tree-based models have potential in language generation.
Although they do not yet match the performance of large language models, they possess certain
advantages that make them valuable for studying the emergence of intelligence on a smaller scale.
Decision trees are easier to interpret (see Appendix C for more on interpretability using ARDTs),
simpler to understand and analyze mathematically, and fast to train. Moreover, unlike standard neural
9networks, the inference time for decision trees typically increases logarithmically with their size: a
tree with depth dcan have 2dnodes but only requires traversing O(d)nodes per input.
This paper serves as a preliminary exploration into using ARDTs for language modeling tasks.
We aim to inspire further research that integrates tree-based models into current language model
pipelines, leveraging their unique strengths to enhance language generation capabilities. We believe
incorporating tree-structured models into hybrid models with Transformers could be a promising
direction for future research.
References
Anselmi, F., Rosasco, L., Tan, C., and Poggio, T. Deep convolutional networks are hierarchical kernel
machines. Center for Brains, Minds and Machines (CBMM) Memo No. 035 , 2015.
Arora, S. and Barak, B. Computational complexity: a modern approach . Cambridge University Press,
2009.
Aytekin, C. Neural networks are decision trees, 2022.
Bird, S., Klein, E., and Loper, E. Natural language processing with Python: analyzing text with the
natural language toolkit . ‚Äù O‚ÄôReilly Media, Inc.‚Äù, 2009.
Blum, A. Rank-r decision trees are a subclass of r-decision lists. Information Processing Letters , 42
(4):183‚Äì185, 1992.
Breiman, L. Random forests. Machine learning , 45:5‚Äì32, 2001.
Breiman, L., Friedman, J., Olshen, R., and Stone, C. Classification and Regression Trees . Wadsworth
Publishing, 1984.
Brutzkus, A., Daniely, A., and Malach, E. Id3 learns juntas for smoothed product distributions. In
Conference on Learning Theory , pp. 902‚Äì915. PMLR, 2020.
Bshouty, N. H. and Burroughs, L. On the proper learning of axis-parallel concepts. The Journal of
Machine Learning Research , 4:157‚Äì176, 2003.
Chen, T. and Guestrin, C. XGBoost: A scalable tree boosting system. In Proceedings of the 22nd ACM
SIGKDD International Conference on Knowledge Discovery and Data Mining , KDD ‚Äô16, pp. 785‚Äì
794, New York, NY , USA, 2016. ACM. ISBN 978-1-4503-4232-2. doi: 10.1145/2939672.2939785.
URL http://doi.acm.org/10.1145/2939672.2939785 .
Chowdhery, A., Narang, S., Devlin, J., Bosma, M., Mishra, G., Roberts, A., Barham, P., Chung, H. W.,
Sutton, C., Gehrmann, S., Schuh, P., Shi, K., Tsvyashchenko, S., Maynez, J., Rao, A., Barnes,
P., Tay, Y ., Shazeer, N., Prabhakaran, V ., Reif, E., Du, N., Hutchinson, B., Pope, R., Bradbury,
J., Austin, J., Isard, M., Gur-Ari, G., Yin, P., Duke, T., Levskaya, A., Ghemawat, S., Dev, S.,
Michalewski, H., Garcia, X., Misra, V ., Robinson, K., Fedus, L., Zhou, D., Ippolito, D., Luan, D.,
Lim, H., Zoph, B., Spiridonov, A., Sepassi, R., Dohan, D., Agrawal, S., Omernick, M., Dai, A. M.,
Pillai, T. S., Pellat, M., Lewkowycz, A., Moreira, E., Child, R., Polozov, O., Lee, K., Zhou, Z.,
Wang, X., Saeta, B., Diaz, M., Firat, O., Catasta, M., Wei, J., Meier-Hellstern, K., Eck, D., Dean,
J., Petrov, S., and Fiedel, N. Palm: Scaling language modeling with pathways, 2022.
De, S., Smith, S. L., Fernando, A., Botev, A., Cristian-Muraru, G., Gu, A., Haroun, R., Berrada, L.,
Chen, Y ., Srinivasan, S., Desjardins, G., Doucet, A., Budden, D., Teh, Y . W., Pascanu, R., Freitas,
N. D., and Gulcehre, C. Griffin: Mixing gated linear recurrences with local attention for efficient
language models, 2024.
Ehrenfeucht, A. and Haussler, D. Learning decision trees from random examples. Information and
Computation , 82(3):231‚Äì246, 1989.
Eldan, R. and Li, Y . Tinystories: How small can language models be and still speak coherent english?,
2023.
Filimonov, D. Decision tree-based syntactic language modeling . University of Maryland, College
Park, 2011.
10Friedman, J. H. Stochastic gradient boosting. Computational statistics & data analysis , 38(4):
367‚Äì378, 2002.
Grinsztajn, L., Oyallon, E., and Varoquaux, G. Why do tree-based models still outperform deep
learning on typical tabular data? Advances in Neural Information Processing Systems , 35:507‚Äì520,
2022.
Gu, A. and Dao, T. Mamba: Linear-time sequence modeling with selective state spaces, 2023.
Hakkinen, J. and Tian, J. N-gram and decision tree based language identification for written words.
InIEEE Workshop on Automatic Speech Recognition and Understanding, 2001. ASRU‚Äô01. , pp.
335‚Äì338. IEEE, 2001.
Heeman, P. A. Pos tags and decision trees for language modeling. In 1999 Joint SIGDAT Conference
on Empirical Methods in Natural Language Processing and Very Large Corpora , 1999.
Hopcroft, J. E., Motwani, R., and Ullman, J. D. Introduction to automata theory, languages, and
computation. Acm Sigact News , 32(1):60‚Äì65, 2001.
Kearns, M. and Mansour, Y . On the boosting ability of top-down decision tree learning algorithms. In
Proceedings of the twenty-eighth annual ACM symposium on Theory of computing , pp. 459‚Äì468,
1996.
Lewis, R. J. An introduction to classification and regression tree (cart) analysis. In Annual meeting of
the society for academic emergency medicine in San Francisco, California , volume 14. Citeseer,
2000.
Ma, X., Zhou, C., Kong, X., He, J., Gui, L., Neubig, G., May, J., and Zettlemoyer, L. Mega: Moving
average equipped gated attention, 2023.
Magerman, D. M. Statistical decision-tree models for parsing. arXiv preprint cmp-lg/9504030 , 1995.
Malach, E. Auto-regressive next-token predictors are universal learners. arXiv preprint
arXiv:2309.06979 , 2023.
Meek, C., Chickering, D. M., and Heckerman, D. Autoregressive tree models for time-series analysis.
InProceedings of the 2002 SIAM International Conference on Data Mining , pp. 229‚Äì244. SIAM,
2002.
Mikolov, T., Chen, K., Corrado, G., and Dean, J. Efficient estimation of word representations in
vector space, 2013.
Nallapati, R. and Allan, J. Capturing term dependencies using a sentence tree based language model.
InProceedings of CIKM , volume 2, pp. 383‚Äì390. Citeseer, 2002.
Navada, A., Ansari, A. N., Patil, S., and Sonkamble, B. A. Overview of use of decision tree algorithms
in machine learning. In 2011 IEEE control and system graduate research colloquium , pp. 37‚Äì42.
IEEE, 2011.
OpenAI, :, Achiam, J., and Steven Adler, e. a. Gpt-4 technical report, 2023.
Ouyang, L., Wu, J., Jiang, X., Almeida, D., Wainwright, C. L., Mishkin, P., Zhang, C., Agarwal,
S., Slama, K., Ray, A., Schulman, J., Hilton, J., Kelton, F., Miller, L., Simens, M., Askell, A.,
Welinder, P., Christiano, P., Leike, J., and Lowe, R. Training language models to follow instructions
with human feedback, 2022.
Poggio, T. Compositional sparsity: a framework for ml. Center for Brains, Minds and Machines
(CBMM) Memo No. 138 , 2022.
Potamianos, G. and Jelinek, F. A study of n-gram and decision tree letter language modeling methods.
Speech Communication , 24(3):171‚Äì192, 1998.
Quinlan, J. R. Induction of decision trees. Machine learning , 1:81‚Äì106, 1986.
Rivest, R. L. Learning decision lists. Machine learning , 2:229‚Äì246, 1987.
11Shwartz-Ziv, R. and Armon, A. Tabular data: Deep learning is not all you need. Information Fusion ,
81:84‚Äì90, 2022.
Srivastava, A., Rastogi, A., and Abhishek Rao, e. a. Beyond the imitation game: Quantifying and
extrapolating the capabilities of language models, 2023.
Sun, Y ., Dong, L., Huang, S., Ma, S., Xia, Y ., Xue, J., Wang, J., and Wei, F. Retentive network: A
successor to transformer for large language models, 2023.
Suzgun, M., Scales, N., Sch ¬®arli, N., Gehrmann, S., Tay, Y ., Chung, H. W., Chowdhery, A., Le, Q. V .,
Chi, E. H., Zhou, D., and Wei, J. Challenging big-bench tasks and whether chain-of-thought can
solve them, 2022.
van der Maaten, L. Barnes-hut-sne, 2013.
Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L., and
Polosukhin, I. Attention is all you need, 2023.
Wong, L., Grand, G., Lew, A. K., Goodman, N. D., Mansinghka, V . K., Andreas, J., and Tenenbaum,
J. B. From word models to world models: Translating from natural language to the probabilistic
language of thought, 2023.
Yarotsky, D. Error bounds for approximations with deep relu networks. CoRR , abs/1610.01145, 2016.
URL http://arxiv.org/abs/1610.01145 .
12A Additional Proofs
For any D, letd=‚åàlog(|D|)‚åâ+ 1and let Œ® :D‚Üí {0,1}dbe a one-to-one mapping of tokens to
Boolean vectors, s.t. Œ®1(s) = 1 for all s‚ààD.
Definition 9. A function f:DL‚ÜíDis called k-Junta if there exists a set of separate indexes
i1, . . . , i k‚àà[L]and function g:Dk‚ÜíDs.t.f(x) =g(xi1, . . . , x ik).
Lemma 10. For every k-Junta f:DL‚ÜíD, there exists a tree Tof size O
|D|k
and depth
O(klog|D|)s.t.T(Œ®(x)) =f(x)for all x‚ààDL.
Proof. LetTthe perfect binary tree of depth dk, where each level of the tree corresponds to a pair
(j, l)‚àà[k]√ó[d], and all the nodes at the level implement the condition Œ®l(xij)‚â•1. Observe that in
this construction, each leaf correspond to a specific choice of values for Œ®(xi1), . . . , Œ®(xik), and we
can set its output to be g(xi1, . . . , x ik).
Proof of Theorem 3. LetAbe some automaton, defined by transition function Œ¥:Q√óŒ£‚ÜíQ, and we
can arbitrarily extend it to Œ¥:D2‚ÜíDs.t.Œ¥(x,‚ü®PAD‚ü©) =q0for all x‚ààD. Then, from Theorem 10
there exists some tree Tof size O(|D|2)s.t. for all x‚ààDLit holds that T(Œ®(x)) =Œ¥(xL, xL‚àín).
We prove by induction that for all i‚àà[n]it holds that TAR
i(x) =qi, where qiis the state of the
automaton Aat iteration i.
‚Ä¢Let z‚ààRL,dbe the padded output of Œ®(x), i.e. z =
[Œ®(‚ü®PAD‚ü©), . . . , Œ®(‚ü®PAD‚ü©),Œ®(x1), . . . , Œ®(xn)]. Note that since xL‚àín=‚ü®PAD‚ü©
we have TAR
1(x) =T(z) =Œ¥(xL,‚ü®PAD‚ü©) =q1.
‚Ä¢ Assume that TAR
1:i‚àí1(x) = (q1, . . . , q i‚àí1). Therefore,
TAR
i(x) =T(Œ®(‚ü®PAD‚ü©, . . . ,‚ü®PAD‚ü©, x1, . . . , x n, q1, . . . , q i‚àí1))
=Œ¥(qi‚àí1, xi) =qi
Therefore, the required follows.
Proof of Theorem 6. We encode the state of the Turing machine by a string s‚ààDM+1as follows:
if the head is in state q‚ààQand at position i‚àà[M], and the memory is m1, . . . , m M‚ààŒ£, we set
s= (m1, . . . , m i‚àí1, q, m i, . . . , m M). That is, we add a token indicating the state of the head before
the cell where the head is located. Let Œ¥:Q√óŒ£‚ÜíQ√óŒ£√ó{‚ü®LEFT ‚ü©,‚ü®RIGHT ‚ü©}be the transition
function of the Turing machine. We define the following function g:D4‚ÜíD4:
g(s) =Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥x2ifx1, x2, x3/‚ààQ
qifx1‚ààQandŒ¥(x1, x2) = (q, Œ±,‚ü®RIGHT ‚ü©)
Œ±ifx1‚ààQandŒ¥(x1, x2) = (q, Œ±,‚ü®LEFT ‚ü©)
Œ±ifx2‚ààQandŒ¥(x2, x3) = (q, Œ±,‚ü®RIGHT ‚ü©)
x1ifx2‚ààQandŒ¥(x2, x3) = (q, Œ±,‚ü®LEFT ‚ü©)
x2ifx3‚ààQandŒ¥(x3, x4) = (q, Œ±,‚ü®RIGHT ‚ü©)
qifx3‚ààQandŒ¥(x3, x4) = (q, Œ±,‚ü®LEFT ‚ü©)
Observe that the function f:DM+1‚ÜíDM+1s.t.fi(s) =g(si‚àí1, si, si+1, si+2)exactly defines the
transition between the encoded states of the Turing machine. Namely, if the state of the machine at
iteration iiss, then the state at iteration i+ 1isf(s). We slightly modify gto handle the generation
of the first iteration, as follows:
Àúg(s) =Ô£±
Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£≥‚ü®SEP‚ü©x1=‚ü®PAD‚ü©andx2=‚ü®PAD‚ü©andx3=‚ü®PAD‚ü©
q0 x1=‚ü®PAD‚ü©andx2=‚ü®PAD‚ü©andx3Ã∏=‚ü®PAD‚ü©
‚ü®SEP‚ü©x2=‚ü®SEP‚ü©
g(s) otherwise
13Now, from Lemma 10 there exists a tree Tof size O(|D|4)s.t.T(Œ®(x)) = Àúg(x1, x2, x3, x4).
Lets1, . . . ,sT‚ààDM+1the encodings of the state of the Turing machine at iterations 1, . . . , T . Let
x‚ààDLbe the encoding of the input, staring with ‚ü®PAD‚ü©tokens, followed by one ‚ü®BOS‚ü©token and
the input string. Denote the output of the ARDT TARafterT¬∑(M+ 2) given the input x, where we
split the output into chunks of size M+ 2by:
TAR(x) = (z1, . . . ,zT)‚ààDT¬∑(M+2),zi‚ààDM+2
Claim: For all i‚àà[T], it holds that zi= (‚ü®SEP‚ü©,si).
Prove: We prove by induction on i.
‚Ä¢Fori= 1, notice that the input begins with 3 ‚ü®PAD‚ü©tokens, followed by the input tokens
x1, . . . , x M, and therefore by definition of Àúgwe get z1= (‚ü®SEP‚ü©, q0, x1, . . . , x M) =
(‚ü®SEP‚ü©,s1).
‚Ä¢ Assume the required holds for i. First, observe that
zi+1,1=T(Œ®(si‚àí1,M+1,‚ü®SEP‚ü©, si,1, . . . , s i,M+1)) =‚ü®SEP‚ü©
Now, assume that zi+1,1:j= (‚ü®SEP‚ü©, si+1,1, . . . , s i+1,j‚àí1). Therefore
zi+1,j+1=T(Œ®(si,j‚àí1, si,j, si,j+1, . . . , s i,M+1,‚ü®SEP‚ü©, si+1,1, . . . , s i+1,j‚àí1))
=g(si,j‚àí1, si,j, si,j+1, si,j+2) =si+1,j
and by induction we get zi+1= (‚ü®SEP‚ü©,si+1)
Therefore, Toutputs the final token of iteration TafterT(M+ 2) steps of auto-regression, which
proves the theorem.
B Additional Implementation Details
B.1 Hardware & Computational Cost
Our experiments were conducted on a single NVIDIA A100 GPU. For the Tiny Stories experiments,
the training process took approximately 1 hour, and it required about 1 second to generate 20 words
during the inference phase.
B.2 Dataset Details
Tiny Stories. As shown in Tab. 3, the training and validation datasets of Tiny Stories contain
147,273 and 21,990 stories, respectively. We use NLTK Bird et al. (2009) as the tokenizer to obtain
420,351,665 and 4,329,963 tokens from the training dataset. In the training dataset and validation
dataset, the number of words in the vocabulary is 27,455 and 11,273, respectively.
BIG-Bench-Hard is a dataset contains the selection of 23 difficult tasks from the BIG-Bench. These
tasks are identified by their resistance to being outperformed by prior language model evaluations
when compared to the average human evaluator. The BIG-Bench-Hard tasks often demand complex,
multi-step reasoning, and the use of few-shot prompting without CoT, as previously utilized in
BIG-Bench evaluations Srivastava et al. (2023), significantly underrepresents the true potential and
performance of language models.
Four representative reasoning tasks we select for evaluate our ARDTs:
(1)Boolean Expressions . Example: not (True) and (True). Answer: False.
(2)Navigate . Example: If you follow these instructions, will you return to the starting point?
Instructions: Turn left. Take 5 steps. Turn right. Answer: No.
(3)Web-of-Lies . Example: Delbert tells the truth. Delfina says Delbert lies. Antwan says Delfina tells
the truth. Does Delfina tell the truth? Answer: No.
(4)Sports Understanding . Example: Is the following sentence plausible? ‚ÄùElias Lindholm beat the
buzzer.‚Äù Answer: No.
14Table 3: Basic Information about the Tinystories Dataset.
Training dataset Validation dataset
The number of stories 147,273 21,990
The number of tokens 420,351,665 4,329,963
The word count of each story. 54 - 5,498 63 - 4,254
V ocabulary 27455 11274
B.3 Details about the Visualization of the Decision Trees
To enable visualization that treats words as features, as shown in Algorithm 1, we map word
embeddings into a lower-dimensional space. This process utilizes three primary inputs: word
embeddings Win an N√ó100matrix, where Nrepresents the number of words and 100 the
dimensionality of each embedding; cluster centers Cin a20√ó100matrix, indicating 20 clusters
within the 100-dimensional embedding space; and a mapping matrix Msized 100√ó20, designed
to reduce the embeddings‚Äô dimensionality to 20. The algorithm begins with an orthogonalization
procedure, applying QR decomposition to the transpose of C(CT) and returning the first 20 columns
ofQT, thereby establishing an orthogonal basis for the cluster space. It then projects the word
embeddings Winto this lower-dimensional space by multiplying them with the mapping matrix M.
By iterating over each word embedding in W, the algorithm applies this projection and ultimately
returns a set of transformed embeddings {E1, . . . , E N}, where each Eiprovides a lower-dimensional
representation of the corresponding word embedding. This approach allows us to treat each vector
value as individual words, facilitating a more intuitive understanding of the data.
Algorithm 1 Map Word Embeddings to Lower Dimensional Space
input
Word Embeddings W‚äÜRN√ó100
Cluster Centers C‚äÜR20√ó100
Mapping Matrix M‚äÜR100√ó20
procedure ORTHOGONALIZE (C)
Q, R‚ÜêQR Decomposition (CT)
return Q[:,: 20].T
end procedure
procedure MAPEMBEDDINGS (W,M)
return W¬∑M
end procedure
M‚ÜêORTHOGONALIZE (C)
foreach word embedding wiinWdo
Ei‚ÜêMAPEMBEDDINGS (wi, M)
end for
Return {E1, . . . , E N}
B.4 The Story Beginnings Used in Our Evaluation
In Table 6, we provide 10 examples over 100 story beginnings we used for our experiments on Tiny
Stories.
B.5 An Example on Multidimensional Scores
As an example, we took the story that appears in the example above and cut it after the word ‚Äùloud‚Äù.
We generated a completion of stories using our ARDTs and baselines, then we prompted GPT-4 to
first provide a verbal assessment and then grade the completion. The transcript of interaction is as
follows, with the parts produced by GPT-4 in italic font:
15Table 4: Generated Chain-of-Thought data for boolean expression.
Input Prompt not not ( not ( False ) ) is True and False and not True and True is
Generated PromptLet‚Äôs think step by step.
Remember that (i) expressions inside
brackets are always evaluated first and
that (ii) the order of operations from
highest priority to lowest priority is
‚Äùnot‚Äù, ‚Äùand‚Äù, ‚Äùor‚Äù, respectively. We
first simplify this expression ‚ÄùZ‚Äù as
follows: ‚ÄùZ = not not ( not ( False ) ) =
not not ( A )‚Äù where ‚ÄùA = not ( False
)‚Äù. Let‚Äôs evaluate A: A = not ( False )
= not False = True. Plugging in A, we
get: Z = not not ( A ) = not not (True)
= not not False = True. So the answer
is True.Let‚Äôs think step by step. Remember that (i) ex-
pressions inside brackets are always evaluated
first and that (ii) the order of operations from
highest priority to lowest priority is ‚Äùnot‚Äù,
‚Äùand‚Äù, ‚Äùor‚Äù, respectively. We first simplify
this expression ‚ÄùZ‚Äù as follows: ‚ÄùZ = True and
False and not True and True = A and B‚Äù where
‚ÄùA = True and False‚Äù and ‚ÄùB = not True and
True‚Äù. Let‚Äôs evaluate A: A = True and False =
False. Let‚Äôs evaluate B: B = not True and True
= not (True and True) = not (True) = False.
Plugging in A and B, we get: Z = A and B
= False and False = False. So the answer is
False.
Table 5: Generated Chain-of-Thought data for navigation.
Input PromptIf you follow these instructions, do
you return to the starting point? Al-
ways face forward. Take 2 steps
right. Take 9 steps left.Take 7 steps
right.If you follow these instructions, do you return to
the starting point? Turn around. Take 1 step. Take
6 steps. Turn around. Take 6 steps. Take 9 steps.
Take 1 step.
Generated PromptLet‚Äôs think step by step.We start at
the origin (0, 0), facing the posi-
tive y-axis.(1) Always face forward:
(0, 0), facing the positive y-axis.(2)
Take 2 steps right: (0, 2), facing the
positive y-axis.(3) Take 9 steps left:
(0, -7), facing the positive y-axis.(4)
Take 7 steps right: (0, 7), facing the
positive y-axis. Since (0, 0) is (0,
0), we are indeed where we started.
So the answer is Yes.Let‚Äôs think step by step. We start at the origin (0,
0), facing the positive y-axis. (1) Turn around: (0,
0), facing the negative y-axis. (2) Take 1 step: (0,
-1), facing the negative y-axis. (3) Take 6 steps: (0,
-7), facing the negative y-axis. (4) Turn around:
(0, -7), facing the positive y-axis. (5) Take 6 steps:
(0, -1), facing the positive y-axis. (6) Take 9 steps:
(0, 8), facing the positive y-axis. (7) Take 1 step:
(0, 9), facing the positive y-axis. Since (0, 9) is
not (0, 0), we are not where we started. So the
answer is No.
Table 6: Examples of the story beginnings generated by GPT-4. In the inference phase, we fed these
story beginnings generated by GPT-4 into the ARDTs to continue writting the stories.
The beginning of the stories (GPT-4 generated)
1 Kitty found a bright, lost treasure.
2 Thirsty, they sought a hidden pond.
3 Roxy climbed, seeking icy hill‚Äôs peak.
4 Billy‚Äôs idea sparked an unlikely friendship.
5 Leaves underfoot, Roxy ascended triumphantly.
6 Daisy, small yet happy, met Max.
7 Max‚Äôs playful antics delighted tiny Daisy.
8 Sue‚Äôs thoughtful gesture warmed her mother.
9 A candle‚Äôs flame united mother, daughter.
10 The sad cow wished for companionship.
16the following exercise, the student is given a beginning of a story. The student needs
to complete it into a full story. The exercise tests the student‚Äôs language abilities and
creativity. The symbol ‚àó ‚àó ‚àó marks the separator between the prescribed beginning
and the student‚Äôs completion :
Once upon a time, *** there wasalittlegirlnamed Lily. Sheloved toplay outside inthe
sunshine. One day, shesawabigtreeinthegarden. Shewassoexcited about it.
Please provide your general assessment about the part written by the student (the one
after the *** symbol). Is it grammatically correct? Is it consistent with the beginning
of the story? Pay special attention to whether the student manages to complete the
sentence which is split in the middle by the separator ***.
This is a charming and whimsical story about a little girl named Lily who feels excited upon
discovering a big tree in the garden.
The grammar is generally correct.
Overall, the student‚Äôs completion of the story demonstrates adequate language abilities and
creativity. However, adding more details about Lily‚Äôs exploration, as well as her thoughts
and actions after discovering the tree, could make the story more engaging and vivid.
Now, grade the student‚Äôs completion in terms of grammar, creativity, consistency with the
story‚Äôs beginning and whether the plot makes sense. Moreover, please provide your best
guess of what the age of the student might be, as reflected from the completion. Choose
from possible age groups: A: 3 or under. B: 4-5. C: 6-7. D: 8-9. E: 10-12. F: 13-16.
Grammar: 9/10, Creativity: 4/10, Consistency: 7/10, Age group: E (10-12)
C Interpretability
One advantage of using decision trees over complex neural networks is the Interpretability of the
computational process. Unlike neural networks, which rely on abstract vector operations in high-
dimensional space, decision trees implement relatively simple logic, computing their output based on
splitting criteria that may be easily displayed to, and interpreted by, humans. That said, recall that
our decision trees operate on aggregations of word vector embeddings, which make interpretability
harder to achieve. Specifically, each splitting rule of the decision tree is based on the value of
a single coordinate, which does not necessarily have an interpretable semantic value when using
rotation-invariant word embedding methods such as Word2Vec.
150
 100
 50
 0 50 100100
50
050100150
peoplechildren
dancersboysstudents
pupilsneighborsdrums
firemen
costumejacketscooter
cushionshoemask
pendresstrampolinecolourfulbright
shinycolored
yellowtall
sparklybig
green
maylynn
pleasantlybefore
giftedness
barryyvonne
janielikedsuggestedwanteddecidedwould
continuedinvitedusedbegan
amyshe
sueemilytommy
cassettesanna
momosallymaylynn
pleasantlybefore
giftedness
barryyvonne
janieanymoreany butquittoohowever
regretswithoutstill
recognizingreward
borrowedfateappreciating
servingsalesafterwarddaringwoodsrivermeadow
fieldoceansea
junglevalleyfields
kick roll
soakreachtouch
catchpickflycrawlbrought
spotted
discoveredshowedsaw
noticedledusedmadebeach playgroundmallhotel stadiumairportgymzoo swings
servedvisited
cookedgained
ateprovidedharvestedtalkedincluding
ignorecomplainargueunderstandexplain
punishquarrel
comforttalkpuppiesmicrophonesforts
eachaliens
theirsoldiers
games cameras
findingsunited
ivan
months
effortsmore
tasting
miseryricher
groundedonly
cancelled
possiblefulfilledlastsrecognition
treasuringkids
beltcolorful
everequallyloved
lily
becauselifestyleforest
climbfoundpark
shared
listenthey
worth
Figure 3: t-SNE van der Maaten (2013) visualization of 20 cluster centers. We selected 20 cluster
centers and display 4 words closest to the cluster centers.
In order to generate decision trees with meaningful splitting rules, we modify the word embedding
such that single coordinates have specific semantic values. To achieve this, we begin by clustering
all the word vectors from the dataset (over 16K words) into 20 clusters using K-means. We then
17Input Prompt: ‚ÄúLily and Tom loved to play together, and they found‚Äù. . .NYYYYY
YYYYYYYNNNNNNNNNNYYYNNN
NFigure 4: Track the decision-making process within the decision trees. We use ‚ÄôLily and Tom
loved to play together, and they found‚Äô as an the input prompt and generate the next word using our
ARDTs. We visualize part of the process within the decision tree. Specifically, we visualized 31
nodes of the first decision tree.
0.0000 0.0025 0.0050 0.0075 0.0100 0.0125 0.0150 0.0175
Importancetogether
kids
belt
colorful
ever
loved
lily
because
lifestyle
forest
climb
found
park
listen
shared
they
equally
worthFeaturesT op Feature Importances in XGBoost Model
Figure 5: Feature Importance. We present the feature importance of the top 20 words most closely
associated with each cluster, based on their average gain.
choose one representative word for each cluster, by taking the word that is closest to the center of
the cluster in the embedding space (see Figure 3 for an illustration of the clusters and representative
words). Now, these words (represented as vectors) form a basis for a new20-dimensional embedding
space, which is a linear subspace of the original 100-dimensional space of Word2Vec. We use these
basis words to compute the new word embedding, by projecting each vector from the original space
into this subspace, and representating the projection as a linear combination of the basis words.
Mathematically, if x1, . . . , x kare the basis words, we define our new embedding Œ¶intoRkby:
Œ¶(x) = arg min z‚ààRk‚à•P
iziŒ®(xi)‚àíŒ®(x)‚à•2. Observe that each basis word xiis mapped by Œ¶to
a unit vector ei. Intuitively, the i-th coordinate of the embedding Œ¶now represents words that are
18semantically similar to the word xi. Now, splitting rules based on the coordinate ican be interpreted
as ‚Äútesting‚Äù whether a word similar to xiappears in the sentence.
We visualize one of the decision trees trained on the Tiny Stories Dataset using the new ‚Äúinterpretable‚Äù
embedding Œ¶in Figure 1. Note that, unlike complex neural network architectures, which carry out
opaque computations, the decision process of the ARDT with the new embedding appears to be
semantically meaningful. For example, observe that the word Lilyappears for three times as the
most relevant word during node splits. Considering Lilyis a frequently occurring name in the Tiny
Stories dataset, it‚Äôs frequent appearance in the tree can be deemed reasonable. We further analyze
the importance of different features by plotting their importance score. We plot the importance of
each cluster, represented by a single word, in Figure 5. We assess the importance of each cluster by
calculating its average gain during every split within the model.
In Figure 4, we use the input sentence ‚ÄúLily and Tom loved to play together and they found‚Äù as an
example to visualize part of the decision-making process of the first decision tree in the ensemble.
We note that each feature corresponds to a single cluster, represented by a single word, e.g. the
feature f2corresponds to the word ‚ÄúLily‚Äù. That is, the word ‚ÄúLily‚Äù will be mapped to the unit vector
e2= (0,1,0, . . . , 0). Note that most words (besides the 20 words used as a basis for the embedding),
will be mapped to a linear combination of the basis words, and so can also affect (positively or
negatively) the value of the feature f2. Since the input vector is a weighted-average of the embedding
of all words, the decision when splitting on the feature f2may be affected by multiple words in the
sentence.
19NeurIPS Paper Checklist 596
1.Claims 597
Question: Do the main claims made in the abstract and introduction accurately reflect the 598
paper‚Äôs contributions and scope? 599
Answer: [Yes] 600
Justification: The abstract and introduction clearly state the main theoretical and empirical 601
contributions in this paper. 602
Guidelines: 603
‚Ä¢The answer NA means that the abstract and introduction do not include the claims 604
made in the paper. 605
‚Ä¢The abstract and/or introduction should clearly state the claims made, including the 606
contributions made in the paper and important assumptions and limitations. A No or 607
NA answer to this question will not be perceived well by the reviewers. 608
‚Ä¢The claims made should match theoretical and experimental results, and reflect how 609
much the results can be expected to generalize to other settings. 610
‚Ä¢It is fine to include aspirational goals as motivation as long as it is clear that these goals 611
are not attained by the paper. 612
2.Limitations 613
Question: Does the paper discuss the limitations of the work performed by the authors? 614
Answer: [Yes] 615
Justification: See the Discussion section. 616
Guidelines: 617
‚Ä¢The answer NA means that the paper has no limitation while the answer No means that 618
the paper has limitations, but those are not discussed in the paper. 619
‚Ä¢ The authors are encouraged to create a separate ‚ÄùLimitations‚Äù section in their paper. 620
‚Ä¢The paper should point out any strong assumptions and how robust the results are to 621
violations of these assumptions (e.g., independence assumptions, noiseless settings, 622
model well-specification, asymptotic approximations only holding locally). The authors 623
should reflect on how these assumptions might be violated in practice and what the 624
implications would be. 625
‚Ä¢The authors should reflect on the scope of the claims made, e.g., if the approach was 626
only tested on a few datasets or with a few runs. In general, empirical results often 627
depend on implicit assumptions, which should be articulated. 628
‚Ä¢The authors should reflect on the factors that influence the performance of the approach. 629
For example, a facial recognition algorithm may perform poorly when image resolution 630
is low or images are taken in low lighting. Or a speech-to-text system might not be 631
used reliably to provide closed captions for online lectures because it fails to handle 632
technical jargon. 633
‚Ä¢The authors should discuss the computational efficiency of the proposed algorithms 634
and how they scale with dataset size. 635
‚Ä¢If applicable, the authors should discuss possible limitations of their approach to 636
address problems of privacy and fairness. 637
‚Ä¢While the authors might fear that complete honesty about limitations might be used by 638
reviewers as grounds for rejection, a worse outcome might be that reviewers discover 639
limitations that aren‚Äôt acknowledged in the paper. The authors should use their best 640
judgment and recognize that individual actions in favor of transparency play an impor- 641
tant role in developing norms that preserve the integrity of the community. Reviewers 642
will be specifically instructed to not penalize honesty concerning limitations. 643
3.Theory Assumptions and Proofs 644
Question: For each theoretical result, does the paper provide the full set of assumptions and 645
a complete (and correct) proof? 646
Answer: [Yes] 647
20Justification: The theoretical results and their assumptions are explicitly stated in . The 648
proofs are provided in the main text and the supplementary material. 649
Guidelines: 650
‚Ä¢ The answer NA means that the paper does not include theoretical results. 651
‚Ä¢All the theorems, formulas, and proofs in the paper should be numbered and cross- 652
referenced. 653
‚Ä¢All assumptions should be clearly stated or referenced in the statement of any theorems. 654
‚Ä¢The proofs can either appear in the main paper or the supplemental material, but if 655
they appear in the supplemental material, the authors are encouraged to provide a short 656
proof sketch to provide intuition. 657
‚Ä¢Inversely, any informal proof provided in the core of the paper should be complemented 658
by formal proofs provided in appendix or supplemental material. 659
‚Ä¢ Theorems and Lemmas that the proof relies upon should be properly referenced. 660
4.Experimental Result Reproducibility 661
Question: Does the paper fully disclose all the information needed to reproduce the main ex- 662
perimental results of the paper to the extent that it affects the main claims and/or conclusions 663
of the paper (regardless of whether the code and data are provided or not)? 664
Answer: [Yes] 665
Justification: The experimental results and how to reproduce them are fully disclosed in the 666
experimental section. 667
Guidelines: 668
‚Ä¢ The answer NA means that the paper does not include experiments. 669
‚Ä¢If the paper includes experiments, a No answer to this question will not be perceived 670
well by the reviewers: Making the paper reproducible is important, regardless of 671
whether the code and data are provided or not. 672
‚Ä¢If the contribution is a dataset and/or model, the authors should describe the steps taken 673
to make their results reproducible or verifiable. 674
‚Ä¢Depending on the contribution, reproducibility can be accomplished in various ways. 675
For example, if the contribution is a novel architecture, describing the architecture fully 676
might suffice, or if the contribution is a specific model and empirical evaluation, it may 677
be necessary to either make it possible for others to replicate the model with the same 678
dataset, or provide access to the model. In general. releasing code and data is often 679
one good way to accomplish this, but reproducibility can also be provided via detailed 680
instructions for how to replicate the results, access to a hosted model (e.g., in the case 681
of a large language model), releasing of a model checkpoint, or other means that are 682
appropriate to the research performed. 683
‚Ä¢While NeurIPS does not require releasing code, the conference does require all submis- 684
sions to provide some reasonable avenue for reproducibility, which may depend on the 685
nature of the contribution. For example 686
(a)If the contribution is primarily a new algorithm, the paper should make it clear how 687
to reproduce that algorithm. 688
(b)If the contribution is primarily a new model architecture, the paper should describe 689
the architecture clearly and fully. 690
(c)If the contribution is a new model (e.g., a large language model), then there should 691
either be a way to access this model for reproducing the results or a way to reproduce 692
the model (e.g., with an open-source dataset or instructions for how to construct 693
the dataset). 694
(d)We recognize that reproducibility may be tricky in some cases, in which case 695
authors are welcome to describe the particular way they provide for reproducibility. 696
In the case of closed-source models, it may be that access to the model is limited in 697
some way (e.g., to registered users), but it should be possible for other researchers 698
to have some path to reproducing or verifying the results. 699
5.Open access to data and code 700
21Question: Does the paper provide open access to the data and code, with sufficient instruc- 701
tions to faithfully reproduce the main experimental results, as described in supplemental 702
material? 703
Answer: [Yes] 704
Justification: The paper provides all the information about the data, models, and implemen- 705
tation. Code will be available upon publication. 706
Guidelines: 707
‚Ä¢ The answer NA means that paper does not include experiments requiring code. 708
‚Ä¢Please see the NeurIPS code and data submission guidelines ( https://nips.cc/ 709
public/guides/CodeSubmissionPolicy ) for more details. 710
‚Ä¢While we encourage the release of code and data, we understand that this might not be 711
possible, so ‚ÄúNo‚Äù is an acceptable answer. Papers cannot be rejected simply for not 712
including code, unless this is central to the contribution (e.g., for a new open-source 713
benchmark). 714
‚Ä¢The instructions should contain the exact command and environment needed to run to 715
reproduce the results. See the NeurIPS code and data submission guidelines ( https: 716
//nips.cc/public/guides/CodeSubmissionPolicy ) for more details. 717
‚Ä¢The authors should provide instructions on data access and preparation, including how 718
to access the raw data, preprocessed data, intermediate data, and generated data, etc. 719
‚Ä¢The authors should provide scripts to reproduce all experimental results for the new 720
proposed method and baselines. If only a subset of experiments are reproducible, they 721
should state which ones are omitted from the script and why. 722
‚Ä¢At submission time, to preserve anonymity, the authors should release anonymized 723
versions (if applicable). 724
‚Ä¢Providing as much information as possible in supplemental material (appended to the 725
paper) is recommended, but including URLs to data and code is permitted. 726
6.Experimental Setting/Details 727
Question: Does the paper specify all the training and test details (e.g., data splits, hyper- 728
parameters, how they were chosen, type of optimizer, etc.) necessary to understand the 729
results? 730
Answer: [Yes] 731
Justification: The paper provides detailed explanations of the implementation and settings. 732
Guidelines: 733
‚Ä¢ The answer NA means that the paper does not include experiments. 734
‚Ä¢The experimental setting should be presented in the core of the paper to a level of detail 735
that is necessary to appreciate the results and make sense of them. 736
‚Ä¢The full details can be provided either with the code, in appendix, or as supplemental 737
material. 738
7.Experiment Statistical Significance 739
Question: Does the paper report error bars suitably and correctly defined or other appropriate 740
information about the statistical significance of the experiments? 741
Answer: [Yes] 742
Justification: The experiments examine all the configurations. 743
Guidelines: 744
‚Ä¢ The answer NA means that the paper does not include experiments. 745
‚Ä¢The authors should answer ‚ÄùYes‚Äù if the results are accompanied by error bars, confi- 746
dence intervals, or statistical significance tests, at least for the experiments that support 747
the main claims of the paper. 748
‚Ä¢The factors of variability that the error bars are capturing should be clearly stated (for 749
example, train/test split, initialization, random drawing of some parameter, or overall 750
run with given experimental conditions). 751
22‚Ä¢The method for calculating the error bars should be explained (closed form formula, 752
call to a library function, bootstrap, etc.) 753
‚Ä¢ The assumptions made should be given (e.g., Normally distributed errors). 754
‚Ä¢It should be clear whether the error bar is the standard deviation or the standard error 755
of the mean. 756
‚Ä¢It is OK to report 1-sigma error bars, but one should state it. The authors should 757
preferably report a 2-sigma error bar than state that they have a 96% CI, if the hypothesis 758
of Normality of errors is not verified. 759
‚Ä¢For asymmetric distributions, the authors should be careful not to show in tables or 760
figures symmetric error bars that would yield results that are out of range (e.g. negative 761
error rates). 762
‚Ä¢If error bars are reported in tables or plots, The authors should explain in the text how 763
they were calculated and reference the corresponding figures or tables in the text. 764
8.Experiments Compute Resources 765
Question: For each experiment, does the paper provide sufficient information on the com- 766
puter resources (type of compute workers, memory, time of execution) needed to reproduce 767
the experiments? 768
Answer: [Yes] 769
Justification: We disclose all of the information about the computational resources in the 770
section about the experiments. 771
Guidelines: 772
‚Ä¢ The answer NA means that the paper does not include experiments. 773
‚Ä¢The paper should indicate the type of compute workers CPU or GPU, internal cluster, 774
or cloud provider, including relevant memory and storage. 775
‚Ä¢The paper should provide the amount of compute required for each of the individual 776
experimental runs as well as estimate the total compute. 777
‚Ä¢The paper should disclose whether the full research project required more compute 778
than the experiments reported in the paper (e.g., preliminary or failed experiments that 779
didn‚Äôt make it into the paper). 780
9.Code Of Ethics 781
Question: Does the research conducted in the paper conform, in every respect, with the 782
NeurIPS Code of Ethics https://neurips.cc/public/EthicsGuidelines ? 783
Answer: [Yes] 784
Justification: The research follow the NeurIPS Code of Ethics. 785
Guidelines: 786
‚Ä¢The answer NA means that the authors have not reviewed the NeurIPS Code of Ethics. 787
‚Ä¢If the authors answer No, they should explain the special circumstances that require a 788
deviation from the Code of Ethics. 789
‚Ä¢The authors should make sure to preserve anonymity (e.g., if there is a special consid- 790
eration due to laws or regulations in their jurisdiction). 791
10.Broader Impacts 792
Question: Does the paper discuss both potential positive societal impacts and negative 793
societal impacts of the work performed? 794
Answer: [Yes] 795
Justification: Please refer to the Discussion section. 796
Guidelines: 797
‚Ä¢ The answer NA means that there is no societal impact of the work performed. 798
‚Ä¢If the authors answer NA or No, they should explain why their work has no societal 799
impact or why the paper does not address societal impact. 800
23‚Ä¢Examples of negative societal impacts include potential malicious or unintended uses 801
(e.g., disinformation, generating fake profiles, surveillance), fairness considerations 802
(e.g., deployment of technologies that could make decisions that unfairly impact specific 803
groups), privacy considerations, and security considerations. 804
‚Ä¢The conference expects that many papers will be foundational research and not tied 805
to particular applications, let alone deployments. However, if there is a direct path to 806
any negative applications, the authors should point it out. For example, it is legitimate 807
to point out that an improvement in the quality of generative models could be used to 808
generate deepfakes for disinformation. On the other hand, it is not needed to point out 809
that a generic algorithm for optimizing neural networks could enable people to train 810
models that generate Deepfakes faster. 811
‚Ä¢The authors should consider possible harms that could arise when the technology is 812
being used as intended and functioning correctly, harms that could arise when the 813
technology is being used as intended but gives incorrect results, and harms following 814
from (intentional or unintentional) misuse of the technology. 815
‚Ä¢If there are negative societal impacts, the authors could also discuss possible mitigation 816
strategies (e.g., gated release of models, providing defenses in addition to attacks, 817
mechanisms for monitoring misuse, mechanisms to monitor how a system learns from 818
feedback over time, improving the efficiency and accessibility of ML). 819
11.Safeguards 820
Question: Does the paper describe safeguards that have been put in place for responsible 821
release of data or models that have a high risk for misuse (e.g., pretrained language models, 822
image generators, or scraped datasets)? 823
Answer: [NA] 824
Justification: No new data or models are released. 825
Guidelines: 826
‚Ä¢ The answer NA means that the paper poses no such risks. 827
‚Ä¢Released models that have a high risk for misuse or dual-use should be released with 828
necessary safeguards to allow for controlled use of the model, for example by requiring 829
that users adhere to usage guidelines or restrictions to access the model or implementing 830
safety filters. 831
‚Ä¢Datasets that have been scraped from the Internet could pose safety risks. The authors 832
should describe how they avoided releasing unsafe images. 833
‚Ä¢We recognize that providing effective safeguards is challenging, and many papers do 834
not require this, but we encourage authors to take this into account and make a best 835
faith effort. 836
12.Licenses for existing assets 837
Question: Are the creators or original owners of assets (e.g., code, data, models), used in 838
the paper, properly credited and are the license and terms of use explicitly mentioned and 839
properly respected? 840
Answer: [Yes] 841
Justification: The authors are the creators. 842
Guidelines: 843
‚Ä¢ The answer NA means that the paper does not use existing assets. 844
‚Ä¢ The authors should cite the original paper that produced the code package or dataset. 845
‚Ä¢The authors should state which version of the asset is used and, if possible, include a 846
URL. 847
‚Ä¢ The name of the license (e.g., CC-BY 4.0) should be included for each asset. 848
‚Ä¢For scraped data from a particular source (e.g., website), the copyright and terms of 849
service of that source should be provided. 850
‚Ä¢If assets are released, the license, copyright information, and terms of use in the 851
package should be provided. For popular datasets, paperswithcode.com/datasets 852
has curated licenses for some datasets. Their licensing guide can help determine the 853
license of a dataset. 854
24‚Ä¢For existing datasets that are re-packaged, both the original license and the license of 855
the derived asset (if it has changed) should be provided. 856
‚Ä¢If this information is not available online, the authors are encouraged to reach out to 857
the asset‚Äôs creators. 858
13.New Assets 859
Question: Are new assets introduced in the paper well documented and is the documentation 860
provided alongside the assets? 861
Answer: [Yes] 862
Justification: The paper describes in detail the implementation of the new methods and the 863
code used for the experiments. 864
Guidelines: 865
‚Ä¢ The answer NA means that the paper does not release new assets. 866
‚Ä¢Researchers should communicate the details of the dataset/code/model as part of their 867
submissions via structured templates. This includes details about training, license, 868
limitations, etc. 869
‚Ä¢The paper should discuss whether and how consent was obtained from people whose 870
asset is used. 871
‚Ä¢At submission time, remember to anonymize your assets (if applicable). You can either 872
create an anonymized URL or include an anonymized zip file. 873
14.Crowdsourcing and Research with Human Subjects 874
Question: For crowdsourcing experiments and research with human subjects, does the paper 875
include the full text of instructions given to participants and screenshots, if applicable, as 876
well as details about compensation (if any)? 877
Answer: [NA] 878
Justification: The paper does not involve crowdsourcing nor research with human subjects. 879
Guidelines: 880
‚Ä¢The answer NA means that the paper does not involve crowdsourcing nor research with 881
human subjects. 882
‚Ä¢Including this information in the supplemental material is fine, but if the main contribu- 883
tion of the paper involves human subjects, then as much detail as possible should be 884
included in the main paper. 885
‚Ä¢According to the NeurIPS Code of Ethics, workers involved in data collection, curation, 886
or other labor should be paid at least the minimum wage in the country of the data 887
collector. 888
15.Institutional Review Board (IRB) Approvals or Equivalent for Research with Human 889
Subjects 890
Question: Does the paper describe potential risks incurred by study participants, whether 891
such risks were disclosed to the subjects, and whether Institutional Review Board (IRB) 892
approvals (or an equivalent approval/review based on the requirements of your country or 893
institution) were obtained? 894
Answer: [NA] 895
Justification: The paper does not involve crowdsourcing nor research with human subjects. 896
Guidelines: 897
‚Ä¢The answer NA means that the paper does not involve crowdsourcing nor research with 898
human subjects. 899
‚Ä¢Depending on the country in which research is conducted, IRB approval (or equivalent) 900
may be required for any human subjects research. If you obtained IRB approval, you 901
should clearly state this in the paper. 902
‚Ä¢We recognize that the procedures for this may vary significantly between institutions 903
and locations, and we expect authors to adhere to the NeurIPS Code of Ethics and the 904
guidelines for their institution. 905
‚Ä¢For initial submissions, do not include any information that would break anonymity (if 906
applicable), such as the institution conducting the review. 907
25