NeuroCUT: A Neural Approach for Robust Graph Partitioning
Rishi Shahâˆ—
Department of Computer Science and
Engineering, IIT Delhi
Delhi, India
rishi.shah10122001@gmail.comKrishnanshu Jainâˆ—
Department of Computer Science and
Engineering, IIT Delhi
Delhi, India
krishnanshu1907@gmail.comSahil Manchandaâˆ—
Department of Computer Science and
Engineering, IIT Delhi
Delhi, India
sahilm1992@gmail.com
Sourav Medya
University of Illinois
Chicago, USA
medya@uic.eduSayan Ranu
Department of Computer Science and
Engineering, IIT Delhi, India
Delhi, India
sayanranu@iitd.ac.in
ABSTRACT
Graph partitioning aims to divide a graph into ğ‘˜disjoint subsets
while optimizing a specific partitioning objective. The majority of
formulations related to graph partitioning exhibit NP-hardness due
to their combinatorial nature. Conventional methods, like approx-
imation algorithms or heuristics, are designed for distinct parti-
tioning objectives and fail to achieve generalization across other
important partitioning objectives. Recently machine learning-based
methods have been developed that learn directly from data. Further,
these methods have a distinct advantage of utilizing node features
that carry additional information. However, these methods assume
differentiability of target partitioning objective functions and can-
not generalize for an unknown number of partitions, i.e., they as-
sume the number of partitions is provided in advance. In this study,
we develop NeuroCUT with two key innovations over previous
methodologies. First, by leveraging a reinforcement learning-based
framework over node representations derived from a graph neural
network and positional features, NeuroCUT can accommodate any
optimization objective, even those with non-differentiable func-
tions. Second, we decouple the parameter space and the partition
count making NeuroCUT inductive to any unseen number of parti-
tion, which is provided at query time. Through empirical evaluation,
we demonstrate that NeuroCUT excels in identifying high-quality
partitions, showcases strong generalization across a wide spectrum
of partitioning objectives, and exhibits strong generalization to
unseen partition count.
CCS CONCEPTS
â€¢Computing methodologies â†’Machine learning; Artificial
intelligence; â€¢Mathematics of computing â†’Graph algo-
rithms; Graph algorithms.
âˆ—These authors contributed equally to this research.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08.
https://doi.org/10.1145/3637528.3671815KEYWORDS
Graph Partitioning, Min Cut, Robustness, Versatile Partitioning
Objectives, Inductive learning, GNN, Reinforcement learning.
ACM Reference Format:
Rishi Shah, Krishnanshu Jain, Sahil Manchanda, Sourav Medya, and Sayan
Ranu. 2024. NeuroCUT: A Neural Approach for Robust Graph Partitioning.
In30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining
(KDD â€™24), August 25â€“29, 2024, 2024, Barcelona, Spain. ACM, New York, NY,
USA, 12 pages. https://doi.org/10.1145/3637528.3671815
1 INTRODUCTION
Graph partitioning is a fundamental problem in network analysis
with numerous real-world applications in various domains such as
system design in online social networks [ 37], dynamic ride-sharing
in transportation systems [ 43], VLSI design [ 18], and preventing
cascading failure in power grids [ 26]. The goal of graph partitioning
is to divide a given graph into disjoint subsets where nodes within
each subset exhibit strong internal connections while having limited
connections with nodes in other subsets. Generally speaking, the
aim is to find somewhat balanced partitions while minimizing the
number of edges across partitions.
1.1 Related Work
Several graph partitioning formulations have been studied in the
literature, mostly in the form of discrete optimization [ 2,8,20â€“22].
The majority of the formulations are NP-hard and thus the proposed
solutions are either heuristics or algorithms with approximate solu-
tions [ 20]. Among these, two widely used methods are Spectral Clus-
tering [ 35] and hMETIS [ 20]. Spectral Clustering partitions a graph
into clusters based on the eigenvectors of a similarity matrix de-
rived from the graph. hMETIS is a hypergraph partitioning method
that divides a graph into clusters by maximizing intra-cluster sim-
ilarity while minimizing inter-cluster similarity. However, such
techniques are confined to specific objective functions and are un-
able to leverage the available node features in the graph. Recently,
there have been attempts to solve graph partitioning problem via
neural approaches. The neural approaches have a distinct advantage
that they can utilize node features. Node features supply additional
information and provide contextual insights that may improve the
accuracy of graph partitioning. For instance, [ 47] has recognized
the importance of incorporating node attributes in graph clustering
 
2584
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Rishi Shah, Krishnanshu Jain, Sahil Manchanda, Sourav Medya, & Sayan Ranu
where nodes are partitioned into disjoint groups. Note that there are
existing neural approaches [ 11,14,16,23,24,29â€“32,38,44] to solve
other NP-hard graph combinatorial problems (e.g., minimum vertex
cover). However these methods are not generic enough to solve
graph partitioning. For example, although S2VDQN [ 23] learns to
solve the Maxcut problem, it is designed for the specific case of
bi-partitioning. This hinders its applicability to the target problem
setup ofğ‘˜-way partitioning.
In this paper, we build a single framework to solve several graph
partitioning problems. One of the most relevant to our work is the
method DMoN by Tsitsulin et al . [45] . This method designs a neural
architecture for cluster assignments and use a modularity-based ob-
jective function for optimizing these assignments. Another method,
that is relevant to our work is GAP, which is an unsupervised
learning method to solve the balanced graph partitioning prob-
lem [34]. It proposes a differentiable loss function for partitioning
based on a continuous relaxation of the normalized cut formulation.
Deep-MinCut being an unsupervised approach learns both node
embeddings and the community structures simultaneously where
the objective is to minimize the mincut loss [ 9]. Another method
solves the multicut problem where the number of partitions is not
an input to the problem [ 17]. The idea is to construct a reformu-
lation of the multicut ILP constraints to a polynomial program
as a loss function. However, the problem formulation is different
than the generic normalized cut or mincut problem. Another related
work is DGCluster [ 3], which proposes to solve the attributed graph
clustering problem while maximizing modularity when ğ‘˜is not
known beforehand. Finally, [ 12] solves the normalized cut problem
only for the case where the number of partitions is exactly two.
Nevertheless, these neural approaches for the graph partitioning
problem often do not use node features and only limited to a distinct
partitioning objective. Here, we point out notable drawbacks that
we address in our framework.
â€¢Non-inductivity to partition count: The number of partitions
required to segment a graph is an input parameter. Hence, it
is important for a learned model to generalize to any partition
count without retraining. In ğ‘˜-way graph partitioning, a model
demonstrates inductivity to the number of partitions when it can
infer on varying partition numbers without specific training for
each. Existing neural approaches are non-inductive to the num-
ber of partitions, i.e they can only infer on number of partitions
on which they are trained. Additionally, it is worth noting that
the optimal number of partitions is often unknown beforehand.
This capability is crucial in practical applications like chip design,
where graph partitioning optimizes logic cell placement by divid-
ing netlists (circuits) into smaller subgraphs, aiding independent
placement. As the optimal partition count is frequently unknown
in advance, experimenting with different partition numbers is a
common practice. Hence, it is a common practice to experiment
with different partition counts and evaluate their impact on the
partitioning objective. While the existing methods [ 12,34,45]
assume that the number of partitions ( ğ‘˜) is known beforehand,
our proposed method can generalize to any ğ‘˜.
â€¢Non-generalizability to different cut functions: Multiple
objective functions for graph cut have been studied in the parti-
tioning literature. The optimal objective function hinges upon
the subsequent application in question. For instance, the twomost relevant studies, DMoN [ 45] and GAP [ 34] focus on maxi-
mizing modularity and minimizing normalized cut respectively.
Our framework is generic and can solve different partitioning
objectives.
â€¢Assumption of differential objective function: Existing neu-
ral approaches assume the objective function to be differentiable.
As we illustrate in Â§ 2, the assumption does not always hold in
the real-world. For instance, the sparsest cut [ 7] and balanced
cut [34] objectives are not differentiable.
1.2 Our Contributions
In this paper, we circumvent the above-mentioned limitations through
the following key contributions.
â€¢Versatile objectives: We develop NeuroCUT; an auto-regressive,
graph reinforcement learning framework that integrates posi-
tional information, to solve the graph partitioning problem for
attributed graphs. Diverging from conventional algorithms, Neu-
roCUT can solve multiple partitioning objectives. Moreover, un-
like other neural methods, NeuroCUT can accommodate diverse
partitioning objectives, without the necessity for differentiability.
â€¢Inductivity to number of partitions: The parameter space of
NeuroCUT is independent of the partition count. This innova-
tive decoupled architecture endows NeuroCUT with the ability
to generalize effectively to arbitrary partition count specified
during inference.
â€¢Empirical Assessment: We perform comprehensive experi-
ments employing real-world datasets, evaluating NeuroCUT
across four distinct graph partitioning objectives. Our empirical
investigation substantiates the efficacy of NeuroCUT in parti-
tioning tasks, showcasing its robustness across a spectrum of
objective functions. We also demonstrate the capability of Neu-
roCUT to generalize effectively to partition sizes that have not
been seen during training.
2 PROBLEM FORMULATION
In this section, we introduce the concepts central to our work and
formulate the problem. All the notations used in this work are
outlined in Table 1.
Definition 1 (Graph). We denote a graph as G=(V,E,X)
whereVis the set of nodes, E âŠ†VÃ—V is the set of edges and
XâˆˆR|V|Ã—|ğ¹|refers to node feature matrix where ğ¹is the set of all
features in graphG.
Definition 2 (Cut). A cutC=(S,T)is a partition ofVinto
two subsetsSandT. The cut-set ofC=(S,T)is the set{(ğ‘¢,ğ‘£)âˆˆ
E|ğ‘¢âˆˆS,ğ‘£âˆˆT} of edges that have one endpoint in Sand the other
endpoint inT.
Definition 3 (Graph Partitioning). Given graphG, we aim
to partitionGintoğ‘˜disjoint setsP={ğ‘ƒ1,ğ‘ƒ2,Â·Â·Â·,ğ‘ƒğ‘˜}such that the
union of the nodes in those sets is equal to Vi.eâˆªğ‘˜
ğ‘–=1ğ‘ƒğ‘–=Vand
each node belongs to exactly one partition.
Partitioning Objective: We aim to minimize/maximize a parti-
tioning objective of the form ğ‘‚ğ‘ğ‘—(G,P). A wide variety of objec-
tives for graph partitioning have been proposed in the literature.
 
2585NeuroCUT: A Neural Approach for Robust Graph Partitioning KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Without loss of generality, we consider the following four objec-
tives. These objectives are chosen due to being well studied in the
literature, while also being diverse from each other.1
(1)ğ‘˜-MinCut [ 39]:Partition a graph into ğ‘˜partitions such that the
total number of edges across partitions is minimized.
ğ‘˜-mincut(P)=|P|âˆ‘ï¸
ğ‘™=1|cut
ğ‘ƒğ‘™,ğ‘ƒğ‘™
|
Ã
ğ‘’âˆˆE|ğ‘’|(1)
Hereğ‘ƒğ‘™refers to the set of elements in ğ‘™ğ‘¡â„partition ofPas
described in Def. 3 and ğ‘ƒğ‘™refers to set of elements not in ğ‘ƒğ‘™.
(2)Normalized Cut [ 41]:Theğ‘˜-MinCut criteria favors cutting small
sets of isolated nodes in the graph. To avoid this unnatural
bias for partitioning out small sets of points, normalised cut
computes the cut cost as a fraction of the total edge connections
to all the nodes in the graph.
Ncut(P):=|P|âˆ‘ï¸
ğ‘™=1|cut
ğ‘ƒğ‘™,ğ‘ƒğ‘™
|
vol(ğ‘ƒğ‘™,V)(2)
Here, vol(ğ‘ƒğ‘™,V):=Ã
ğ‘£ğ‘–âˆˆğ‘ƒğ‘™,ğ‘£ğ‘—âˆˆVğ‘’(ğ‘£ğ‘–,ğ‘£ğ‘—).
(3)Balanced Cut [ 34]:Balanced cut favours partitions of equal sizes
so an extra term that indicates the squared distance from equal
sized partition is added to normalized cuts.
Balanced-Cuts(P):=|P|âˆ‘ï¸
ğ‘™=1|cut
ğ‘ƒğ‘™,ğ‘ƒğ‘™
|
vol(ğ‘ƒğ‘™,V)+(|ğ‘ƒğ‘™|âˆ’|V|/ğ‘˜)2
|V|2(3)
Here, vol(ğ‘ƒğ‘™,V):=Ã
ğ‘£ğ‘–âˆˆğ‘ƒğ‘™,ğ‘£ğ‘—âˆˆVğ‘’(ğ‘£ğ‘–,ğ‘£ğ‘—)
(4)Sparsest Cut [ 7]: Two-way sparsest cuts minimize the cut edges
relative to the number of nodes in the smaller partition. We
generalize it to ğ‘˜-way sparsest cuts by summing up the value
for all the partitions. The intuition behind sparsest cuts is that
any partition should neither be very large nor very small.
Sparsest-Cuts(P)=|P|âˆ‘ï¸
ğ‘™=1ğœ™(ğ‘ƒğ‘™,ğ‘ƒğ‘™) (4)
ğ‘¤â„ğ‘’ğ‘Ÿğ‘’ ğœ™(ğ‘†,Â¯ğ‘†)=cut(ğ‘†,Â¯ğ‘†)
min(|ğ‘†|,|Â¯ğ‘†|)(5)
Problem 1 (Learning to Partition Graph ). Given a graph
Gand the number of partitions ğ‘˜, the goal is to find a partitioning P
of the graphGthat optimizes a target objective function ğ‘‚ğ‘ğ‘—(G,P).
Towards this end, we aim to learn a policy ğœ‹that assigns each node
ğ‘£âˆˆV to a partition inP.
In addition to our primary goal of finding a partitioning that
optimizes a certain objective function, we also desire policy ğœ‹to
have the following properties:
(1)Inductive: Policyğœ‹is inductive if the parameters of the policy
are independent of both the size of the graph and the number of
partitionsğ‘˜. If the policy is not inductive then it will be unable
to infer on unseen size graphs/number of partitions.
(2)Learning Versatile Objectives: To optimize the parameters
of the policy, a target objective function is required. The opti-
mization objective may not be differentiable and it might not be
always possible to obtain a differentiable formulation. Hence,
1Our framework is not restricted to these objectives.Table 1: Notations used in the paper
Symb
ol Meaning
G Graph
V No
de set
ğ‘’ Edgeğ‘’âˆˆ
E
E Edge
set
X Featur
e matrix containing raw node features
Nğ‘£ Neighb
oring nodes of node ğ‘£
ğ‘‚
ğ‘ğ‘—(G,P)Objective function based upon graph Gand its
partitioningP
ğ‘˜ Numb
er of partitions
Pğ‘¡Partitioning
at timeğ‘¡
ğ‘ƒğ‘¡
ğ‘–ğ‘–ğ‘¡
â„partition at time ğ‘¡
ğ‘ƒğ‘– Set
of nodes that are not in the ğ‘–ğ‘¡â„partition
Sğ‘¡State
of system at step ğ‘¡
P
ART(Pğ‘¡,ğ‘£)Partition of node ğ‘£at timeğ‘¡
Sğ‘¡ State representation of Partitions and Graph at
stepğ‘¡
p
os(ğ‘£) Positional embedding of node ğ‘£
emb init(ğ‘£) Initial
embedding of node ğ‘£
ğ›¼ Numb
er of anchor nodes for lipschitz embedding
ğ‘‡ Length
of trajectory
ğœ‹ Policy
function
the policyğœ‹should be capable of learning to optimize for a
target objective that may or may not be differentiable.
3NEUROCUT: PROPOSED METHODOLOGY
Fig. 1 describes the framework of NeuroCUT. For a given input
graphG, we first construct the initial partitions of nodes using a
clustering based approach. Subsequently, a message-passing Gnn
embeds the nodes of the graph ensuring inductivity to different
graph sizes. Next, the assignment of nodes to partitions proceeds in
a two-phased strategy. We first select a node to change its partition
and then we choose a suitable partition for the selected node. Fur-
ther, to ensure inductivity on the number of partitions, we decouple
the number of partitions from the direct output representations
of the model. This decoupling allows us to query the model to an
unseen number of partitions. After a nodeâ€™s partition is updated,
thereward with respect to change in partitioning objective value
is computed and the parameters of the policy are optimized. The
reward is learned through reinforcement learning (RL) [42].
The choice of using RL is motivated through two observations.
Firstly, cut problems on graphs are generally recognized as NP-
hard, making it impractical to rely on ground-truth data, which
would be computationally infeasible to obtain. Secondly, the cut
objective may lack differentiability. Therefore, it becomes essen-
tial to adopt a learning paradigm that can be trained even under
these non-differentiable constraints. In this context, RL effectively
 
2586KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Rishi Shah, Krishnanshu Jain, Sahil Manchanda, Sourav Medya, & Sayan Ranu
Initial Partition AssignmentGNNâ„!Node Embeddingsğ‘£!ğ‘£!ğ‘£"ğ‘£"ğ‘£!ğ‘£#ğ‘£"Input Graph ğ’¢=(ğ’±,â„°,ğ‘¿)		ğ‘£!ğ‘£"ğ‘£$ğ‘£%ğ‘£&ğ‘£'ğ‘£(ğ‘£)							ğ‘ƒğ‘ğ‘Ÿğ‘¡ğ‘†ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘	, ğ‘£)ğ’—Update node partitionGet Reward ğ‘…!		Update policy ğ…ğœ½			after ğ‘»stepsPartition SelectionNode selectionğ‘£!ğ‘£"ğ‘£"ğ‘£!ğ‘£%ğ‘£#ğ‘£"ğ‘£!
ğ‘£!ğ‘£"ğ‘£"ğ‘£!ğ‘£%ğ‘£#ğ‘£"ğ‘£!Updating partition of node ğ‘£#				Target PartitioningObjectiveRaw node + Positional features(Lipschitz Embedding)Start
ğ‘£%
ğ‘£!ğ‘£"ğ‘£"ğ‘£!ğ‘£%ğ‘£#ğ‘£"ğ‘£!PartitionScores
Figure 1: Architecture of NeuroCUT. First, the initial partitioning of the graph is performed based on node features and
positional embeddings. These embeddings are refined using GNN to infuse toplogical information from neighborhood. At each
step a node is selected and its partitioned is updated. During training the GNN parameters are updated and hence embeddings
are re-computed. During inference, the GNN is called only once to compute the embeddings of the nodes of the graph.
addresses both of these critical requirements. Additionally, in the
process of sequentially constructing a solution, RL allows us to
model the gain obtained by perturbing the partition of a node.
Markov Decision Process. Given a graphG, our objective is
to find the partitioning Pthat maximizes/minimizes the target
objective function ğ‘‚ğ‘ğ‘—(G,P). We model the task of iteratively
updating the partition for a node as a Markov Decision Process
(MDP) defined by the tuple (ğ‘†,A,ğœŒ,ğ‘…,ğ›¾). Here,ğ‘†is the state space,
Ais the set of all possible actions,ğœŒ:ğ‘†Ã—ğ‘†Ã—Aâ†’[ 0,1]denotes
thestate transition probability function, ğ‘…:ğ‘†Ã—Aâ†’ Rdenotes
thereward function andğ›¾âˆˆ(0,1)thediscounting factor. We next
formalize each of these notions in our MDP formulation.
3.1 State: Initialization & Positional Encoding
Initialization. Instead of directly starting from empty partitions,
we perform a warm start operation that clusters the nodes of the
graph to obtain the initial graph partitions. The graph is clustered
intoğ‘˜clusters based on their raw features and positional embed-
dings (discussed below). We use K-means [28] algorithm for this
task. The details of the clustering are present in Appendix A.1.
Positional Encoding (Embeddings). Given that the partitioning
objectives are NP-hard mainly due to the combinatorial nature
of the graph structure, we look for representations that capture
the location of a node in the graph. Positional encodings provide
an idea of the position in space of a given node within the graph.
Two nodes that are closer in the graph, should be closer in the
embedding space. Towards this, we use Lipschitz Embedding [6].
LetA={ğ‘1,Â·Â·Â·,ğ‘ğ›¼}âŠ†V be a randomly selected subset of ğ›¼nodes. We call them anchor nodes. From each anchor node ğ‘–, the
walker starts a random walk [ 5] and jumps to a neighboring node
ğ‘—with a transition probability (W ğ‘–ğ‘—) governed by the transition
probability matrix WâˆˆR|ğ‘‰|Ã—|ğ‘‰|. Furthermore, at each step, with
probabilityğ‘the walker jumps to a neighboring node ğ‘—and returns
to the node ğ‘–with 1âˆ’ğ‘. LetÂ®ğ‘Ÿğ‘–ğ‘—corresponds to the probability of
the random walker starting from node ğ‘–and reaching node ğ‘—.
Â®ğ‘Ÿğ‘–=ğ‘ËœWÂ®ğ‘Ÿğ‘–+(1âˆ’ğ‘)Â®ğ‘’ğ‘– (6)
Eq. 6 describes the random walk starting at node ğ‘–. In vectorÂ®ğ‘’ğ‘–âˆˆ
R|ğ‘‰|Ã—1, only theğ‘–ğ‘¡â„element (the initial anchor node) is 1, and the
rest are set to zero. We set Wğ‘–ğ‘—=1
ğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’(ğ‘—)if edgeğ‘’ğ‘–ğ‘—âˆˆ E,0
otherwise. The random walk with restart process is repeated for ğ›½
iterations, where ğ›½is a hyper-parameter. Here Â®ğ‘’ğ‘–âˆˆR|ğ‘‰|Ã—1andğ‘is
a scalar.
Based upon the obtained random walk vectors for the set of
anchor nodesA, we embed all nodes ğ‘¢âˆˆV in ağ›¼-dimensional
feature space:
pos(ğ‘¢)=[ğ‘Ÿ1ğ‘¢,ğ‘Ÿ2ğ‘¢,Â·Â·Â·,ğ‘Ÿğ›¼ğ‘¢] (7)
To accommodate both raw feature and positional information
we concatenate the raw node features i.e X[ğ‘¢]with the positional
embedding pos(ğ‘¢)for each node ğ‘¢to obtain the initial embedding
which will act as input to our neural model. Specifically,
emb init(ğ‘¢)=X[ğ‘¢] âˆ¥ pos(ğ‘¢) (8)
In the above equation, âˆ¥represents the concatenation operator.
State. The state space characterizes the state of the system at time
ğ‘¡in terms of the current set of partitions Pğ‘¡. Intuitively the state
should contain information to help our model make a decision to
 
2587NeuroCUT: A Neural Approach for Robust Graph Partitioning KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
select the next node and the partition for the node to be assigned.
LetPğ‘¡denote the status of partitions at time ğ‘¡wherein a partition
ğ‘ƒğ‘¡
ğ‘–is represented by all nodes belonging to ğ‘–ğ‘¡â„partition. The state
of the system at step ğ‘¡is defined as
ğ‘†ğ‘¡={ğ‘†ğ‘¡
1,ğ‘†ğ‘¡
2,Â·Â·Â·ğ‘†ğ‘¡
ğ‘˜:ğ‘†ğ‘¡
ğ‘–={emb init(ğ‘£) âˆ€ğ‘£âˆˆğ‘ƒğ‘¡
ğ‘–}} (9)
Here state of each partition is represented by the collection of initial
embedding of nodes in that partition.
3.2 Action: Selection of Nodes andPartitions
Towards finding the best partitioning scheme for the target parti-
tion objective we propose a 2-step action strategy to update the
partitions of nodes. The first phase consists of identifying a node
to update its partition. Instead of arbitrarily picking a node, we
propose to prioritize selecting nodes for which the new assign-
ment is more likely to improve the overall partitioning objective.
In comparison to a strategy that arbitrarily selects nodes, the above
mechanism promises greater improvement in the objective with
less number of iterations. In the second phase, we calculate the
score of each partition Pwith respect to the selected node from the
first phase and then assign it to one of the partitions based upon the
partitioning scores. We discuss both these phases in details below.
3.2.1 Phase 1: Node Selection to Identify Node to Perturb.
LetPART(Pğ‘¡,ğ‘£)denote the partition of the node ğ‘£at stepğ‘¡. Our
proposed formulation involves selecting a node ğ‘£at stepğ‘¡belonging
to partition PART(Pğ‘¡,ğ‘£)and then assigning it to a new partition.
The newly assigned partition and the current partition of the node
could also be same.
Towards this, we design a heuristic to prioritize selecting nodes
which when placed in a new partition are more likely to improve
the overall objective value. A node ğ‘£is highly likely to be moved
from its current partition if most of its neighbours are in a different
partition than that of node ğ‘£. Towards this, we calculate the score
of nodesğ‘£âˆˆV in the graph as the ratio between the maximum
number of neighbors in another partition and the number of neigh-
bors in the same partition as ğ‘£. Intuitively, if a partition exists in
which the majority of neighboring nodes of a given node ğ‘£belong,
and yet node ğ‘£is not included in that partition, then there is a
high probability that node ğ‘£should be subjected to perturbation.
Specifically the score of node ğ‘£at stepğ‘¡is defined as:
NodeScoreğ‘¡[ğ‘£]=
maxğ‘âˆˆğ‘ƒğ‘¡\PART(ğ‘ƒğ‘¡,ğ‘£)|ğ‘¢|ğ‘¢âˆˆN(ğ‘£)âˆ‹PART(ğ‘ƒğ‘¡,ğ‘¢)=ğ‘|
|ğ‘¢|ğ‘¢âˆˆN(ğ‘£)âˆ‹PART(ğ‘ƒğ‘¡,ğ‘¢)=PART(ğ‘ƒğ‘¡,ğ‘£)|Ã—1
ğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’(ğ‘£)
(10)
For a node of interest ğ‘£, the numerator computes the maximum
number of neighbors in a different partition than that of ğ‘£. As
described in Table 1, PART(ğ‘ƒğ‘¡,ğ‘£)refers to the partition of ğ‘£at step
ğ‘¡. The expression ğ‘ƒğ‘¡\PART(ğ‘ƒğ‘¡,ğ‘£)computes all other partitions
except the partition of ğ‘£. The term|ğ‘¢|ğ‘¢âˆˆN(ğ‘£)âˆ‹PART(ğ‘ƒğ‘¡,ğ‘¢)=ğ‘|
computes the number of neighbors of ğ‘£in the partition ğ‘. The
denominator computes the number of neighbors of node ğ‘£in the
same partition as ğ‘£, referred to as PART(ğ‘ƒğ‘¡,ğ‘£). Further, a node
having a higher degree implies that it has several edges associated
to it. Hence, an incorrect placement of it could contribute to ahigher partitioning value. Therefore, we normalize the scores by
theğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’ of the node.
3.2.2 Phase 2: Inductive Method for Partition Selection.
Once a node is selected, the next phase involves choosing the new
partition for the node. Towards this, we design an approach em-
powered by Graph Neural Networks (GNNs) [ 15] which enables
the model to be inductive with respect to size of graph. Further, in-
stead of predicting a fixed-size score vector [ 34,46] for the number
of partitions, our proposed method of computing partition scores
allows the model to be inductive to the number of partitions too.
We discuss both above points in section below.
Message Passing through Graph Neural Network
To capture the interaction between different nodes and their fea-
tures along with the graph topology, we parameterize our policy by
a Graph Neural Network (GNN) [ 15]. GNNs combine node feature
information and the graph structure to learn better representations
via feature propagation and aggregation.
We first initialize the input layer of each node ğ‘¢âˆˆV in graph as
h0ğ‘¢=emb init(ğ‘¢)using eq. 8. We perform ğ¿layers of message pass-
ing to compute representations of nodes. To generate the embedding
for nodeğ‘¢at layerğ‘™+1we perform the following transformation[ 15]:
hğ‘™+1
ğ‘¢=Wğ‘™
1hğ‘™
ğ‘¢+Wğ‘™
2Â·1
|Nğ‘¢|âˆ‘ï¸
ğ‘¢â€²âˆˆNğ‘¢hğ‘™
ğ‘¢â€² (11)
where h(ğ‘™)
ğ‘¢is the node embedding in layer ğ‘™.Wğ‘™
1andWğ‘™
2are
trainable weight matrices at layer ğ‘™.
Followingğ¿layers of message passing, the final node represen-
tation of node ğ‘¢in theğ¿ğ‘¡â„layer is denoted by hğ¿ğ‘¢âˆˆRğ‘‘. Intuitively
hğ¿ğ‘¢characterizes ğ‘¢using a combination of its own features and
features aggregated from its neighborhood.
Scoring Partitions. Recall from eq. 9, each partition at time ğ‘¡is
represented using the nodes belonging to that partition. Building
upon this, we compute the score of each partition ğ‘âˆˆPğ‘¡with
respect to the node ğ‘£selected in Phase 1 using all the nodes in ğ‘.
In contrast to predicting a fixed-size score vector corresponding
to number of partitions [ 34,46], the proposed design choice makes
the model inductive to the number of partitions. Specifically, the
number of partitions are not directly tied to the output dimensions
of the neural model.
Having obtained the transformed node embeddings through a
Gnn in Eq. 11, we now compute the (unnormalized) score for node
ğ‘£selected in phase 1 for each partition ğ‘âˆˆPğ‘¡as follows:
PartScore(ğ‘,ğ‘£)=AGG({MLP(ğœ(â„ğ‘£|â„ğ‘¢))
âˆ€ğ‘¢âˆˆN(ğ‘£)âˆ‹PART(Pğ‘¡,ğ‘¢)=ğ‘})(12)
The above equation concatenates the selected node ğ‘£â€™s embed-
ding with its neighbors ğ‘¢âˆˆN(ğ‘£)that belong to the partition ğ‘
under consideration. In general, the strength of a partition assign-
ment to a node is higher if its neighbors also belong to the same
partition. The above formulation surfaces this strength in the em-
bedding space. The concatenated representation (â„ğ‘£|â„ğ‘¢)âˆ€ğ‘¢âˆˆN(ğ‘£)
is passed through an MLP that converts the vector into a score
(scalar). We then apply an aggregation operator (e.g., mean) over
all neighbors of ğ‘¢belonging toPğ‘¡to get an unnormalized score
for partition ğ‘. Hereğœis an activation function.
 
2588KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Rishi Shah, Krishnanshu Jain, Sahil Manchanda, Sourav Medya, & Sayan Ranu
To compute the normalized score at step ğ‘¡is finally calculated
as softmax over the all partitions ğ‘âˆˆPğ‘¡for the currently selected
nodeğ‘£. Mathematically, the probability of taking action ğ‘ğ‘¡=ğ‘at
time stepğ‘¡at stateğ‘†ğ‘¡is defined as:
ğœ‹((ğ‘ğ‘¡=ğ‘)/ğ‘†ğ‘¡)=exp(PartScore(ğ‘,ğ‘£))Ã
ğ‘â€²âˆˆPğ‘¡exp(PartScore(ğ‘â€²,ğ‘£))(13)
During the course of trajectory of length ğ‘‡, we sample action
ğ‘ğ‘¡âˆˆP i.e., the assignment of the partition for the node selected in
phase 1 at step ğ‘¡using policy ğœ‹.
State Transition. After action ğ‘ğ‘¡is applied at state ğ‘†ğ‘¡, the state
is updated to ğ‘†ğ‘¡+1that involves updating the partition set Pğ‘¡+1.
Specifically, if node ğ‘£belonged to ğ‘–ğ‘¡â„partition at time ğ‘¡and its
partition has been changed to ğ‘—in phase 2, then we apply the below
operations in order.
ğ‘ƒğ‘¡+1
ğ‘–â†ğ‘ƒğ‘¡
ğ‘–\{ğ‘£}andğ‘ƒğ‘¡+1
ğ‘—â†ğ‘ƒğ‘¡
ğ‘—âˆª{ğ‘£} (14)
3.3 Reward, Training & Inference
Reward. Our aim is to improve the value of the overall partitioning
objective. One way is to define the reward ğ‘…ğ‘¡at stepğ‘¡â‰¥0as the
change in objective value of the partitioning i.e ğ‘‚ğ‘ğ‘—(G,Pğ‘¡)at step
ğ‘¡. Specifically,
ğ‘…ğ‘¡=(ğ‘‚ğ‘ğ‘—(G,Pğ‘¡)âˆ’ğ‘‚ğ‘ğ‘—(G,Pğ‘¡+1))
(ğ‘‚ğ‘ğ‘—(G,Pğ‘¡)+ğ‘‚ğ‘ğ‘—(G,Pğ‘¡+1))Â·ğœ† (15)
Hereğœ†is a hyperparameter that is used to scale the reward. The
above reward expression incentivizes significant improvements in
the objective function. This is achieved mathematically by consider-
ing both the change and the current value of the objective function.
This design steers the model towards prioritizing substantial im-
provements, especially in low objective function regions, ultimately
guiding it towards the overall minimum.
However, above definition of reward focuses on short-term im-
provements instead of long-term. Hence, to prevent this local greedy
behavior and to capture the combinatorial aspect of the selections,
we use discounted rewards ğ·ğ‘¡to increase the probability of actions
that lead to higher rewards in the long term [ 42]. The discounted
rewards are computed as the sum of the rewards over a horizon
of actions with varying degrees of importance (short-term and
long-term). Mathematically,
ğ·ğ‘¡=ğ‘…ğ‘¡+ğ›¾ğ‘…ğ‘¡+1+ğ›¾2ğ‘…ğ‘¡+2+...=ğ‘‡âˆ’ğ‘¡âˆ‘ï¸
ğ‘—=0ğ›¾ğ‘—ğ‘…ğ‘¡+ğ‘—(16)
whereğ‘‡is the length of the horizon and ğ›¾âˆˆ(0,1]is adiscounting
factor (hyper-parameter) describing how much we favor immediate
rewards over the long-term future rewards.
The above reward mechanism provides flexibility to our frame-
work to be versatile to objectives of different nature, that may
or may not be differentiable. This is an advantage over existing
neural methods [ 34,46] where having a differentiable form of the
partitioning objective is a pre-requisite.
Policy Loss Computation and Parameter Update. Our objec-
tive is to learn parameters of our policy network in such a way
that actions that lead to an overall improvement of the partition-
ing objective are favored more over others. Towards this, we use
REINFORCE gradient estimator [48] to optimize the parameters ofour policy network. Specifically, we wish to maximize the reward
obtained for the horizon of length ğ‘‡with discounted rewards ğ·ğ‘¡.
Towards this end, we define a reward function ğ½(ğœ‹ğœƒ)as:
ğ½(ğœ‹ğœƒ)=Eğ‘‡âˆ‘ï¸
ğ‘¡=0 ğ·ğ‘¡
(17)
We, then, optimize ğ½(ğœ‹ğœƒ)via policy gradient [42] as follows:
âˆ‡ğ½(ğœ‹ğœƒ)="ğ‘‡âˆ‘ï¸
ğ‘¡=0 ğ·ğ‘¡âˆ‡ğœƒğ‘™ğ‘œğ‘”ğœ‹ğœƒ(ğ‘ğ‘¡/ğ‘†ğ‘¡)#
(18)
Training and Inference. For a given graph, we optimize the pa-
rameters of the policy network ğœ‹ğœƒforğ‘‡steps. Note that the tra-
jectory length ğ‘‡is not kept very large to avoid the long-horizon
problem. During inference, we compute the initial node embed-
dings, obtain initial partitioning and then run the forward pass of
our policy to improve the partitioning objective over time.
3.4 Time Complexity
The time complexity of NeuroCUT during inference is
O (ğ›¼Ã—ğ›½Ã—|E|)+(|E|+ ğ‘˜)Ã—ğ‘‡â€². Hereğ›¼is the number of anchor
nodes,ğ›½is number of random walk iterations, ğ‘˜is the number
of partitions and ğ‘‡â€²is the number of iterations during inference.
Typicallyğ›¼,ğ›½andğ‘˜are<<|V|andğ‘‡â€²=ğ‘œ(|V|) . Further, for
sparse graphs|E|=O(|V|) . Hence time complexity of NeuroCUT
isğ‘œ(|V|2). For detailed derivation please see Appendix A.2.
4 EXPERIMENTS
In this section, we demonstrate the efficacy of NeuroCUT against
state-of-the-art methods and establish that:
â€¢Efficacy and Robustness: NeuroCUT produces the best results
over diverse partitioning objective functions. This establishes the
robustness of NeuroCUT.
â€¢Inductivity: As one of the major strengths, unlike existing neural
models such as GAP [34],DMon [46] and MinCutPool [4], our
method NeuroCUT is inductive on the number of partitions and
consequently can generalize to unseen number of partitions.
Code: Our code base is accessible at https://github.com/idea-iitd/
NeuroCut.
4.1 Experimental Setup
4.1.1 Datasets: We use four real datasets for our experiments. They
are described below and their statistics are present in Table 2. For
all datasets we use their largest connected component.
â€¢Cora andCiteseer [40]: These are citation networks where
nodes correspond to individual papers and edges represent cita-
tions between papers. The node features are extracted using a
bag-of-words approach applied to paper abstracts.
â€¢Harbin [27]: This is a road network extracted from Harbin city,
China. The nodes correspond to road intersections and node
features represent latitude and longitude of a road intersection.
â€¢Actor [36]: This dataset is based upon Wikipedia data where
each node in the graph corresponds to an actor, and the edge be-
tween two nodes denotes co-occurrence on the same Wikipedia
page. Node features correspond to keywords in Wikipedia pages.
This is a heterophilous dataset [ 49] where nodes tend to connect
to other nodes that are dissimilar.
 
2589NeuroCUT: A Neural Approach for Robust Graph Partitioning KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
â€¢Facebook [33]: In social network analysis, a ğ‘˜-way cut can de-
lineate communities of users with minimal inter-community
connections. This partitioning unveils hidden social circles and
provides insights into how different groups interact within the
larger network. The Facebook dataset, used for community de-
tection, does not include node features. In this dataset, nodes
represent users, and edges represent friendships.
â€¢Stochastic Block Models (SBM) [1]: SBMs are synthetic net-
works and produce graphs with communities, where subsets of
nodes are characterized by specific edge densities within the
community. This allows us to validate our method by comparing
the identified partitions with the ground truth communities. This
dataset does not include node features.
Table 2: Dataset Statistics
Dataset|
V| |E| #Features Average
DegreeClustering
CoefficientDegree Assor-
tativity
Cora
2485 5069 1433 4.07 0.23 -0.07
CiteSeer 2120 3679 3703 3.47 0.169 0.0075
Harbin 6598 10492 2 3.18 0.036 0.22
Actor 6198 14879 931 4.82 0.05 -0.048
Facebook 1034 26749 - 51.7 0.526 0.431
SBM 500 5150 - 20.6 0.18 -0.0059
4.1.2 Partitioning objectives: We evaluate our method on a diverse
set of four partitioning objectives described in Section 2, namely
Normalized Cut, Balanced Cut, k-MinCut, and Sparsest Cut. In addi-
tion to evaluating on diverse objectives, we also choose a diverse
number of partitions for evaluation, specifically, ğ‘˜=2,5and10.
4.1.3 Baselines: We compare our proposed method with both neu-
ralas well as non-neural methods.
Neural baselines: We compare with DMon [46], GAP [34], Min-
CutPool [4] and Ortho [46].DMon is the state-of-the-art neural
attributed-graph clustering method. GAP is optimized for balanced
normalized cuts with an end-to-end framework with a differen-
tiable loss function which is a continuous relaxation version of
normalized cut. MinCutPool optimizes for normalized cut and
uses an additional orthogonality regularizer. Ortho is the orthogo-
nality regularizer described in DMon andMinCutPool. We also
compare with DRL [ 12] which solves for Normalized cut at ğ‘˜=2
in Appendix A.5
Non-neural baselines: Following the settings of DMon [46], we
compare with K-means clustering applied on raw node features. We
also compare with standard graph clustering methods hMetis [ 20]
and Spectral clustering [35] in App Sec. A.4.
4.1.4 Other settings: We run all our experiments on an Ubuntu
20.04 system running on Intel Xeon 6248 processor with 96 cores
and 1 NVIDIA A100 GPU with 40GB memory for our experiments.
ForNeuroCUT we used GraphSage[ 15] as our GNN with number
of layersğ¿=2, learning rate as 0.0001, hidden size = 32. We used
Adam optimizer for training the parameters of our policy network
ğœ‹ğœƒ. For computing discounted reward in RL, we use discount factor
ğ›¾=0.99. We set the length of trajectory ğ‘‡during training as 2.
At time step ğ‘¡, the rewards are computed from time ğ‘¡toğ‘¡+ğ‘‡and
parameters of the policy ğœ‹ğœƒare updated. The default number of
anchor nodes for computing positional embeddings is set to 35. We
setğ›½=100andğ‘=0.85for Eq. 6. We set scaling factor ğœ†=100in
eq. 15.Table 3: Results on Normalized Cut. Our model NeuroCUT
produces the best (lower is better) performance across all
datasets and the number of partitions ğ‘˜.
Dataset Metho
d ğ’Œ=2ğ’Œ=5ğ’Œ=10
CoraK
-means 0.65 3.26 7.44
MinCutPool 0.12 0.61 1.65
DMon 0.57 3.07 7.40
Ortho 0.80 1.88 4.06
GAP 0.10 0.68 -
NeuroCUT 0.02 0.33 0.92
CiteSe
erK-means 0.30 2.35 5.21
MinCutPool 0.10 0.38 1.04
DMon 0.33 2.71 6.84
Ortho 0.28 1.51 3.25
GAP 0.12 - -
NeuroCUT 0.02 0.20 0.44
HarbinK
-means 0.56 2.34 5.40
MinCutPool - - -
DMon 0.98 3.25 -
Ortho - - -
GAP 0.25 - -
NeuroCUT 0.01 0.07 0.28
A
ctorK-means 0.99 4.00 8.98
MinCutPool 0.55 1.97 4.73
DMon 0.77 3.46 8.08
Ortho 1.05 3.98 8.90
GAP 0.20 - -
NeuroCUT 0.17 0.99 4.66
Table 4: Results on Sparsest Cut. Our model NeuroCUT
produces the best (lower is better) performance across all
datasets and number of partitions ğ‘˜.
Dataset Metho
d ğ’Œ=2ğ’Œ=5ğ’Œ=10
CoraK
-means 3.41 14.90 32.52
MinCutPool 0.52 2.44 6.68
DMon 0.45 1.89 5.82
Ortho 2.73 7.06 15.70
GAP 0.41 2.80 -
NeuroCUT 0.13 1.46 3.03
CiteSe
erK-means 1.53 13.70 22.20
MinCutPool 0.31 1.32 3.62
DMon 0.35 1.21 3.62
Ortho 0.88 4.15 10.60
GAP 0.60 - -
NeuroCUT 0.11 0.49 1.19
HarbinK
-means 1.91 7.44 17.03
MinCutPool - - -
DMon 2.01 - -
Ortho - - -
GAP 1.56 - -
NeuroCUT 0.06 0.23 0.82
A
ctorK-means 5.43 19.40 40.34
MinCutPool 2.44 8.51 19.81
DMon 1.71 9.50 21.01
Ortho 3.42 16.55 40.4
GAP 1.35 - -
NeuroCUT 0.65 2.04 2.88
4.2 Results on Transductive Setting
In the transductive setting, we compare our proposed method Neu-
roCUT against the mentioned baselines, where the neural models
 
2590KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Rishi Shah, Krishnanshu Jain, Sahil Manchanda, Sourav Medya, & Sayan Ranu
Table 5: Results on k-MinCut. In most of the cases, our model
NeuroCUT produces the best (lower is better) performance
across all datasets and the number of partitions ğ‘˜. Values less
than 10âˆ’2are approximated to 0.
Dataset Metho
d ğ’Œ=2ğ’Œ=5ğ’Œ=10
CoraK
-means 0.32 0.34 0.61
MinCutPool 0.06 0.12 0.17
DMon 0.05 0.09 0.14
Ortho 0.33 0.34 0.38
GAP 0.05 0.10 0.11
NeuroCUTâˆ¼0.0âˆ¼0.0 0.06
CiteSe
erK-means 0.12 0.27 0.43
MinCutPool 0.04 0.08 0.10
DMon 0.05 0.07 0.12
Ortho 0.13 0.47 0.30
GAP 0.05 0.08 0.10
NeuroCUT 0.01 0.02 0.03
HarbinK
-means 0.28 0.46 0.54
MinCutPool 0.0 0.0 0.0
DMon 0.10 0.01 âˆ¼0.0
Ortho 0.0 0.0 0.0
GAP 0.01 0.01 0.01
NeuroCUTâˆ¼0.0 0.01 0.03
A
ctorK-means 0.48 0.54 0.80
MinCutPool 0.25 0.35 0.42
DMon 0.17 0.39 0.44
Ortho 0.35 0.65 0.83
GAP 0.09 0.12 0.26
NeuroCUTâˆ¼0.0âˆ¼0.0âˆ¼0.0
are trained and tested with the same number of partitions. Ta-
bles 3-6 present the results for different partitioning objectives
across all datasets and methods. For the objectives under consid-
eration, a smaller value depicts better performance. NeuroCUT
demonstrates superior performance compared to both neural and
non-neural baselines across four distinct partitioning objectives,
highlighting its robustness. Further, we would also like to point
out that in many cases, existing baselines produce â€œnanâ€ values
which are represented by â€œ -â€ in the result tables. This is due to the
reason that every partition is not assigned atleast one node which
leads to the situation where denominator becomes 0innormalized,
balanced andsparsest cut objectives as defined in Sec. 2.
Our method NeuroCUT incorporates dependency during in-
ference and this leads to robust performance. Specifically, as the
architecture is auto-regressive, it takes into account the current
state before moving ahead as opposed to a single shot pass in meth-
ods such as GAP [34]. Further, unlike other methods, NeuroCUT
also incorporates positional information in the form of Lipschitz
embedding to better contextualize global node positional informa-
tion. We also observe that the non-neural method K-means fails to
perform on all objective functions since its objective is not aligned
with the main objectives under consideration.
4.3 Results on Inductivity to Partition Count
As detailed in Section 3.2.2, the decoupling of parameter size and
the number of partitions allows NeuroCUT to generalize effectively
to an unseen number of partitions. In this section, we empirically
analyze the generalization performance of NeuroCUT to an un-
known number of partitions. We compare it with the non-neural
baseline K-means, as the neural methods like GAP, DMon, Or-
tho, and MinCutPool cannot be employed to infer on an unseenTable 6: Results on Balanced Cut. In most cases, our model
NeuroCUT produces the best (lower is better) performance
across all datasets and number of partitions ğ‘˜.
Dataset Metho
d ğ’Œ=2ğ’Œ=5ğ’Œ=10
CoraK
-means 0.68 3.90 7.44
MinCutPool 0.13 0.60 1.62
DMon 0.11 0.48 1.47
Ortho 0.80 1.89 4.06
GAP 0.10 0.74 -
NeuroCUT 0.45 0.64 1.08
CiteSe
erK-means 0.42 2.64 5.30
MinCutPool 0.09 0.38 1.04
DMon 0.10 0.37 1.1
Ortho 0.28 1.51 3.32
GAP 0.23 - -
NeuroCUT 0.07 0.24 0.60
HarbinK
-means 0.56 2.37 5.41
MinCutPool - - -
DMon 1.30 - -
Ortho - - -
GAP 0.72 - -
NeuroCUT 0.21 0.11 0.27
A
ctorK-means 1.00 4.06 9.08
MinCutPool 0.55 1.96 4.71
DMon 0.34 2.01 4.80
Ortho 1.05 3.90 8.91
GAP 0.25 - -
NeuroCUT 0.59 1.69 4.42
Table 7: Inductivity to unseen partition count. Here we set
the target number of partitions ğ‘˜=10. I stands for inductive
and T for transductive setting. In this table, the transductive
version of NeuroCUT trained on ğ‘˜=10serves as a point of
reference when assessing the quality of the inductive version
ofNeuroCUT.
Dataset
Method Normalized Sparsest k-MinCut Balanced
CoraK
-means 7.44 32.52 0.61 7.53
NeuroCUT-T 0.92 3.03 0.06 1.08
NeuroCUT-I 1.18 5.04 0.02 2.03
CiteSe
erK-means 5.21 22.20 0.43 5.30
NeuroCUT-T 0.44 1.19 0.03 0.60
NeuroCUT-I 0.63 1.62 0.03 0.62
HarbinK
-means 5.40 17.03 0.54 5.41
NeuroCUT-T 0.28 0.82 0.03 0.27
NeuroCUT-I 0.27 0.87 0.03 0.29
number of partitions. In Table 7, we present the results on induc-
tivity. Specifically, we trained NeuroCUT on different partition
sizes (ğ‘˜=5andğ‘˜=8) and tested it on an unseen partition size
ğ‘˜=10. The inductive version, referred to as NeuroCUT-I2, ob-
tains high-quality results on different datasets. Note that while the
non-neural method such as K-means needs to be re-run for the
unseen partitions, NeuroCUT only needs to perform forward pass
to produce the results on an unseen partition size.
4.4 Ablation Studies
Initial Warm Start vs Final Cut Values. NeuroCUT takes a
warm start by partitioning nodes based on clustering over their raw
node features and Lipschitz embeddings, which are subsequently
2For clarity purposes, in this experiment we use NeuroCUT-T to refer to the trans-
ductive setting whose results are presented in Sec. 4.2
 
2591NeuroCUT: A Neural Approach for Robust Graph Partitioning KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Cora CiteSeer Harbin012345Normalized CutInitial
Final
(a) Normalized Cut
Cora CiteSeer Harbin024681012 Sparsest CutInitial
Final (b) Sparsest Cut
Cora CiteSeer Harbin01234Balanced CutInitial
Final (c) Balanced Cut
Cora CiteSeer Harbin0.000.050.100.150.200.250.300.350.40k-MincutInitial
Final (d) k-MinCut
Figure 2: Results on the initial warm start and the final cut values obtained by NeuroCUT atğ‘˜=10. It shows that our neural
model NeuroCUT (Final) performs more accurate node and partition selection to optimize the objective function. Subsequently,
there is a significant difference between the initial and final cut values.
Cora CiteSeer Harbin01020304050% GainNormalized
Balanced
k-MinCut
Sparsest-Cut
Figure 3: Node Selection in Phase 1 with Heuristic vs Random:
Relative % improvement (gain) in cut values obtained by
NeuroCUT when using different node selection strategies for
ğ‘˜=5. In most cases, our heuristic finds significantly better
cuts than a random node selection procedure.
fine-tuned auto-regressively through the phase 1 and phase 2 of
NeuroCUT. In this section, we measure, how much the partitioning
objective has improved since the initial clustering? Figure 2 sheds
light on this question. Specifically, it shows the difference between
the initial cut value after clustering and the final cut value from
the partitions produced by our method. We note that there is a
significant difference between the initial and final cut values, which
essentially shows the effectiveness of NeuroCUT.
Impact of Node Selection Procedures. In this section, we
explore the effectiveness of our proposed node selection heuristic
in enhancing overall quality. Specifically, we measure the relative
performance gain(in %) obtained by NeuroCUT when using the
node selection heuristic as proposed in Section 3.2.1 over a random
node selection strategy. In our experiments for the random node
selection strategy, we selected the best performing run across multi-
ple seeds. Figure 3 shows the percentage gain for three datasets. We
observe that a simpler node selection where we select all the nodes
one by one in a random order, yields substantially inferior results
in comparison to the heuristic proposed by us. This suggests that
the proposed sophisticated node selection strategy plays a crucial
role in optimizing the overall performance of NeuroCUT. In Ap-
pendix A.7, we conduct a more detailed analysis of the observations
presented in Figure 3, with particular attention to the variation in
gains related to the Balanced Cut objective.
Impact of Clustering Initialization in Warm-start Phase: To
understand the importance of different initializations in the warm-
up phase(Â§ 3.1), in Appendix A.6 we perform an ablation study usingthree different initialization schemes, namely K-means(default),
density-based clustering DBSCAN [ 10], and Random initialization.
4.5 Impact of Cluster Strength on Performance
In Section A.8 in appendix, we analyze the impact of cluster strength
in networks on the performance of different methods.
5 CONCLUSION
In this work, we study the problem of graph partitioning with node
features. Existing neural methods for addressing this problem re-
quire the target objective to be differentiable and necessitate prior
knowledge of the number of partitions. In this paper, we intro-
duced NeuroCUT, a framework to effectively address the graph
partitioning problem with node features. NeuroCUT tackles these
challenges using a reinforcement learning-based approach that can
adapt to any target objective function. Further, attributed to its
decoupled parameter space and partition count, NeuroCUT can
generalize to an unseen number of partitions. The efficacy of our
approach is empirically validated through an extensive evaluation
on four datasets, four graph partitioning objectives and diverse par-
tition counts. Notably, our method shows significant performance
gains when compared to the state-of-the-art techniques, proving
its competence in both inductive and transductive settings.
Limitations and Future Directions: Achieving a sub-quadratic
computational complexity with an inductive neural method for
attributed graph partitioning is an open challenge. In NeuroCUT,
node selection and perturbation are performed in a sequential fash-
ion. One direction to improve the efficiency of NeuroCUT could
be batch processing the selection and perturbation of multiple in-
dependent nodes simultaneously. Another interesting direction
could be designing explanations of the neural methodsâ€”such as
NeuroCUTâ€”for graph combinatorial problems [19].
6 ACKNOWLEDGEMENT
We thank Kartik Sharma for the helpful suggestions. Rishi Shah
acknowledges that the funding for the conference was provided by
the CMU GSA Conference Funding. Sahil Manchanda acknowledges
financial support by GP Goyal grant of IIT Delhi and Qualcomm
Innovation Fellowship India.
 
2592KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Rishi Shah, Krishnanshu Jain, Sahil Manchanda, Sourav Medya, & Sayan Ranu
REFERENCES
[1]Emmanuel Abbe. 2017. Community detection and stochastic block models: recent
developments. The Journal of Machine Learning Research 18, 1 (2017), 6446â€“6531.
[2]Reid Andersen, Fan Chung, and Kevin Lang. 2006. Local graph partitioning
using pagerank vectors. In 2006 47th Annual IEEE Symposium on Foundations of
Computer Science (FOCSâ€™06). IEEE, 475â€“486.
[3]Aritra Bhowmick, Mert Kosan, Zexi Huang, Ambuj Singh, and Sourav Medya.
2024. DGCLUSTER: A Neural Framework for Attributed Graph Clustering via
Modularity Maximization. In Proceedings of the AAAI Conference on Artificial
Intelligence, Vol. 38. 11069â€“11077.
[4]Filippo Maria Bianchi, Daniele Grattarola, and Cesare Alippi. 2020. Spectral clus-
tering with graph neural networks for graph pooling. In International conference
on machine learning. PMLR, 874â€“883.
[5]Monica Bianchini, Marco Gori, and Franco Scarselli. 2005. Inside pagerank. ACM
Transactions on Internet Technology (TOIT) 5, 1 (2005), 92â€“128.
[6]Jean Bourgain. 1985. On Lipschitz embedding of finite metric spaces in Hilbert
space. Israel Journal of Mathematics 52 (1985), 46â€“52.
[7]Shuchi Chawla, Robert Krauthgamer, Ravi Kumar, Yuval Rabani, and D Sivakumar.
2006. On the hardness of approximating multicut and sparsest-cut. computational
complexity 15 (2006), 94â€“114.
[8]Fan Chung. 2007. Four proofs for the Cheeger inequality and graph partition
algorithms. In Proceedings of ICCM, Vol. 2. Citeseer, 378.
[9]Chi Thang Duong, Thanh Tam Nguyen, Trung-Dung Hoang, Hongzhi Yin,
Matthias Weidlich, and Quoc Viet Hung Nguyen. 2023. Deep MinCut: Learning
Node Embeddings by Detecting Communities. Pattern Recognition 134 (2023),
109126.
[10] Martin Ester, Hans-Peter Kriegel, JÃ¶rg Sander, Xiaowei Xu, et al .1996. A density-
based algorithm for discovering clusters in large spatial databases with noise. In
kdd, Vol. 96. 226â€“231.
[11] Maxime Gasse, Didier ChÃ©telat, Nicola Ferroni, Laurent Charlin, and Andrea
Lodi. 2019. Exact combinatorial optimization with graph convolutional neural
networks. Advances in neural information processing systems 32 (2019).
[12] Alice Gatti, Zhixiong Hu, Tess Smidt, Esmond G Ng, and Pieter Ghysels. 2022.
Graph partitioning and sparse matrix ordering using reinforcement learning and
graph neural networks. The Journal of Machine Learning Research 23, 1 (2022),
13675â€“13702.
[13] Ralph E Gomory and Tien Chung Hu. 1961. Multi-terminal network flows. J.
Soc. Indust. Appl. Math. 9, 4 (1961), 551â€“570.
[14] Nikhil Goyal, Harsh Vardhan Jain, and Sayan Ranu. 2020. GraphGen: A Scalable
Approach to Domain-agnostic Labeled Graph Generation. In Proceedings of The
Web Conference 2020 (Taipei, Taiwan) (WWW â€™20) . Association for Computing
Machinery, New York, NY, USA, 1253â€“1263. https://doi.org/10.1145/3366423.
3380201
[15] Will Hamilton, Zhitao Ying, and Jure Leskovec. 2017. Inductive representation
learning on large graphs. Advances in neural information processing systems 30
(2017).
[16] Chaitanya K Joshi, Thomas Laurent, and Xavier Bresson. 2019. An efficient graph
convolutional network technique for the travelling salesman problem. arXiv
preprint arXiv:1906.01227 (2019).
[17] Steffen Jung and Margret Keuper. 2022. Learning to solve minimum cost multicuts
efficiently using edge-weighted graph convolutional neural networks. In Joint
European Conference on Machine Learning and Knowledge Discovery in Databases.
Springer, 485â€“501.
[18] Andrew B Kahng, Jens Lienig, Igor L Markov, and Jin Hu. 2011. VLSI physical
design: from graph partitioning to timing closure. Vol. 312. Springer.
[19] Jaykumar Kakkad, Jaspal Jannu, Kartik Sharma, Charu Aggarwal, and Sourav
Medya. 2023. A survey on explainability of graph neural networks. arXiv preprint
arXiv:2306.01958 (2023).
[20] George Karypis, Rajat Aggarwal, Vipin Kumar, and Shashi Shekhar. 1997. Multi-
level hypergraph partitioning: Application in VLSI domain. In Proceedings of the
34th annual Design Automation Conference. 526â€“529.
[21] George Karypis and Vipin Kumar. 1998. Multilevelk-way partitioning scheme
for irregular graphs. Journal of Parallel and Distributed computing 48, 1 (1998),
96â€“129.
[22] George Karypis and Vipin Kumar. 1999. Multilevel k-way hypergraph partition-
ing. In Proceedings of the 36th annual ACM/IEEE design automation conference.
343â€“348.
[23] Elias Khalil, Hanjun Dai, Yuyu Zhang, Bistra Dilkina, and Le Song. 2017. Learn-
ing combinatorial optimization algorithms over graphs. Advances in neural
information processing systems 30 (2017).
[24] Wouter Kool, Herke Van Hoof, and Max Welling. 2018. Attention, learn to solve
routing problems! arXiv preprint arXiv:1803.08475 (2018).
[25] Jure Leskovec and Julian Mcauley. 2012. Learning to discover social circles in
ego networks. Advances in neural information processing systems 25 (2012).
[26] Hao Li, Gary W Rosenwald, Juhwan Jung, and Chen-Ching Liu. 2005. Strategic
power infrastructure defense. Proc. IEEE 93, 5 (2005), 918â€“933.[27] Xiucheng Li, Gao Cong, Aixin Sun, and Yun Cheng. 2019. Learning travel time
distributions with deep generative model. In The World Wide Web Conference.
1017â€“1027.
[28] James MacQueen et al .1967. Some methods for classification and analysis of
multivariate observations. In Proceedings of the fifth Berkeley symposium on
mathematical statistics and probability, Vol. 1. Oakland, CA, USA, 281â€“297.
[29] Sahil Manchanda, Shubham Gupta, Sayan Ranu, and Srikanta J Bedathur. 2024.
Generative modeling of labeled graphs under data scarcity. In Learning on Graphs
Conference. PMLR, 32â€“1.
[30] Sahil Manchanda, Sofia Michel, Darko Drakulic, and Jean-Marc Andreoli. 2022.
On the generalization of neural combinatorial optimization heuristics. In Joint
European Conference on Machine Learning and Knowledge Discovery in Databases.
Springer, 426â€“442.
[31] Sahil Manchanda, Akash Mittal, Anuj Dhawan, Sourav Medya, Sayan Ranu,
and Ambuj Singh. 2020. Gcomb: Learning budget-constrained combinatorial
algorithms over billion-sized graphs. Advances in Neural Information Processing
Systems 33 (2020), 20000â€“20011.
[32] Sahil Manchanda and Sayan Ranu. 2023. LiMIP: lifelong learning to solve mixed
integer programs. In Proceedings of the AAAI Conference on Artificial Intelligence,
Vol. 37. 9047â€“9054.
[33] Julian McAuley and Jure Leskovec. 2012. Learning to Discover Social Cir-
cles in Ego Networks. In Neural Information Processing Systems. https://api.
semanticscholar.org/CorpusID:2820103
[34] Azade Nazi, Will Hang, Anna Goldie, Sujith Ravi, and Azalia Mirhoseini. 2019.
Gap: Generalizable approximate graph partitioning framework. arXiv preprint
arXiv:1903.00614 (2019).
[35] Andrew Ng, Michael Jordan, and Yair Weiss. 2001. On spectral clustering: Analysis
and an algorithm. Advances in neural information processing systems 14 (2001).
[36] Oleg Platonov, Denis Kuznedelev, Michael Diskin, Artem Babenko, and Liudmila
Prokhorenkova. 2023. A critical look at the evaluation of GNNs under heterophily:
are we really making progress? arXiv preprint arXiv:2302.11640 (2023).
[37] Josep M Pujol, Vijay Erramilli, and Pablo Rodriguez. 2009. Divide and conquer:
Partitioning online social networks. arXiv preprint arXiv:0905.4918 (2009).
[38] Rishabh Ranjan, Siddharth Grover, Sourav Medya, Venkatesan Chakaravarthy,
Yogish Sabharwal, and Sayan Ranu. 2022. Greed: A neural framework for learning
graph distance functions. Advances in Neural Information Processing Systems 35
(2022), 22518â€“22530.
[39] Huzur Saran and Vijay V Vazirani. 1995. Finding k cuts within twice the optimal.
SIAM J. Comput. 24, 1 (1995), 101â€“108.
[40] Prithviraj Sen, Galileo Namata, Mustafa Bilgic, Lise Getoor, Brian Galligher, and
Tina Eliassi-Rad. 2008. Collective classification in network data. AI magazine 29,
3 (2008), 93â€“93.
[41] Jianbo Shi and Jitendra Malik. 2000. Normalized cuts and image segmentation.
IEEE Transactions on pattern analysis and machine intelligence 22, 8 (2000), 888â€“
905.
[42] Richard S Sutton and Andrew G Barto. 2018. Reinforcement learning: An intro-
duction. MIT press.
[43] Amirmahdi Tafreshian and Neda Masoud. 2020. Trip-based graph partitioning in
dynamic ridesharing. Transportation Research Part C: Emerging Technologies 114
(2020), 532â€“553.
[44] Hao Tian, Sourav Medya, and Wei Ye. 2024. COMBHelper: A Neural Approach
to Reduce Search Space for Graph Combinatorial Problems. In Proceedings of the
AAAI Conference on Artificial Intelligence, Vol. 38. 20812â€“20820.
[45] Anton Tsitsulin, John Palowitch, Bryan Perozzi, and Emmanuel MÃ¼ller. 2023.
Graph clustering with graph neural networks. Journal of Machine Learning
Research 24, 127 (2023), 1â€“21.
[46] Anton Tsitsulin, John Palowitch, Bryan Perozzi, and Emmanuel MÃ¼ller. 2023.
Graph clustering with graph neural networks. Journal of Machine Learning
Research 24, 127 (2023), 1â€“21.
[47] Chun Wang, Shirui Pan, Guodong Long, Xingquan Zhu, and Jing Jiang. 2017.
Mgae: Marginalized graph autoencoder for graph clustering. In Proceedings of the
2017 ACM on Conference on Information and Knowledge Management. 889â€“898.
[48] Ronald J Williams. 1992. Simple statistical gradient-following algorithms for
connectionist reinforcement learning. Machine learning 8 (1992), 229â€“256.
[49] Xin Zheng, Yi Wang, Yixin Liu, Ming Li, Miao Zhang, Di Jin, Philip S Yu, and
Shirui Pan. 2022. Graph neural networks for graphs with heterophily: A survey.
arXiv preprint arXiv:2202.07082 (2022).
A APPENDIX
A.1 Clustering for Initialization
As discussed in sec 3.1 in main paper, we first cluster the nodes
of the graph into ğ‘˜clusters where ğ‘˜is the number of partitions.
Towards this, we apply K-means algorithm [ 28] on the nodes of
the graph where a node is represented by its raw node features and
 
2593NeuroCUT: A Neural Approach for Robust Graph Partitioning KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Table 8: Time complexity of different methods.
Method Complexity Comments
DMonO(ğ‘‘2Ã—|V|+|E|) Per iteration complexity
MinCutPoolO(ğ‘‘2Ã—|V|+|E|) Per iteration complexity
OrthoO(|V|Ã—ğ‘˜2) Per iteration complexity
GAPO(|V|Ã—ğ‘˜2+|V|2)Per iteration complexity
SpectralO(|V|3) Inference complexity
NeuroCUT ğ‘œ(|V|2) Inference complexity
positional representation i.e emb init(ğ‘¢)âˆ€ğ‘¢âˆˆV based upon eq. 8.
Further, we used ğ¿infnorm as the distance metric for clustering.
A.2 Time Complexity Analysis of NeuroCUT
(1)First the positional embeddings for all nodes in the graph are
computed. This involves running RWR for ğ›¼anchor nodes for ğ›½
iterations (Eq. 6). This takes O(ğ›¼Ã—ğ›½Ã—|E|) time. (2)Next, GNN is
called to compute embeddings of node. In each layer of GNN a node
ğ‘£âˆˆV aggregates message from ğ‘‘neighbors where ğ‘‘is the average
degree of a node. This takes O(V) time. This operation is repeat for
ğ¿layers. Since ğ¿is typically 1 or 2 hence we ignore this factor. (3)
The node selection algorithm is used that computes score for each
node based upon its neighborhood using eq. 10. This consumes
O(|V|Ã—ğ‘‘)time. (4)Finally for the selected node, its partition
has to be determined using eq. 12 and 13. This takes O(ğ‘‘+ğ‘˜)
time, as we consider only the neighbors of the selected node to
compute partition score. Steps 2-4 are repeated for ğ‘‡â€²iterations.
Hence overall running time is O (ğ›¼Ã—ğ›½Ã—|E|)+(|V|Ã— ğ‘‘+ğ‘˜)Ã—ğ‘‡â€².
Typicallyğ›¼,ğ›½andğ‘˜are<<|V|andğ‘‡â€²=ğ‘œ(|V|) . Since|V|Ã—ğ‘‘â‰ˆ
|E|, hence complexity is ğ‘œ(|E|Ã—|V|Further, for sparse graphs
|E|=O(|V|) . Hence time complexity of NeuroCUT isğ‘œ(|V|2).
A.3 Time Complexity Comparison
Table 8 presents the complexities of NeuroCUT and other promi-
nent neural and non-neural baselines algorithms. In the table, |V|,
|E|,ğ‘˜,ğ‘‘are the number of nodes, edges, partitions, and average
node degree respectively. While some neural algorithms exhibit
faster complexity, they require separate training for each partition
size (ğ‘˜). In contrast, NeuroCUT, once trained, can generalize to any
value. Consequently, for practical workloads, NeuroCUT presents a
more scalable option in terms of computation overhead and storage
(one model versus separate models for each).
The quadratic time complexity of NeuroCUT may pose chal-
lenges for very large graphs. However, this complexity remains
faster than spectral clustering, a widely used graph partitioning al-
gorithm. Also, for the baseline neural methods(DMon, MinCutPool,
Ortho and GAP), the time complexity provided is per iteration. The
number of iterations often ranges between 1000 to 2000 and there
is no clear understanding of how it varies as a function of the graph
(like density, diameter, etc.)
A.4 Comparison: Non-neural Baselines
We compare the performance of our method against graph based
clustering algorithms hMETIS and Spectral Clustering and par-
tition algorithm Gomory-Hu Tree [ 13]. Since these methods areTable 9: Performance of different methods on Facebook and
SBM dataset. Lower values are better.â€²âˆ’â€²denotes nan.
Dataset Metho
dMetrics
Normalized Sparsest Balanced ğ‘˜-MinCut
Faceb
ookNeuroCUT 0.257 4.121 0.972 0.015
hMETIS 1.15 52.319 1.115 0.200
Spectral 1.67 4.72 2.459 0.003
Gomory-Hu Tree 4.00 5.00 4.792 âˆ¼0
MinCutPool - - - 0.023
DMon - - - âˆ¼0
Ortho - - - 0.05
GAP - - - 0.025
SBMNeur
oCUT 0.191 3.939 0.191 0.038
hMETIS 0.191 3.939 0.191 0.038
Spectral 0.191 3.939 0.191 0.038
Gomory-Hu Tree 4.003 48.75 4.787 0.0075
MinCutPool - - - 0.0
DMon - - - 0.0
Ortho - - - âˆ¼0
GAP - - - 0.035
Table 10: Gatti et al. on Normalized Cut at ğ‘˜=2.
Metho
dâ†’
Datasetâ†“Cora
CiteSeer Harbin Actor SBM Facebook
Neur
oCUT 0.02 0.02 0.01 0.17 0.191 0.257
Gatti et al. 0.355 0.29 0.13 1.00 0.72 0.92
not compatible with datasets having raw node features, we com-
pare with two datasets namely Facebook [ 25] and Stochastic Block
Model(SBM) [ 1] which donâ€™t have node features for this compar-
ision. Table 9 compares the performance of NeuroCUT against
hMETIS and Spectral Clustering. The details of these datasets are
presented in Table 2. In addition to non-neural methods, we also
show the performance of neural methods MinCutPool, DMon, Or-
tho and GAP on these datasets.
The performance of NeuroCUT is better than non-neural meth-
ods hMETIS, Spectral and Gomory-Hu Tree in most of the cases
on Facebook dataset. Further, on SBM dataset, it matches the per-
formance of hMETIS and Spectral clustering. The SBM dataset
has a clear community structure, making it an easy instance for
partitioning algorithms, resulting in similar performance across
different methods. We would also like to highlight that in the case of
ğ‘˜âˆ’ğ‘šğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡ , Gomory-Hu Tree algorithm generated trivial partitions
for these datasets where almost all nodes were assigned the same
partition. The other neural methods such as MinCutPool, DMon,
Ortho, and GAP fail to produce a valid solution in most of the
cases. This is possibly because these baselines are not robust to per-
form on datasets without raw node features. Overall, NeuroCUT
outperforms the baselines on diverse objectives and datasets.
A.5 Comparison with Gatti et al. [12]
In Table 10, we compare the performance of our method against DRL
method proposed by Gatti et al. [ 12] which solves the normalized
cut problem for the case where the number of partitions is exactly
two. We observe that NeuroCUT outperforms DRL on all datasets.
A.6 Impact of Clustering Initialization
To understand the importance of different initializations in the
warm-up phase, we perform an ablation study on 2datasets namely
 
2594KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Rishi Shah, Krishnanshu Jain, Sahil Manchanda, Sourav Medya, & Sayan Ranu
Table 11: Impact of Clustering initialization in Warm-up
Phase of NeuroCUT in the normalized cut objective at ğ‘˜=5.
Dataset K-means Random DBSCAN
Cora 0.33 0.79 0.55
CiteSeer 0.20 0.51 0.70
Table 12: Statistics for Normalized Cut (3 runs) for ğ‘˜=5
Dataset
Our Heuristic Random Selection Random Selection % Gain
Avg Best (from best)
Cora
0.33Â±0.0024 0.461 Â±0.0164 0.445 35
Citeseer 0.20Â±0.00961 0.276 Â±0.0177 0.258 29
Harbin 0.073Â±0.0027 0.097Â±0.0131 0.086 18
Table 13: Statistics for Balanced Cut (across 3 runs) for ğ‘˜=5
Dataset
Our Heuristic Random Selection Random Selection % Gain
Avg Best (from best)
Cora
0.642Â±0.0065 0.753Â±0.0574 0.672 2
Citeseer 0.248Â±0.0049 0.307 Â±0.039 0.252 0.5
Harbin 0.1087Â±0.0010 0.1313 Â±0.011 0.1293 19
Cora and CiteSeer using 3 different initialization namely K-means,
density-based clustering DBSCAN [10], and Random initialization.
In Table 11 we observe the performance on normalized cut at ğ‘˜=5.
We observe that K-means performs the best in this experiment.
The improvement observed when using K-means orDBSCAN over
Random shows that a good initialization i.e. warm-up does help in
improving quality of partitions. In DBSCAN we set ğ‘’ğ‘ğ‘ =0.9and
ğ‘šğ‘–ğ‘›_ğ‘ ğ‘ğ‘šğ‘ğ‘™ğ‘’ğ‘  =2. It is worth noting that DBSCANâ€™s performance
can vary based on the parameter selection. Nonetheless, the primary
goal of this experiment is to demonstrate the advantageous role of a
good initialization, specifically in contrast to random initialization.
Table 14: Number of Nodes Re-assigned after Initial Assign-
ment by NeuroCUT on the Balanced Cut objective.
Dataset
Nodes Perturbed Total Nodes Percentage
Cora
791 2495 31.7
Citeseer 413 2120 19.4
Harbin 187 6598 2.8
A.7 Impact of Node Selection Procedures
In Fig. 3 in main paper, random selection performs well only in
Balanced Cuts. The objective in Balanced Cuts (Eq. 3.) is not only a
function of the combined weight of cut edges, but also balancing the
number of nodes across partitions. This additional node-balancing
term is not present in the objective functions of the other cut defi-
nitions. Due to this reduced importance of optimizing the cut value,
random does well, since even when an incorrect node is selected, it
can still be utilized to keep the partition sizes balanced. Moreover,
we find that when the warm-up assignment is less accurate and
the percentage of nodes re-assigned by NeuroCUT to a different
partition is high, a random selection of nodes is closer in efficacy
to our heuristic selection. In contrast, in Harbin, the percentage
of nodes perturbed to a new partition is significantly smaller. In
this scenario, the probability that random selection will select thissmall subset is lower and hence amplifying the effectiveness gap
between random and heuristic selection.
A.8 Impact of Cluster Strength on Performance
To understand the impact of community structure on performance
ofNeuroCUT, we generate Stochastic Model Block(SBM) graphs
with different intra cluster strength. In Table 15, we observe the
performance of different methods on the normalized cut objective
atğ‘˜=5. The baseline methods hMETIS and Spectral Clustering per-
form worse when the strength within communities is low indicated
by Intra Cluster Edge Probability and Clustering Coefficient values.
Although NeuroCUT outperforms or matches existing methods
in all cases, however, the gap between baselines and NeuroCUT
increases significantly when the community structure is not strong.
Further, the neural baselines DMon, MinCutPool and Ortho gener-
ated â€˜nanâ€™ values for this experiment.
Table 15: Performance on SBM Dataset
SBM
Dataset Statistics Normalized Cut
Intra
Cluster
Edge
ProbabilityClustering
Coefficient|V| |E| NeuroCUT hMETIS Spectral
Clustering
1
0.005 0.003 495 555 0.3089 0.331
0.379
2 0.01 0.0029 525 661 0.3434 0.5889
0.4259
3 0.2 0.184 500 5150 0.1912
0.1912 0.1912
4 0.4 0.3822 500 10102 0.1153
0.1153 0.1153
A.9 Impact of ğ›½onNeuroCUT
We study the impact of ğ›½parameter(eq. 6) which is the number of
iterations in random walk with restart. In Table 16 we present the
performance of NeuroCUT using different ğ›½on normalized-cut
objective atğ‘˜=5. We observe that NeuroCUT improves with more
iterations as ğ›½increases and then its performance stabilizes.
Table 16: Impact of ğ›½parameter on NeuroCUT on normal-
ized cut at ğ‘˜=5on the Cora dataset.
ğ›½ Normalized Cut
1 2.12
3 1.57
10 0.33
50 0.33
100 0.33
A.10 Stability Across Multiple Runs
Table 17 shows the Mean and Standard deviation of NeuroCUT for
Normalized cut at ğ‘˜=5for 3 runs. The Std Dev. is lower than the
Mean showing the stability of NeuroCUT across multiple runs.
Table 17: Mean and Standard Deviation for different datasets
on Normalized Cut at ğ‘˜=5forNeuroCUT
Dataset MeanÂ±Std Dev
Cora 0.337Â±0.0024
Citeseer 0.20Â±0.00961
Harbin 0.073Â±0.0027
Actor 0.97Â±0.0389
 
2595