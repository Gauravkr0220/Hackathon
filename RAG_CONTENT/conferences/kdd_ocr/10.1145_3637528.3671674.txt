Scalable Algorithm for Finding Balanced Subgraphs with
Tolerance in Signed Networks
Jingbang Chenâˆ—
j293chen@uwaterloo.ca
David R. Cheriton School of
Computer Science, University of
Waterloo
Waterloo, CanadaQiuyang Mangâˆ—
qiuyangmang@link.cuhk.edu.cn
School of Data Science, The Chinese
University of Hong Kong, Shenzhen
Shenzhen, ChinaHangrui Zhouâˆ—
zhouhr23@mails.tsinghua.edu.cn
Institute for Interdisciplinary
Information Sciences (IIIS), Tsinghua
University
Beijing, China
Richard Peng
yangp@cs.cmu.edu
Computer Science Department,
Carnegie Mellon University
Pittsburgh, USAYu Gao
ygao2606@gmail.com
Independent
Beijing, ChinaChenhao Maâ€ 
machenhao@cuhk.edu.cn
School of Data Science, The Chinese
University of Hong Kong, Shenzhen
Shenzhen, China
ABSTRACT
Signed networks, characterized by edges labeled as either posi-
tive or negative, offer nuanced insights into interaction dynamics
beyond the capabilities of unsigned graphs. Central to this is the
task of identifying the maximum balanced subgraph, crucial for
applications like polarized community detection in social networks
and portfolio analysis in finance. Traditional models, however, are
limited by an assumption of perfect partitioning, which fails to
mirror the complexities of real-world data. Addressing this gap, we
introduce an innovative generalized balanced subgraph model that
incorporates tolerance for imbalance. Our proposed region-based
heuristic algorithm, tailored for this NP-hard problem, strikes a
balance between low time complexity and high-quality outcomes.
Comparative experiments validate its superior performance against
leading solutions, delivering enhanced effectiveness (notably larger
subgraph sizes) and efficiency (achieving up to 100 Ã—speedup) in
both traditional and generalized contexts.
CCS CONCEPTS
â€¢Theory of computation â†’Graph algorithms analysis.
KEYWORDS
graph mining, signed graph, dense subgraph, community detection
ACM Reference Format:
Jingbang Chen, Qiuyang Mang, Hangrui Zhou, Richard Peng, Yu Gao,
and Chenhao Ma. 2024. Scalable Algorithm for Finding Balanced Sub-
graphs with Tolerance in Signed Networks. In Proceedings of the 30th ACM
âˆ—The first three authors contributed equally to this research.
â€ Chenhao Ma is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD 2024, August 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671674SIGKDD Conference on Knowledge Discovery and Data Mining (KDD â€™24),
August 25â€“29, 2024, Barcelona, Spain. ACM, New York, NY, USA, 10 pages.
https://doi.org/10.1145/3637528.3671674
1 INTRODUCTION
Social media platforms, integral to our digital connectivity, trans-
form interactions into analyzable social networks. By deploying
graph algorithms, we discern network properties like community
detection [ 20,36] and partitioning [ 11], informing user experience
improvements and recommendation systems [ 35]. Yet, these plat-
forms can also engender echo chambers that reinforce divisive
ideologies, challenging democratic health. Consequently, detecting
and countering polarization in social networks is a critical area of
research [ 9,31], pivotal for developing defenses against misinfor-
mation [8, 14].
A classical model that applies to social networks to deal with po-
larization is the signed graphs. The signed graph model overcomes
the limitation that normal graphs cannot capture usersâ€™ dispositions.
Generally speaking, while the vertex set represents users, there are
two kinds of edges between vertices indicating agreement or dis-
agreement. We often refer to them as the positive and the negative
edges. The signed graph model was first introduced by Harary in
1953 [ 22] to study the concept of balance. The concept of balance is
important in signed graphs. Generally speaking, a signed graph is
balanced if it can be decomposed into two disjoint sets such that
positive edges are between vertices in the same set while negative
edges are between vertices from different sets. Such a concept has
many practical applications, especially in the polarization study. In
a social network, a balanced graph suggests two communities exist
with contrasting relationships while maintaining inner cohesion.
There are two lines of work when studying social network po-
larization with signed graphs. Since most graphs coming from real
scenarios are not balanced, if we can find the maximum balanced
subgraph (MBS) instead, it usually reveals the largest polarized
communities along with several important properties.
On the other line of work, instead of extracting the maximal
subgraph, it focuses on removing edges to guarantee the balance of
the original graph. The minimum number of edges whose deletion
 
278
KDD 2024, August 2024, Barcelona, Spain Jingbang Chen et al.
0% imbalanced edges10% imbalanced edges
20% imbalanced edges30% imbalanced edges
Figure 1: Balanced subgraphs are found in Cloister with
different tolerance, where solid edges are positive, dashed
edges are negative, black edges are balanced, and red edges
are imbalanced.
makes all connected components balanced is called the Frustration
Index of the given signed graph.
However, such a notion of balance is strict in that no edge can
disobey the condition. In reality, such strictness does not usually
appear. For example, though being dominated, there usually exists
some voices of disagreement on the majority idea, even in the
most extreme community. Besides, two individuals in different
political parties might reach a consensus on certain issues. In other
words, there usually exist some imbalanced edges in signed graphs
extracted from the community, which are against the strict notion
of balance. Failing to handle these imbalanced edges might prevent
us from identifying, extracting, and characterizing the community
properly in real scenarios. We provide an example in Figure 11: As
we increase the limitation for imbalanced edges, the community
is getting significantly larger and denser. Therefore, we may be
unable to capture the actual community if we prohibit imbalanced
edges when computing.
Many questions arise here due to the many limitations:
â€¢Can these two lines of work be unified?
â€¢Can we develop algorithms finding communities that are non-
strictly balanced?
In this paper, we answer these questions affirmatively. We de-
sign a tailored function to measure the tolerance of the imbalance.
To properly describe such tolerance, we adapt the frustration in-
dex as part of the tolerance function. In this way, we can either
allow no tolerance to extract the MBS in the network or a loose
tolerance to extract communities that might contain voices of dis-
agreement. We further raise new problems based on this tolerance
model and present a new region-based heuristic algorithm that com-
putes maximal balanced subgraphs under the tolerance setting. Our
new algorithm is versatile, delivering high-quality solutions across
1konect.cc/networks/moreno_sampsona range of problems based on the tolerance model, and itâ€™s also
efficient, with an expected output time proportional to the size of
the result. By setting different tolerances, we utilize our algorithm
to handle different tasks and compare it with the performance of
state-of-the-art algorithms2on 8 real-world datasets.
Our contributions are summarized as follows:
â€¢We introduce a novel, generalized, and practical model for iden-
tifying balanced subgraphs with tolerance in signed graphs.
â€¢We have developed an efficient region-based heuristic random-
ized algorithm, characterized by an expected time complexity
proportional to the size of the output, and coupled with a guar-
antee of result quality.
â€¢Extensive experiments show that our algorithm consistently out-
performs the baselines in terms of the quality of the returned
subgraphs and achieves up to 100 Ã—speedup in terms of running
time.
â€¢The effectiveness of our algorithm is also evident in its application
to polarized community detection, as detailed in Section 5.5.
Outline. The rest of the paper is organized as follows. We re-
view the related work in Section 2, and introduce our generalized
maximum balanced subgraph model with tolerance in Section 3.
Section 4 presents our region-based heuristic algorithm. Experi-
mental results are given in Section 5, and we conclude in Section 6.
2 RELATED WORK
Signed Graphs. Signed graphs were first introduced by Harary in
1956 to study the notion of balance [22]. Cartwright and Harary gen-
eralized Heiderâ€™s theory of balance onto signed graphs [ 12]. Harary
also developed an algorithm to detect balance in signed graphs [ 24].
There are other works on studying the minimum number of sign
changes to make the graph balance [ 3]. Spectral properties have
also been studied recently. Hou et al. have studied the smallest
eigenvalue in signed graphsâ€™ Laplacian [26, 27].
Many works focus on community detection or partition in signed
graphs. Anchuri et al. give a spectral method that partitions the
signed graph into non-overlapping balanced communities [ 4]. Dor-
eian and Mrvar propose an algorithm for partitioning a directed
signed graph and minimizing a measure of imbalance [18]. Yang et
al. give a random-walk-based method to partition into cohesively
polarized communities [ 37]. The more recent work is by Niu et
al [32]. They leverage the balanced triangles, which model cohe-
sion and polarization simultaneously, to design a good heuristic.
Maximum Balanced Subgraphs. The Maximum Balanced Sub-
graphs (MBS) problem has two variants: maximizing the number of
vertices (MBS-V) and edges (MBS-E). Poljak et al. give a tight lower
bound in 1986 [ 34] on the number of edges and vertices of the bal-
anced subgraph. The MBS-E problem is in fact NP-hard since it can
be formulated as a generalization of the standard MaxCut problem.
To find the exact solution, there are some algorithms in the context
offixed-parameter tractability (FPT) are developed [ 16,28]. More
studies are on extracting large balanced subgraphs. DasGupta et al.
have developed an algorithm based on semidefinite programming
relaxation (SDP) [ 17]. For the MBS-V problem, Figueiredo and Frota
propose several heuristic methods in 2014 [19].
2Here, the SOTA algorithms are adapted to fit our new tasks under various tolerances.
 
279Scalable Algorithm for Finding Balanced Subgraphs with Tolerance in Signed Networks KDD 2024, August 2024, Barcelona, Spain
In 2020, Ordozgoiti et al. proposed a new algorithm named Tim-
bal[33] that extracts large balanced subgraphs regarding both
vertices and edges. Timbal relies on signed spectral theory and the
bound for perturbations of the graph Laplacian. However, Timbal
is not stable and the balanced subgraph it found is sometimes small
and unsatisfying as shown in our experiments.
Frustration Index. The frustration index was first introduced in
1950s [ 1,23]. Computing the frustration index is related to the
EdgeBipartization problem, which requires minimization of the
number of edges whose deletion makes the graph bipartite. Since
EdgeBipartization isNP-hard, computing the frustration index is
alsoNP-hard. The MaxCut is also a special case of the frustration
index problem. Assuming Khotâ€™s unique games conjecture [ 30], it
is still NP-hard to approximate within any constant factor. For the
non-constant factor case, there are works that produce a solution
approximated to a factor of ğ‘‚(âˆšï¸
logğ‘›)[2] orğ‘‚(logğ‘˜)[7] whereğ‘›
is the number of vertices and ğ‘˜is the frustration index. Coleman et
al. have given a review on different approximation algorithms [ 15].
HÃ¼ffner et al. show that the frustration index is fixed parameter
tractable and can be computed in ğ‘‚(2ğ‘˜ğ‘š2), whereğ‘šis the number
of edges and ğ‘˜is the fixed parameter (the frustration index) [ 29].
There are also algorithms using binary programming models to
compute the exact frustration index [5, 6].
3 PROBLEM SPECIFICATION
A signed graph is an undirected simple graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’)
whereğ‘‰is the vertex set and ğ¸+,ğ¸âˆ’represent the positive and
negative signed edge sets. We first give the formal definition of
balanced graphs as follows, which is the same as the previous
works [ 32,33]. Note that we and these works require the graph to
be connected for the community detection proposal.
Definition 3.1 (Balanced Graph). Given a signed graph ğº=
(ğ‘‰,ğ¸+,ğ¸âˆ’),ğºis balanced if ğºis connected and there exists a partition
ğ‘‰=ğ‘‰1âˆªğ‘‰2,ğ‘‰1âˆ©ğ‘‰2=âˆ…such that for each edge (ğ‘–,ğ‘—)âˆˆğ¸+, vertices
ğ‘–andğ‘—belong to the same set within ğ‘‰1andğ‘‰2, while for each edge
(ğ‘–,ğ‘—)âˆˆğ¸âˆ’, they belong to the different sets.
Graphs are usually not balanced, especially when they are from
practical scenarios. Therefore, people turn to study to find the
maximum balanced subgraph (MBS) from the given graph. There
are usually two variants of problems: maximizing the number of
vertices [33] and edges [17].
Problem 1 (MBS-V). Given a signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’),
find the graph ğºâ€²=(ğ‘‰â€²,ğ¸â€²+,ğ¸â€²âˆ’)induced byğ‘‰â€²âŠ†ğ‘‰such thatğºâ€²
is balanced and|ğ‘‰â€²|is maximized.
Problem 2 (MBS-E). Given a signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’), find
the graphğºâ€²=(ğ‘‰â€²,ğ¸â€²+,ğ¸â€²âˆ’)induced byğ‘‰â€²âŠ†ğ‘‰such thatğºâ€²is
balanced and|ğ¸â€²+âˆªğ¸â€²âˆ’|is maximized.
We illustrate the concepts of MBS-V and MBS-E with an example
in Figure 2, along with other problems to be discussed below. Here,
we give a graph with 6 vertices numbered from 1to6where solid
edges are positive and dashed edges are negative, presented in (a).
When solving Problem 1 or 2 on this graph, the optimal subgraph
is constructed by vertex 1,2,3,5, whereğ‘‰1={1,3,5}andğ‘‰2={2}.
They are painted in two different colors in (b).
1
2 3
4 5
61
2 3
4 5
61
2 3
4 5
61
2 3
4 5
6
(a) (b) (c) (d)Figure 2: A signed graph (a), its MBS-V and MBS-E (b), its
TMBS-V and TMBS-E (c), and its ğ›½-TMBS (d) with ğ›½=1
3.
Another well-known problem in this topic is computing the
minimum number of edges whose deletion makes all connected
components balanced. This minimum amount of the edge removal
is called the Frustration Index of the given signed graph ğº, denoted
asğ¿(ğº).
Now, we are ready to introduce the concept of Balance with
ğ›½-tolerance in signed networks, which is central to our paper.
Definition 3.2 (Balanced Graph under ğ›½-Tolerance). Given
a signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’)and a tolerance parameter ğ›½âˆˆ(0,1],
ğºis balanced under ğ›½-Tolerance if ğºis connected andğ¿(ğº)
|ğ¸+âˆªğ¸âˆ’|â‰¤ğ›½.
In other words, when a graph is balanced under ğ›½-tolerance, it
implies that by removing at most ğ›½|ğ¸+âˆªğ¸âˆ’|edges from it, we
can ensure that all connected components of the remaining graph
become strictly balanced. Expanding upon the original definition
of balance, this concept allows for the tolerance of a maximum of
ğ›½|ğ¸+âˆªğ¸âˆ’|edges that disobey the partitioning of polarized com-
munities.
Under such ğ›½-tolerance restriction, finding the maximum bal-
anced subgraph is generalized into the following two problems.
Problem 3 (TMBS-V). Given a signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’)
and a tolerance parameter ğ›½âˆˆ(0,1], find the graph ğºâ€²=(ğ‘‰â€²,ğ¸â€²+,ğ¸â€²âˆ’)
induced byğ‘‰â€²âŠ†ğ‘‰such thatğºâ€²is balanced under ğ›½-Tolerance and
|ğ‘‰â€²|is maximized.
Problem 4 (TMBS-E). Given a signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’)
and a tolerance parameter ğ›½âˆˆ(0,1], find the graph ğºâ€²=(ğ‘‰â€²,ğ¸â€²+,ğ¸â€²âˆ’)
induced byğ‘‰â€²âŠ†ğ‘‰such thatğºâ€²is balanced under ğ›½-Tolerance and
|ğ¸â€²+âˆªğ¸â€²âˆ’|is maximized.
Whenğ›½becomes any value between (0,1
|ğ¸+âˆªğ¸âˆ’|),Problem 3 and
Problem 4 are equivalent to the Problem 1 and Problem 2 respec-
tively. However, unlike the strictly balanced graph, even deciding
whether a signed graph satisfies ğ›½-tolerance is hard. Formally, we
have the following lemma. The proof is deferred to Appendix A.1.3
Lemma 3.1. Given a signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’), deciding
whetherğºis balanced under ğ›½-tolerance cannot be done within poly-
nomial time for tolerance parameter ğ›½>1
|ğ¸+âˆªğ¸âˆ’|, unless P=NP.
Therefore, it is difficult to find large balanced graphs with tol-
erance and we cannot adapt any previous algorithms on MBS or
other related problems. Meanwhile, there is another limitation that
is worth mentioning. If ğ›½â‰¥ğ¿(ğº)
|ğ¸+âˆªğ¸âˆ’|,Problem 3 and Problem 4 has
a trivial optimal solution: the largest connected component. That
is to say, in such loose tolerance restriction, the optimal solution
3Due to the page limit, a full version with appendix can be found at https://github.
com/joyemang33/RH-TMBS/blob/main/paper_full_version.pdf
 
280KDD 2024, August 2024, Barcelona, Spain Jingbang Chen et al.
to these two problems might not reflect the polarized community.
The previous showcase given in Figure 2 (c) is a typical example:
When we solve Problem 3 and 4 with ğ›½=1
3in such graph, we get
the whole graph. However, vertex 6is in fact a noise that only has
negative edges connected to both ğ‘‰1andğ‘‰2. Therefore, it should
not be included in any meaningful subgraph solution.
To encounter the challenges and limitations, we first propose
Tolerant Balance Index, a novel metric to evaluate signed graphs
under the given tolerance for the balance.
Definition 3.3 (Tolerant Balance Index (TBI)). Given a signed
graphğº=(ğ‘‰,ğ¸+,ğ¸âˆ’)and a tolerance parameter ğ›½âˆˆ(0,1], define
its Tolerant Balance Index Î¦(ğº,ğ›½)as the value of|ğ¸+âˆªğ¸âˆ’|âˆ’ğ¿(ğº)
ğ›½.
Correspondingly, we propose the following problem as the main
task to solve throughout the paper.
Problem 5 (ğ›½-TMBS). Given a signed graph ğºand a tolerance
parameterğ›½âˆˆ(0,1], find the graph ğºâ€²induced byğ‘‰â€²âŠ†ğ‘‰such that
ğºâ€²is connected and Î¦(ğºâ€²,ğ›½)is maximized.
It is easy to show, for any balanced graph ğºunderğ›½-tolerance,
Î¦(ğº,ğ›½)â‰¥0. To discuss the usage of solving Problem 5, we also
want to address that maximizing the number of edges (Problem 2
and 4) approximates the solution for maximizing the number of
vertices (Problem 1 and 3). That is to say, these two variants of
MBS problems are related.
Lemma 3.2. Given a signed graph ğº, the solutions to Problem 2 and
Problem 4 are1
Î”-approximations for the Problem 1 and Problem 3
respectively, where Î”is the maximum degree of vertices in ğº.
We defer the proof of Lemma 3.2 to Appendix A.1. Considering
the aforementioned interrelationship between two variants, we
propose that finding the large connected subgraph with maximal
Î¦(ğº,ğ›½)(Problem 5) can be considered as a good approximation
of the solutions to Problem 3 and Problem 4 simultaneously. In
addition, since Problem 5 takes both the size and the polarity
into account, it mitigates the limitation of large ğ›½. When we solve
Problem 5 withğ›½=1
3on Figure 2 (a), the optimal subgraph will
be vertices excluded vertex 6, whereğ‘‰1={1,3,5}andğ‘‰2={2,4},
presented in (d). As it is shown, the noise vertex 6is not mistakenly
selected into the optimal subgraph we try to find. Therefore, the
polarity is being preserved.
In Section 4, we will present an efficient and effective algorithm
forProblem 5. Then in Section 5, we will demonstrate the experi-
mental results to support our proposal.
4 ALGORITHM
We propose Region-based Heuristic ( RH), a new algorithm that
searches for large balanced subgraphs with the ğ›½-tolerance restric-
tion (Problem 5). Our algorithm runs in a given signed graph
ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’), whereğ¸+,ğ¸âˆ’represent the positive and negative
signed edge sets. The tolerance parameter ğ›½is also given as input.
4.1 Relaxation
It is not easy to compute Î¦(ğº,ğ›½)directly. Instead, we propose an
alternative method to approximate it from the lower end while
guaranteeing the tolerance condition ( Î¦(ğº,ğ›½)â‰¥0) is not violated.For each vertex in ğº, we assign a color in {0,1}. Only vertices of
the same color can be grouped in the same community. We denote
any color assignment of ğºasX. Such definition is aligned with the
previous work [ 6]. Now, we are ready to give the formal definition
of our newly proposed Tolerant Balanced Count.
Definition 4.1 (Tolerant Balance Count (TBC)). Given a
signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’)under coloringXand a tolerance
parameterğ›½âˆˆ(0,1], define its Tolerant Balance Count as
Ë†Î¦(ğº,ğ›½,X)=|ğ¸+âˆªğ¸âˆ’|âˆ’1
ğ›½âˆ‘ï¸
(ğ‘–,ğ‘—)âˆˆğ¸+1{ğ‘¥ğ‘–â‰ ğ‘¥ğ‘—}âˆ’1
ğ›½âˆ‘ï¸
(ğ‘–,ğ‘—)âˆˆğ¸âˆ’1{ğ‘¥ğ‘–=ğ‘¥ğ‘—}
The following lemma states that Î¦(ğº,ğ›½)is, in fact, the upper
bound of Ë†Î¦(ğº,ğ›½,X)with respect to different coloring X. The proof
is deferred to Appendix A.2. We also have the following corollary
that ensures the ğ›½-tolerance requirement is not violated.
Lemma 4.1. Given a signed graph ğº=(ğ‘‰,ğ¸+,ğ¸âˆ’)and a tolerance
parameterğ›½âˆˆ(0,1], we have Î¦(ğº,ğ›½)=maxXË†Î¦(ğº,ğ›½,X).
Corollary 4.2. Given a signed graph ğºand a tolerance parameter
ğ›½,ğºis balanced under ğ›½-tolerance if there exists a coloring Xsuch
that Ë†Î¦(ğº,ğ›½,X)â‰¥ 0.
In this way, although we cannot compute Î¦(ğº,ğ›½)directly, we
can approximate the actual value by accumulating the non-negative
Ë†Î¦(ğº,ğ›½,X)values of various coloring. Additionally, by Corollary 4.2,
we can guarantee the ğ›½-tolerance during the whole computation.
Such relaxation plays an important role in our algorithm, and the
experimental results in Section 5 also validate its effectiveness.
4.2 Local Search
Our search process in Algorithm 1 starts from an initial vertex ğ‘ 
instead of the whole vertices set. We will discuss how to choose ğ‘ 
wisely in the later Section 4.3.
Search Operations. As discussed in Section 4.1, we will search for
a connected subgraph ğºâ€²and a coloringXsuch that Ë†Î¦(ğºâ€²,ğ›½,X)is
as large as possible. In the following, if not specified, we use Ë†Î¦to
denote the tolerant balanced count of the subgraph. Throughout
the search process, we use a set ğ‘†to store the selected vertices and
the coloring simultaneously. Specifically, ğ‘†stores selected tuples
(ğ‘¥,ğ‘), where(ğ‘¥,ğ‘)represents a vertex ğ‘¥colored asğ‘. There are
three basic operations with ğ‘†that will insert, delete, or change the
color of a vertex ğ‘¥respectively. Note that these three operations
well define the neighborhood of any solution we find.
â€¢VertexInsert(ğ‘¥,ğ‘): Executeğ‘†â†ğ‘†âˆª(ğ‘¥,ğ‘).
â€¢VertexDelete(ğ‘¥): Letğ‘be the color of ğ‘¥. Executeğ‘†â†ğ‘†\(ğ‘¥,ğ‘).
â€¢ColorFlip(ğ‘¥): Letğ‘be the color of ğ‘¥andğ‘beğ‘â€™s opposite color.
Execute VertexDelete(ğ‘¥)andVertexInsert(ğ‘¥,ğ‘)in order.
Since our search begins from ğ‘ , we initialize ğ‘†to be{(ğ‘ ,0)}
(line 1). We use Ë†Î¦ğ‘œğ‘ğ‘¡and Ë†Î¦ğ‘ğ‘¢ğ‘Ÿto store the maximum Ë†Î¦that we
have found and the current Ë†Î¦respectively. Initially, they are initial-
ized to be 0(line 1). During our process, if we choose to execute
VertexInsert(ğ‘¥,ğ‘)orColorFlip(ğ‘¥)for some vertex ğ‘¥, we will
greedily execute one with the maximal increment of Ë†Î¦that it can
contribute. Therefore, we use two max-heaps ğ‘€ğ»ğ¼,ğ‘€ğ»ğ¹to assist.
After being initialized (line 2), since ğ‘ is selected, for each neigh-
borğ‘£ofğ‘ , we calculate the corresponding contribution to Ë†Î¦when
 
281Scalable Algorithm for Finding Balanced Subgraphs with Tolerance in Signed Networks KDD 2024, August 2024, Barcelona, Spain
VertexInsert(ğ‘£,0)orVertexInsert(ğ‘£,1)are executed and insert
them toğ‘€ğ»ğ¼(line 4 to 5). For ğ‘€ğ»ğ¹, since only ğ‘ is selected, we
calculate the contribution for ColorFlip(ğ‘¥)and insert it into ğ‘€ğ»ğ¹
(line 3).
Here, we do not use any structure to store the contribution
when deleting any vertex from ğ‘†. Instead, whenever we want to
find the optimal deletion, we can compute for every vertex in ğ‘†
altogether with a total cost of ğ‘‚(ğ‘›), for which we may need to
use the well-known Tarjan algorithm [ 25] to guarantee the sub-
graph stays connected after the deletion. We denote such process
asDelEval(ğ‘†).
Our search method is to execute one of the three operations
repeatedly. If we only consider inserting vertices from ğ‘†â€™s neigh-
bors, the total number of VertexInsert is bounded by the size of
the graph. However, since we also have the other two operations,
which are non-incremental, if we do not design a proper termination
strategy, the time complexity might become exponential. Specifi-
cally, we have two parameters that help to define the termination
strategy of the algorithm: A float number ğ‘âˆˆ(0,1)denotes the
non-incremental probability and an integer ğ‘‡to limit the number
of potentially wasted operations.
Operation Selection. We first discuss how to select an operation
each time. Here, we will use the non-incremental probability ğ‘to
help determine. We use ğ‘œğ‘to denote the operation we select and
Î”Ë†Î¦to denote the corresponding contribution value to Ë†Î¦. These
two variables are initialized by acquiring the best VertexInsert
operation from ğ‘€ğ»ğ¼(line 7), indicating choosing an insertion. Then,
we generate a random float number ğ‘§from uniform distribution
ğ‘ˆ(0,1). Ifğ‘§<ğ‘, we also consider using a ColorFlip operation: We
acquire the best ColorFlip operation from ğ‘€ğ»ğ¹and update the
two variables if the corresponding Î”Ë†Î¦is larger than the current
one (line 8 to 9). Similarly, we regenerate ğ‘§and ifğ‘§<ğ‘log|ğ‘†|
|ğ‘†|, we
try choosing a VertexDelete operation: After calling DelEval(ğ‘†)
to recalculate for every possible vertex deletion, we choose the best
among them and try updating (line 10 to 12). In this way, we choose
anVertexInsert operation by default, and with some probability,
we check if the current optimal ColorFlip andVertexDelete can
contribute more. The two probabilities are by design and help to
balance between accuracy and efficiency.
We execute the current ğ‘œğ‘operation after the selection phase and
also update the current Ë†Î¦ğ‘ğ‘¢ğ‘Ÿ. Sinceğ‘†is updated after the execution,
we must also update ğ‘€ğ»ğ¼andğ‘€ğ»ğ¹correspondingly. This is done
in a similar way as the initialization (line 13 to 17).
Search Termination. When the current selected operation en-
larges the current Ë†Î¦ğ‘ğ‘¢ğ‘Ÿ, we denote such operation as a progressive
one. Otherwise, it is non-progressive. We use a parameter ğ‘‡to pre-
vent too many non-progressive operations. Specifically, our search
will terminate when the number of non-progressive operations ex-
ceedsğ‘‡times the number of progressive operations. We implement
such a strategy with a counter ğ‘¡. After we select and execute an
operation (line 7 to 17), we compare the current Ë†Î¦ğ‘ğ‘¢ğ‘Ÿwith Ë†Î¦ğ‘œğ‘ğ‘¡. If
Ë†Î¦ğ‘ğ‘¢ğ‘Ÿis smaller, we decrease ğ‘¡by1. Otherwise, we update Ë†Î¦ğ‘œğ‘ğ‘¡and
increaseğ‘¡byğ‘‡(line 18 to 19). In this way, if ğ‘¡<0, the search should
terminate (line 6). In addition, we also terminate the search when ğ‘†
contains all vertices in ğºsince no further insertion can be executedAlgorithm 1: RH: Search
Input: Signed graph ğº; Tolerance parameter ğ›½;
Non-incremental probability ğ‘; Initial vertex ğ‘ ; Early
stop turn limit ğ‘‡.
Output:ğ»âŠ†ğº: the found balanced subgraph with
ğ›½-tolerance; Ë†Î¦: the lower bound of ğ»â€™s balance
value we achieved.
1ğ‘†â†{(ğ‘ , 0)},Ë†Î¦ğ‘œğ‘ğ‘¡â†0,Ë†Î¦ğ‘ğ‘¢ğ‘Ÿâ†0,ğ‘¡â†ğ‘‡;
2Initialize max-heaps ğ‘€ğ»ğ¼,ğ‘€ğ»ğ¹;
3Insertğ‘ intoğ‘€ğ»ğ¹;
4forğ‘£âˆˆğ‘(ğ‘ )do
5 Insert(ğ‘£,0)and(ğ‘£,1)intoğ‘€ğ»ğ¼;
6whileğ‘¡â‰¥0and|ğ‘†|<|ğ‘‰(ğº)|do
7{ğ‘œğ‘,Î”Ë†Î¦}=GetTopNode(ğ‘€ğ»ğ¼); // ordered by Î”Ë†Î¦
8 ifğ‘§âˆ¼ğ‘ˆ(0,1)<ğ‘then
9{ğ‘œğ‘,Î”Ë†Î¦}â† max({ğ‘œğ‘,Î”Ë†Î¦},GetTopNode(ğ‘€ğ»ğ¹));
10 ifğ‘§âˆ¼ğ‘ˆ(0,1)<ğ‘log|ğ‘†|
|ğ‘†|then
11{Ë†ğ‘œğ‘,Î”Ë†Î¦}â† DelEval(ğ‘†);
12{ğ‘œğ‘,Î”Ë†Î¦}â† max({ğ‘œğ‘,Î”Ë†Î¦},{Ë†ğ‘œğ‘,Î”Ë†Î¦});
13ğ‘†â†Execute operation ğ‘œğ‘onğ‘†;
14ğ‘¥â†the vertex of the ğ‘œğ‘;
15 forğ‘£âˆˆğ‘(ğ‘¥)âˆªğ‘¥do
16 Insert, update or delete ğ‘£â€™s operations in ğ‘€ğ»ğ¼and
ğ‘€ğ»ğ¹;
17 Ë†Î¦ğ‘ğ‘¢ğ‘Ÿâ†Ë†Î¦ğ‘ğ‘¢ğ‘Ÿ+Î”Ë†Î¦;
18 ifË†Î¦ğ‘ğ‘¢ğ‘Ÿâ‰¤Ë†Î¦ğ‘œğ‘ğ‘¡thenğ‘¡â†ğ‘¡âˆ’1;
19 else Ë†Î¦ğ‘œğ‘ğ‘¡â†Ë†Î¦ğ‘ğ‘¢ğ‘Ÿ,ğ‘¡â†ğ‘¡+ğ‘‡;
20Undo the last non-progressive operations on ğ‘†;
21returnğ»=ğº[ğ‘†],Ë†Î¦=Ë†Î¦ğ‘œğ‘ğ‘¡;
(line 6). After the search, we undo the last few non-progressive
operations to retract the optimal subgraph we have found (line 20).
We return with this subgraph as ğ»and its corresponding Ë†Î¦(line 21).
4.3 Region-based Sampling
In the previous section, we propose a search process that starts
from an arbitrary vertex ğ‘ . It is reasonable to foresee that the choice
ofğ‘ might affect the result significantly. If we start only from too
few vertices, our result in the end might be some local maximal
solutions, which would be much worse than the global maximal one.
One of the solutions is to enumerate all possible ğ‘ ,i.e., all vertices in
ğº. However, such pure enumeration may result in excessively high
time complexity. To balance between performance and efficiency,
we propose a Region-based Sampling strategy.
Our sampling method is mainly based on two hypotheses. The
first hypothesis indicates that the probability of finding a nearly
optimal subgraph is high if we are able to select some vertices in the
optimal subgraph as the starting vertex. Here, the â€˜optimalâ€™ denotes
the solution we found by enumerating all vertices as the starting
vertex. We formally state such a hypothesis as follows.
Hypothesis 4.1. Given a signed graph ğºand a tolerance parame-
terğ›½, suppose the optimal subgraph found by Algorithm 1 starting
 
282KDD 2024, August 2024, Barcelona, Spain Jingbang Chen et al.
Algorithm 2: RH: Sampling
Input: Signed graph ğº; Tolerance parameter ğ›½; Iteration
constantC; Non-incremental probability ğ‘; Early
stop turn limit ğ‘‡.
Output:ğ»âŠ†ğº: the found balanced subgraph with
ğ›½-tolerance.
1ğ»â†âˆ…;
2Ë†Î¦ğ‘œğ‘ğ‘¡â†0;
3ğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’â†0;
4whileğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’ <C|ğ‘‰(ğº)|do
5ğ‘ â†Sample a vertex from ğ‘‰(ğº);
6ğ»,Ë†Î¦â†Search(ğº,ğ›½,ğ‘ ,ğ‘,ğ‘‡ );
7 ifË†Î¦>Î¦ğ‘œğ‘ğ‘¡then
8 Ë†Î¦â†Ë†Î¦ğ‘œğ‘ğ‘¡;
9ğ»â†ğ»;
10ğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’â†ğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’+|ğ‘‰(ğ»)|;
11returnğ»;
with vertexğ‘¥isğºğ‘¥, and the optimal graph among all ğºğ‘¥isğºğ‘œğ‘ğ‘¡. For
the givenğœ–, there exists a subset ğ‘‰â€²âŠ†ğ‘‰(ğºğ‘œğ‘ğ‘¡)with|ğ‘‰â€²|
|ğ‘‰(ğºğ‘œğ‘ğ‘¡)|â‰¥1
2
such that Î¦(ğºğ‘¥,ğ›½)â‰¥( 1âˆ’ğœ–)Î¦(ğºğ‘œğ‘ğ‘¡,ğ›½),âˆ€ğ‘¥âˆˆğ‘‰â€².
Another hypothesis describes the relation between Ë†Î¦values
returned by two different calls of Algorithm 1, if we select different
starting vertex. We argue that if the return Ë†Î¦value is larger, the
found subgraph will likely be bigger. We formally state such a
hypothesis as follows.
Hypothesis 4.2. Given a signed graph ğºand a tolerance parame-
terğ›½, suppose the optimal subgraph and coloring found by Algorithm 1
starting with vertex ğ‘areğºğ‘andXğ‘, starting with ğ‘areğºğ‘andXğ‘.
IfË†Î¦(ğºğ‘,ğ›½,Xğ‘)â‰¥Ë†Î¦(ğºğ‘,ğ›½,Xğ‘), we have|ğ‘‰(ğºğ‘)|â‰¤ 2|ğ‘‰(ğºğ‘)|.
With these two hypotheses, we have the following lemma that
describes a sampling strategy that is able to find a (1âˆ’ğœ–)-optimal
subgraph within an acceptable number of calls of the search process.
The proof is deferred to Appendix A.2.
Lemma 4.3. Given a signed graph ğº, a tolerance parameter ğ›½, and a
positiveğœ–<1, suppose we run Algorithm 1 in ğ‘˜iterations, where the ğ‘–-
th iteration starts with a uniformly sampled vertex ğ‘¥ğ‘–âˆˆğ‘‰(ğº), and the
optimal subgraph found is ğºğ‘–. IfHypothesis 4.1 and Hypothesis 4.2
hold, the expected number of iterations that find a (1âˆ’ğœ–)-optimal
subgraph E[ğ‘‹]isÎ©(Ãğ‘˜
ğ‘–=1|ğ‘‰(ğºğ‘–)|/|ğ‘‰(ğº)|).
We provide an implementation of such sampling strategy in
Algorithm 2, which is, in fact, an application of Lemma 4.3. We
useğ»,Ë†Î¦ğ‘œğ‘ğ‘¡to keep track of the current optimal subgraph and its
corresponding Ë†Î¦value. They are initialized to be âˆ…and0in the
beginning (line 1 to 2). We also use a variable ğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’ to keep
track of the total size of all return subgraphs from Algorithm 1,
which is also initialized to be 0(line 3).
For each iteration, we randomly select a vertex ğ‘ (line 5) as the
starting vertex and pass it into Algorithm 1 (line 6). After receiving
the result from Algorithm 1, we update ğ»,Ë†Î¦ğ‘œğ‘ğ‘¡(line 8 to 9) if the
newly found subgraph is better (line 7). Before the new iteration,we accumulate the size of the newly found subgraph into ğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’
(line 10. The whole process will stop when ğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’â‰¥C|ğ‘‰(ğº)|
(line 4). By Lemma 4.3, we can set a proper termination condition
by accumulating the subgraph size from each search process. More
specifically, When ğ‘‡ğ‘œğ‘¡ğ‘ğ‘™ğ‘†ğ‘–ğ‘§ğ‘’ reachesC|ğ‘‰(ğº)|, it is expected to find
a nearly optimal solution Ctimes. In the end, we return ğ»as the
main result (line 11).
Time Complexity Analysis. We show that the time complexity
of Algorithm 2 is ğ‘‚(Î”(C+ 1)ğ‘›log2ğ‘›), whereğ‘›is the number of
vertices inğº. We start with the time complexity of Algorithm 1.
Lemma 4.4. Suppose that the loop starting on Line 6 repeats for
a total ofğ‘¡times. Letâ„be the size of ğ‘†on Line 21. Then we have,
with high probability, â„=Î©(ğ‘¡/logğ‘›)and that the running time of
Algorithm 1 is ğ‘‚(Î”ğ‘¡logğ‘›)in expectation.
Proof. By Lemma A.1, with high probability, â„=Î©(ğ‘¡/logğ‘›).
LetÎ”be the maximum degree of ğº. The running time of each
iteration is dominated by the cost of updating the heaps and the
time for DelEval(ğ‘†). Updating the heaps cost ğ‘‚(Î”logğ‘›)time. The
function DelEval(ğ‘†)costsğ‘‚(Î”|ğ‘†|)time. It is called with probabil-
ityğ‘log|ğ‘†|
|ğ‘†|in each iteration. Thus, its expected runtime in each
iteration isğ‘‚(Î”logğ‘›). We have the running time of Algorithm 1 is
ğ‘¡Â·ğ‘‚(Î”logğ‘›)=ğ‘‚(Î”ğ‘¡logğ‘›). â–¡
Lemma 4.5. With high probability, the expected time complexity
of Algorithm 2 is ğ‘‚(Î”(C+ 1)ğ‘›log2ğ‘›).
Proof. Suppose we call Line 6 for ğ‘˜times. For the ğ‘–-th call,
letğ‘¡ğ‘–be the number of iterations of the loop on Line 6 and let â„ğ‘–
(1â‰¤ğ‘–â‰¤ğ‘˜) be the size of ğ‘†on Line 21. By Lemma 4.4, the total
time complexity in expectation is ğ‘‚(Ãğ‘˜
ğ‘–=1Î”ğ‘¡ğ‘–logğ‘›), and the sum of
â„ğ‘–satisfiesÃğ‘˜
ğ‘–=1â„ğ‘–=Î©(Ãğ‘˜
ğ‘–=1ğ‘¡ğ‘–/logğ‘›).SinceÃğ‘˜
ğ‘–=1â„ğ‘–â‰¤(C+ 1)ğ‘›,
we have that the total runtime of Algorithm 2 in expectation is
ğ‘‚(Ãğ‘˜
ğ‘–=1Î”ğ‘¡ğ‘–logğ‘›)=ğ‘‚(Î”(C+ 1)ğ‘›log2ğ‘›). â–¡
5 EVALUATION
In this section, we address the following research questions to
evaluate various important aspects of our algorithm:
â€¢RQ1 (Effectiveness - TMBS): Given various ğ›½, what are the
optimal subgraphs in terms of size, and Tolerant Index Count,
found by our method and baselines?
â€¢RQ2 (Effectiveness - MBS): What are our methodâ€™s and base-
linesâ€™ performances in finding the maximum balanced subgraph?
â€¢RQ3 (Efficiency): What are the runtimes for our method and
the baselines, and how do they scale with very large networks?
â€¢RQ4 (Generalizability): Can our model and method be adapted
to other related tasks in the signed networks?
We also conduct three experiments shown in appendix B, which
are designed to validate our hypotheses, determine optimal hyper-
parameters, and assess stability.
5.1 Experimental Setting
Baselines. We compare our method with the baselines from
highly related works (e.g., MBS and polarized community detection),
including spectral and other heuristic methods.
 
283Scalable Algorithm for Finding Balanced Subgraphs with Tolerance in Signed Networks KDD 2024, August 2024, Barcelona, Spain
Table 1: Signed network datasets used in experiments, includ-
ing the number of vertices ( |ğ‘‰|) and edges (|ğ¸|), the ratio of
negative edges ( ğœŒâˆ’), and the ratio of non-zero elements ( ğ›¿).
Dataset|ğ‘‰|
|ğ¸+âˆªğ¸âˆ’|ğœŒâˆ’=|ğ¸âˆ’|
|ğ¸+âˆªğ¸âˆ’|ğ›¿=2|ğ¸+âˆªğ¸âˆ’|
|ğ‘‰|
(|ğ‘‰|âˆ’1)
Bit
coin 5k
21k 0.15 1.2e-03
Epinions 131k
711k 0.17 8.2e-05
Slashdo
t 82k
500k 0.23 1.4e-04
Twitter 10k
251k 0.05 4.2e-03
Conflict 116k
2M 0.62 2.9e-04
Elections 7k
100k 0.22 3.9e-03
P
olitics 138k
715k 0.12 7.4e-05
Gro
wth 1.87M
40M 0.50 2.3e-05
Note that since finding tolerant balanced subgraphs is typically
more challenging than previous community detection tasks in
signed networks, we also adapt our TBC-relaxation in Section 4.1
for all baseline methods to ensure that they can return the sub-
graphs satisfying the tolerance constraint. We summarize the core
ideas of each baseline method as follows.
â€¢Eigen: Based on a spectral method from [ 10], we first compute v,
the eigenvector of the signed adjacency matrix ğ´corresponding
to the largest eigen value ğœ†. For each vertex ğ‘–, if a Bernoulli
experiment with success probability ğ‘=|vğ‘–|is successful, we
assign vertex ğ‘–a color determined by sgn(vğ‘–). The maximum
connected components with non-negative Ë†Î¦serve as solutions
toProblem 3 and Problem 4, while the connected component
with the maximum Ë†Î¦provides the solution to Problem 5.
â€¢Timbal: Based on a state-of-the-art method for MBS from [ 33],
we start from the entire graph and repeatedly remove vertices
from it, guided by an eigenvalue approximation outlined in their
paper. Specifically, we compute Ë†Î¦by the optimal coloring among
two non-trivial methods [10, 21] for TMBS problems.
â€¢GreSt: This method combines a classical and effective algorithm
in dense subgraph [ 13] and a heuristic coloring method for signed
networks by spanning tree [ 21]. Firstly, we determine the coloring
of the entire graph by a random spanning tree. We then repeatedly
remove vertices maximizing Ë†Î¦of the remaining graph. A min-
heap is used to speed up the process of finding vertices. To acquire
the solution to different tasks, we need to store the deletion
operations. Then we can restore the graph by undoing deletions
one by one. Such reversal allows us to keep track of the optimal
connected component efficiently, instead of scanning the whole
graph after each deletion.
â€¢RH (LS): Instead of using region-based sampling, we execute our
local search in Section 4.2 for all starting vertices and select the
optimal solutions, to investigate the effectiveness of the regional-
based sampling. This method may provide a better solution than
RHbut is not efficient.
Datasets. We select 7 publicly-available real-world signed net-
works4,Bitcoin, Epinions, Slashdot, Twitter, Conflict, Elec-
tions, and Politics, which were widely used in previous related
works [ 10,32,33]. In addition, to investigate our methodsâ€™ scala-
bility, we generate Growth, a very large signed network induced
4From konect.cc and snap.stanford.edufrom the real temporal network Wikipedia-growth5. Specifically,
we select a threshold ğœ, and give positive signs for the edges with
time stampğ‘¡(ğ‘’)â‰¥ğœand negative signs for the edges with ğ‘¡(ğ‘’)<ğœ.
By using a proper ğœ, the ratio of negative edges of the induced graph
can be 0.5. In this network, a balanced graph contains two commu-
nities, where the edges within each community are recently formed,
while the crossing edges are relatively old. Detailed information
for each dataset can be found in Table 1.
All experiments are conducted on a Ubuntu 22.04 LTS worksta-
tion, equipped with a 12th Gen Intel(R) Core(TM) i9-12900HX. We
set hyperparameters ğ‘‡=20,ğ‘=0.8,C=1.5for all experiments.
5.2 Finding Balanced Subgraphs with Tolerance
We aim to identify sizable and polarized subgraphs while taking
the tolerance into account (RQ1). Firstly, by running algorithms
in Section 5.1, we keep track of the optimal subgraph that we
have found to Problem 3,Problem 4, and Problem 5 respectively.
Noticeably, we do not modify either RHorRH (LS) forProblem 3
andProblem 4. That is to say, we directly use our result on solving
Problem 5 to compare with other algorithms which are tailored for
either Problem 3 orProblem 4, which demonstrates our proposed
Problem 5 is a good approximation for the other two problems.
The comparison results for these three problems are shown in
Figure 3, Figure 4, and Figure 5, respectively. In our experiments,
we consider 15different tolerance parameters ( ğ›½ğ‘–=2âˆ’ğ‘–/2for all
2â‰¤ğ‘–â‰¤16), whereğ‘–=2implies allowance for all connected
subgraphs, while ğ‘–=16means that the found subgraphs are almost
strictly balanced. Since Problem 3 and Problem 4 become trivial
whenğ›½â‰¥ğ¿(ğº)
|ğ¸+âˆªğ¸âˆ’|, we shade the corresponding ranges6in Figure 3
and Figure 4. We omit the results for methods that cannot finish in
100,000 seconds.
Observing the experiment results, our proposed method RH
outperforms all other baselines significantly in all three problems.
This also demonstrates that our proposed tolerance model is a more
realistic model for the general case of balanced signed graph models.
In addition, we can see that RHproduces results that are close to RH
(LS). Therefore, we manage to empirically support our hypothesis
in Section 4.3 in real-world data.
5.3 Finding Strictly Balanced Subgraphs
Finding the Maximum Balanced Subgraph (Problem 1 and 2) is
an important and well-studied problem in signed networks [ 33]
(RQ2). As previously discussed, MBS problems are special forms of
proposed TMBS problems (Problem 3 and 4) by setting ğ›½<1
|ğ¸+âˆªğ¸âˆ’|.
Table 2 shows the results of our case study on the MBS prob-
lems, where we omit the results for Eigen since it cannot return
subgraphs other than a single vertex. RHproduces significantly
better results than the previous state-of-the-art method Timbal,
which is specifically designed for the MBS problems while ours is
not.
5http://konect.cc/networks/wikipedia-growth
6As computing the exact value of ğ¿(ğº)isNP-hard, we cannot calculate the exact
range ofğ›½corresponding to the trivial cases. Instead, we calculate an upper bound ğ¿
ofğ¿(ğº)by a promising valid solution and shade only the subrange ğ›½â‰¥ğ¿
|ğ¸+âˆªğ¸âˆ’|.
 
284KDD 2024, August 2024, Barcelona, Spain Jingbang Chen et al.
Figure 3: Problem 3: Comparing maximum tolerantly balanced subgraphs in vertex cardinality ( |ğ‘‰|) across various tolerances
(ğ›½=2âˆ’ğ‘¥/2), where the part corresponding to trivial ğ›½values for this problem has been shaded.
Figure 4: Probelm 4: Comparing maximum tolerantly balanced subgraphs in edge cardinality ( |ğ¸+âˆªğ¸âˆ’|) across various
tolerances ( ğ›½=2âˆ’ğ‘¥/2), where the part corresponding to trivial ğ›½values for this problem has been shaded.
Figure 5: Probelm 5: Comparing maximum tolerantly balanced subgraphs in TBC ( Ë†Î¦) across various tolerances ( ğ›½=2âˆ’ğ‘¥/2).
Table 2: Case study: Largest strictly balanced subgraph (in terms of |ğ‘‰|or|ğ¸|) found by each method for each dataset ( ğ›½<1
|ğ¸+âˆªğ¸âˆ’|),
where NAdenotes the corresponding method cannot finish in 100,000 seconds on the respective dataset.
Metho
dBit
coin Epinions Slashdo
t Twitter Conflict Elections P
olitics Gro
wth
|ğ‘‰|
|ğ¸||ğ‘‰|
|ğ¸||ğ‘‰|
|ğ¸||ğ‘‰|
|ğ¸||ğ‘‰|
|ğ¸||ğ‘‰|
|ğ¸||ğ‘‰|
|ğ¸||ğ‘‰|
|ğ¸|
Timbal 4,050
9,757 65,879 190,751 43,742 101,590 8,636
129,927 51,463 361,663 3,579
17,633 65,188 230,529 NA
NA
GreSt 571
713 7,078
9,229 7,923
8,465 1,895
2,277 759
4,885 935
1,232 2,371
3,155 272,621 375,603
RH
(LS) 5,002
13,746 NA
NA NA
NA 9,628
209,633 NA
NA 3,970
28,453 NA
NA NA
NA
RH 4,935 13,050 84,165
302,152 55,968
181,069 9,628
209,633 65,468
746,640 3,926 26,478 72,431
317,384 999,504
3,415,441
 
285Scalable Algorithm for Finding Balanced Subgraphs with Tolerance in Signed Networks KDD 2024, August 2024, Barcelona, Spain
5.4 Running Time Analysis
This experiment is designed to study the efficiency and scalability of
our method (RQ3). As shown in Table 3, when the graph size is up
to (|ğ‘‰|=1.87M,|ğ¸+âˆªğ¸âˆ’|=40M), RHcan still produce reasonable
results within 1,000 seconds. On the other hand, the other four
compared methods either produce much worse results while taking
longer time or even fail to finish execution in 100,000 seconds. In all,
the empirical results demonstrate the efficiency of our method in
real-world data in addition to its asymptotic theoretical complexity.
5.5 Solving the 2PC Problem
This experiment aims to evaluate the generalizability when adapt-
ing RH and our tolerant model to different variants of polarity
community detection (RQ4). In addition to balance-related prob-
lems, 2-Polarized-Communities (2PC), proposed by Bonchi and
Galimberti [ 10], serves as another model for polarized community
detection. In their model, the measurement of polarity is penalized
by the size of the solution:
Problem 6 (2PC). Given a signed graph ğºwith signed adjacency
matrixğ´, find a vector ğ‘¥âˆˆ{âˆ’1,0,1}that maximizesğ‘¥ğ‘‡ğ´ğ‘¥
ğ‘¥ğ‘‡ğ‘¥.
To solve the 2PC problem by our tolerance balance model, we
add an additional penalty term to the solution size in the tolerant
balance count: We define Ë†Î¦â€²(ğº,ğ›½,X,ğœŒ)=Ë†Î¦(ğº,ğ›½,X)âˆ’ğœŒ|ğ‘‰|to
serve as a new object function in our RHalgorithm. Throughout
the algorithm, we set ğ›½=1
2. This is because when ğ›½=1
2, ifË†Î¦â€²â‰¥0,
the polarity is no less than ğœŒ. Therefore, Problem 6 can be solved
by the new RHalgorithm, where we apply an iterative mechanism
onğœŒ. The algorithm details can be found in Appendix A.3.
We compare RHâ€™s results with the optimal result computed by
the two methods in Bonchi and Galimbertiâ€™s paper [ 10] (i.e., Eigen
andGreedy). The results are shown in Table 4. RHâ€™s slight modifi-
cations efficiently yield promising communities, demonstrating the
adaptability and effectiveness of our tolerant balance model and
algorithm in varied polarity community detection scenarios.
Table 3: Mean running time (s) for each method on the vari-
ousğ›½in Section 5.2.
Dataset Eigen
Timbal GreSt RH (LS) RH
Bit
coin 0.979
2.670 0.018 135.040 0.057
Epinions 9.213
220.919 0.319 â‰¥100,000 4.162
Slashdo
t 7.287
226.805 0.218 â‰¥100,000 3.175
Twitter 1.704
7.306 0.085 2,516.671 0.493
Conflict 12.899
310.736 0.781 â‰¥100,000 9.031
Elections 1.022
4.542 0.039 675.484 0.288
P
olitics 10.003
143.605 0.304 â‰¥100,000 4.782
Gro
wth 297.299â‰¥100,000 48.915â‰¥100,000 813.099Table 4: Optimal subgraphs in the term of 2PC-polarity
(ğ‘¥ğ‘‡ğ´ğ‘¥
ğ‘¥ğ‘‡ğ‘¥) found by each method, associated with running time.
DatasetRH Eigen Greed
y
p
olarity time (s) p
olarity time (s) p
olarity time (s)
Bit
coin 14.82
0.035 14.76
0.706 14.50
0.999
Epinions 85.27
0.873 64.36
10.271 85.15
428.625
Slashdo
t 41.21 0.584 39.85
7.325 41.36 154.383
Twitter 87.21
0.818 87.04
1.717 86.97
7.853
Conflict 94.27 15.134 87.83 13.144 63.99
552.629
Elections 36.27 0.395 35.87
0.950 36.34 2.223
P
olitics 44.95 0.862 44.22
9.931 45.01 475.353
6 CONCLUSIONS
This paper presents a new and versatile model to identify polar-
ized communities in signed graphs. The model accommodates in-
herent imbalances in polarized communities through a tolerance
feature. Additionally, we propose a region-based heuristic algo-
rithm. Through a wide variety of experiments on graphs of up to
40 M edges, it demonstrates effectiveness and efficiency beyond the
state-of-the-art methods in addressing both traditional and gener-
alized MBS problems. We also adapt our model and algorithm to
2PC, a related but essentially different task, further verifying their
generalizability.
7 REPRODUCIBILITY
Codes for our methods and for reproducing all the experimental
results are available at GitHub7.
ACKNOWLEDGMENTS
Chenhao Ma was partially supported by NSFC under Grant 62302421,
Basic and Applied Basic Research Fund in Guangdong Province
under Grant 2023A1515011280, and the Guangdong Provincial Key
Laboratory of Big Data Computing, the Chinese University of Hong
Kong, Shenzhen. We thank Yixiang Fang (The Chinese University
of Hong Kong, Shenzhen), Qingyu Shi (Hailiang Foreign Language
School), and Xinwen Zhang (The Chinese University of Hong Kong,
Shenzhen) for valuable advice on this project.
7https://github.com/joyemang33/RH-TMBS
 
286KDD 2024, August 2024, Barcelona, Spain Jingbang Chen et al.
REFERENCES
[1]Robert P Abelson and Milton J Rosenberg. 1958. Symbolic psycho-logic: A model
of attitudinal cognition. Behavioral Science (1958).
[2]Amit Agarwal, Moses Charikar, Konstantin Makarychev, and Yury Makarychev.
2005. O(âˆšï¸
logğ‘›) Approximation Algorithms for Min UnCut, Min 2CNF Deletion,
and Directed Cut Problems. In Proceedings of the thirty-seventh annual ACM
symposium on Theory of computing. 573â€“581.
[3]Jin Akiyama, David Avis, Vasek ChvÃ¡tal, and Hiroshi Era. 1981. Balancing signed
graphs. Discrete Applied Mathematics 3, 4 (1981), 227â€“233.
[4]Pranay Anchuri and Malik Magdon-Ismail. 2012. Communities and balance in
signed networks: A spectral approach. In 2012 IEEE/ACM International Conference
on Advances in Social Networks Analysis and Mining. IEEE, 235â€“242.
[5]Samin Aref, Andrew J Mason, and Mark C Wilson. 2018. Computing the line
index of balance using integer programming optimisation. Optimization Problems
in Graph Theory: In Honor of Gregory Z. Gutinâ€™s 60th Birthday (2018), 65â€“84.
[6]Samin Aref, Andrew J Mason, and Mark C Wilson. 2020. A modeling and compu-
tational study of the frustration index in signed networks. Networks 75, 1 (2020),
95â€“110.
[7]Adi Avidor and Michael Langberg. 2007. The multi-multiway cut problem. Theo-
retical Computer Science 377, 1-3 (2007), 35â€“42.
[8]Prithu Banerjee, Wei Chen, and Laks VS Lakshmanan. 2023. Mitigating Fil-
ter Bubbles Under a Competitive Diffusion Model. Proceedings of the ACM on
Management of Data 1, 2 (2023), 1â€“26.
[9]Fabian Baumann, Philipp Lorenz-Spreen, Igor M Sokolov, and Michele Starnini.
2020. Modeling echo chambers and polarization dynamics in social networks.
Physical Review Letters 124, 4 (2020), 048301.
[10] Francesco Bonchi, Edoardo Galimberti, Aristides Gionis, Bruno Ordozgoiti, and
Giancarlo Ruffo. 2019. Discovering Polarized Communities in Signed Networks.
CoRR abs/1910.02438 (2019). arXiv:1910.02438 http://arxiv.org/abs/1910.02438
[11] AydÄ±n BuluÃ§, Henning Meyerhenke, Ilya Safro, Peter Sanders, and Christian
Schulz. 2016. Recent advances in graph partitioning. Springer.
[12] Dorwin Cartwright and Frank Harary. 1956. Structural balance: a generalization
of Heiderâ€™s theory. Psychological review 63, 5 (1956), 277.
[13] Moses Charikar. 2000. Greedy Approximation Algorithms for Finding Dense
Components in a Graph. In Approximation Algorithms for Combinatorial Op-
timization, Klaus Jansen and Samir Khuller (Eds.). Springer Berlin Heidelberg,
Berlin, Heidelberg, 84â€“95.
[14] Uthsav Chitra and Christopher Musco. 2020. Analyzing the impact of filter
bubbles on social network polarization. In Proceedings of the 13th International
Conference on Web Search and Data Mining. 115â€“123.
[15] Tom Coleman, James Saunderson, and Anthony Wirth. 2008. A local-search
2-approximation for 2-correlation-clustering. In European Symposium on Algo-
rithms. Springer, 308â€“319.
[16] Robert Crowston, Gregory Gutin, Mark Jones, and Gabriele Muciaccia. 2013. Max-
imum balanced subgraph problem parameterized above lower bound. Theoretical
Computer Science 513 (2013), 53â€“64.
[17] Bhaskar DasGupta, German Andres Enciso, Eduardo Sontag, and Yi Zhang. 2007.
Algorithmic and complexity results for decompositions of biological networks
into monotone subsystems. Biosystems 90, 1 (2007), 161â€“178.
[18] Patrick Doreian and Andrej Mrvar. 1996. A partitioning approach to structural
balance. Social networks 18, 2 (1996), 149â€“168.[19] Rosa Figueiredo and Yuri Frota. 2014. The maximum balanced subgraph of
a signed graph: Applications and solution approaches. European Journal of
Operational Research 236, 2 (2014), 473â€“487.
[20] Santo Fortunato. 2010. Community detection in graphs. Physics reports 486, 3-5
(2010), 75â€“174.
[21] N GÃ¼lpinar, G Gutin, G Mitra, and A Zverovitch. 2004. Extracting pure network
submatrices in linear programs using signed graphs. Discrete Applied Mathematics
137, 3 (2004), 359â€“372. https://doi.org/10.1016/S0166-218X(03)00361-5
[22] Frank Harary. 1953. On the notion of balance of a signed graph. Michigan
Mathematical Journal 2, 2 (1953), 143â€“146.
[23] Frank Harary. 1959. On the measurement of structural balance. Behavioral Science
4, 4 (1959), 316â€“323.
[24] Frank Harary and Jerald A Kabell. 1980. A simple algorithm to detect balance in
signed graphs. Mathematical Social Sciences 1, 1 (1980), 131â€“136.
[25] John Hopcroft and Robert Tarjan. 1973. Algorithm 447: Efficient Algorithms
for Graph Manipulation. Commun. ACM 16, 6 (jun 1973), 372â€“378. https:
//doi.org/10.1145/362248.362272
[26] Yaoping Hou, Jiongsheng Li, and Yongliang Pan. 2003. On the Laplacian eigen-
values of signed graphs. Linear and Multilinear Algebra 51, 1 (2003), 21â€“30.
[27] Yao Ping Hou. 2005. Bounds for the least Laplacian eigenvalue of a signed graph.
Acta Mathematica Sinica 21, 4 (2005), 955â€“960.
[28] Falk HÃ¼ffner, Nadja Betzler, and Rolf Niedermeier. 2007. Optimal edge dele-
tions for signed graph balancing. In International Workshop on Experimental and
Efficient Algorithms. Springer, 297â€“310.
[29] Falk HÃ¼ffner, Nadja Betzler, and Rolf Niedermeier. 2010. Separator-based data
reduction for signed graph balancing. Journal of combinatorial optimization 20
(2010), 335â€“360.
[30] Subhash Khot. 2002. On the power of unique 2-prover 1-round games. In Pro-
ceedings of the thiry-fourth annual ACM symposium on Theory of computing.
767â€“775.
[31] Tien T Nguyen, Pik-Mai Hui, F Maxwell Harper, Loren Terveen, and Joseph A
Konstan. 2014. Exploring the filter bubble: the effect of using recommender
systems on content diversity. In Proceedings of the 23rd international conference
on World wide web. 677â€“686.
[32] Jason Niu and A. Erdem SarÄ±yÃ¼ce. 2023. On Cohesively Polarized Communities
in Signed Networks. In Companion Proceedings of the ACM Web Conference 2023
(Austin, TX, USA) (WWW â€™23 Companion). Association for Computing Machinery,
New York, NY, USA, 1339â€“1347. https://doi.org/10.1145/3543873.3587698
[33] Bruno Ordozgoiti, Antonis Matakos, and Aristides Gionis. 2020. Finding large
balanced subgraphs in signed networks. In Proceedings of The Web Conference
2020. 1378â€“1388.
[34] Svatopluk Poljak and Daniel TurzÃ­k. 1986. A polynomial time heuristic for certain
subgraph optimization problems with guaranteed worst case bound. Discrete
Mathematics 58, 1 (1986), 99â€“104.
[35] Shiwen Wu, Fei Sun, Wentao Zhang, Xu Xie, and Bin Cui. 2022. Graph neural
networks in recommender systems: a survey. Comput. Surveys 55, 5 (2022), 1â€“37.
[36] Yichen Xu, Chenhao Ma, Yixiang Fang, and Zhifeng Bao. 2023. Efficient and
Effective Algorithms for Generalized Densest Subgraph Discovery. Proc. ACM
Manag. Data 1, 2, Article 169 (jun 2023), 27 pages. https://doi.org/10.1145/3589314
[37] Bo Yang, William Cheung, and Jiming Liu. 2007. Community mining from signed
social networks. IEEE transactions on knowledge and data engineering 19, 10
(2007), 1333â€“1348.
 
287