A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in
Large Sparse Graphs
Ahsanur Rahman
ahsanur.rahman@northsouth.edu
North South University
Dhaka, BangladeshKalyan Roy
kalyan.roy@northsouth.edu
North South University
Dhaka, Bangladesh
Ramiza Maliha
ramiza.maliha@northsouth.edu
North South University
Dhaka, BangladeshTownim Faisal Chowdhury
townim.chowdhury@adelaide.edu.au
Australian Institute for Machine Learning
University of Adelaide, Adelaide, Australia
Abstract
Pseudo-cliques (subgraphs with almost all possible edges) have
many applications. But they do not satisfy the convertible anti-
monotone constraint (as we prove here). So, it is hard to reduce
the search space of pseudo-cliques and list them efficiently. To our
knowledge, only two exact algorithms, namely, ODES and PCE,
were proposed for this purpose, but both have high execution times.
Here, we present an exact algorithm named Fast Pseudo-Clique Enu-
merator (FPCE). It employs some pruning techniques we derived to
reduce the search space. Our experiment on 15real and 16synthetic
graphs shows that (i) on real graphs, FPCE is, on average, 38.6and
6.5times faster than ODES and PCE, respectively, whereas (ii) on
synthetic graphs, FPCE is, on average, 39.7and3.1times faster
than ODES and PCE, respectively. We apply FPCE and a popular
heuristic method on a PPI network to identify pseudo-cliques. FPCE
outputs match with more known protein complexes, are more ac-
curate, and are biologically more significant â€“ suggesting that the
exact computation of pseudo-cliques may give better insights. For
its speed, FPCE is a suitable choice in such cases.
CCS Concepts
â€¢Mathematics of computing â†’Graph algorithms.
Keywords
graph clustering, pseudo-clique, quasi-clique, dense subgraph
ACM Reference Format:
Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowd-
hury. 2024. A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques
in Large Sparse Graphs. In Proceedings of the 30th ACM SIGKDD Con-
ference on Knowledge Discovery and Data Mining (KDD â€™24), August 25â€“
29, 2024, Barcelona, Spain. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3637528.3672066
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.36720661 Introduction
Graphs, a.k.a. networks, are often used to model real-world objects
and their mutual interactions. For example, social networks rep-
resent social relations among people; web graphs represent links
between web pages; protein-protein interaction (PPI) networks
describe mutual interactions among proteins; etc. Densely inter-
connected subgraphs of such networks are useful to identify social
communities from social networks [ 12], protein complexes from PPI
networks [ 15], link spams from web networks [ 37], etc. Different
research devised different formulations to define such subgraphs
and used different terms to indicate them. Unfortunately, the litera-
ture uses these terms inconsistently (Section 2). Here, we use the
term dense subgraph to indicate any definition of such a subgraph.
Motivation: Although a lot of research has been conducted
on dense subgraph mining [ 23], to our knowledge (as shown in
Section 2 and as noted by some others [ 30,46]), most of them either
(i) focus on heuristic algorithms â€“ which do not guarantee to find
all dense subgraphs correctly, or (ii) define dense subgraphs in ways
that allow them to develop fast exact algorithms for finding those.
To our knowledge, only two exact algorithms employ a natural
definition of dense subgraphs: a subgraph in which almost all possi-
ble edges are present (Figure 1). This definition of dense subgraphs
(henceforth called pseudo-cliques following [ 45]) is useful to iden-
tify protein complexes [ 28,33], co-regulated proteins [ 22], disease-
related circRNAs [ 50], Schizophrenia risk genes [ 25], COVID19
drugs [ 13], etc. In absence of efficient exact algorithms, these works
rely on heuristic algorithms to compute pseudo-cliques â€“ which
hinders them from judging the actual potential of pseudo-cliques in
these applications. Here, we address these issues by (i) developing
a fast, exact algorithm to list all maximal pseudo-cliques in a graph
and (ii) evaluating its performance and the quality of its outputs.
Contributions. We made the following contributions here.
(1)We prove that "pseudo-cliqueness" is not a convertible anti-
monotone property. So, algorithms available for mining pat-
terns with anti-monotone or convertible anti-monotone prop-
erty are not applicable to pseudo-cliques (Section 4).
(2)We derive some pruning techniques to prune the search-
space of pseudo-cliques (Sections 4 and 5, Appendix B).
(3)We integrate these techniques with an algorithm [ 45] to
design an exact algorithm for listing pseudo-cliques. We call
itFast Pseudo-Clique Enumerator orFPCE, in short (Section 5).
 
2479
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
(4)We derive a tighter (than that based on [ 45]) bound on the
time complexity of FPCE. Our analysis is much more detailed
and, so, is easier to understand (Section 5, Appendix C).
(5)Our experiment on 16 synthetic and 15 real graphs shows
that FPCE is always faster than its competitors (Section 8).
(6)Our ablation study shows that all pruning techniques of
FPCE are useful for its speedup (Section 9).
(7)We compare the quality of pseudo-cliques found by FPCE
from a PPI network with (i) those found by a popular heuris-
tic approach and (ii) degree-based quasi-cliques (another defi-
nition of dense subgraphs, see Section 2). FPCE outputs are
found to be more biologically interesting (Section 10).
Intuition: Our pruning Techniques are based on our observation
that each pseudo-clique has a certain maximum order, contains a
certainğ‘Ÿ-clique, and can be extended from a smaller pseudo-clique
only if its edge count and minimum degree are high enough. If any
of these conditions are violated, we stop growing the pseudo-clique.
Scope: We focus on sparse graphs only since no exact algorithm
can list pseudo-cliques from dense graphs efficiently (Section 8).
2 Related Work
Dealing with Inconsistent Terminology Usage in Literature:
Finding works that use our definition of pseudo-cliques is compli-
cated due to the discrepancy of terminology usage in the literature.
Some papers use the term quasi-clique [ 21,44], dense-subgraph [ 26], or
near-clique [ 8,43] to mean pseudo-cliques while some others use these
terms to mean some other definitions of dense subgraphs [ 18,32,37].
For example, different papers use quasi-clique to mean at least three
different notions: (i) a pseudo-clique [ 21,44], (ii) a subgraph induced
by a node-set ğ‘†in which each nodeâ€™s degree is at least ğ›¼(|ğ‘†|âˆ’1)
whereğ›¼is a user-given threshold [ 6,51] (we call it Degree-based
Quasi-clique, following [ 34,41]), and (iii) a subgraph whose average
degree is greater than a threshold [ 37] (we call it Average-degree-
based Quasi-clique ). So, to find all relevant papers, we searched
for literature mentioning any of these words and looked at papers
citing those works. However, a comprehensive review of all such
papers is beyond the scope of this paper (see [ 16,23] for this pur-
pose). Here, we only review algorithms to find pseudo-cliques â€“ no
matter what terms were used to denote them in the respective work.
We also discuss some other notable related work to highlight the
difference between our and their definitions of dense subgraphs.
Non-exact Algorithms: Abello et al. [ 1] designed a greedy
randomized adaptive search procedure (GRASP) to find maximal
pseudo-cliques in a graph. A greedy heuristic was proposed in [ 6] to
compute the largest degree-based quasi-clique. Two stochastic local
search algorithms were proposed in [ 9] to find maximal subgraphs
that satisfy requirements of both pseudo-cliques and degree-based
quasi-cliques. Another local search algorithm was described in [ 11]
to find the maximum pseudo-clique. Tsourakakis et al. [ 44] defined
an objective function that generalizes notions of both average-
degree-based quasi-cliques and pseudo-cliques as well as devised
two non-exact algorithms to find the subgraph achieving the highest
value of that function. A distributed algorithm was described in [ 8]
that can find a single pseudo-clique (having a theoretically proven
minimum density) in a graph with high probability. But it cannot
find pseudo-cliques with a given minimum density and minimum
order thresholds. Also, it is not exact and was never implemented.Exact Algorithms for Finding the Maximum Pseudo-clique:
The first exact algorithm to find the largest pseudo-clique in an
input graph was proposed by Pattillo et al. [ 35]. They designed two
mixed integer programming (MIP) formulations to solve this prob-
lem. Four alternative MIP formulations for the same problem were
proposed in [ 46]. It was also solved by Pajouh et al. [ 29] via a DFS-
based branch-and-bound algorithm. Finally, Marinelli et al. [ 30]
solved it via a branch-and-price algorithm.
Exact Algorithms for Other Related Problems: A fixed-
parameter algorithm was proposed in [ 20] to find the densest sub-
graph withğ‘˜nodes. A flow-based algorithm was proposed in [ 14]
to find the largest subgraph with the highest average degree. A
DFS-based exact algorithm, called Quick, was proposed in [ 24]
that lists all maximal degree-based quasi-cliques in a graph. Ko-
musiewicz et al. [ 21] designed a DFS-based branch-and-bound al-
gorithm to find a single pseudo-clique of order ğ‘˜(a user input).
While these are important problems, algorithms to solve them
cannot be easily adapted to efficiently find all the maximal pseudo-
cliques in a graph â€” which is the goal of our work.
Exact Algorithms for Finding All Maximal Pseudo-cliques:
We found only two exact algorithms for solving this problem for a
graph: Overlapping dense subgraph (ODES) [ 26] and Pseudo Clique
Enumerator (PCE) [ 45]. ODES is a BFS-like search algorithm that
maintains a queue of all the order- ğ‘˜pseudo-cliques found so far and
tries to grow each of these pseudo-cliques in the next iteration to
find all the order-(ğ‘˜+1)pseudo-cliques. ODES continues growing
each pseudo-clique in the queue as long as it satisfies the minimum-
density constraint. To maintain such a large queue, ODES needs a
huge memory. PCE, on the other hand, is a reverse-search [ 3] based
(DFS-like) recursive method that continues growing the current
pseudo-clique as long as the minimum-density constraint is satisfied
and reports it when it becomes a maximal pseudo-clique.
3 Notations and Definitions
Table 1 lists our notations. We formally define pseudo-clique below.
Definition 1. ğœƒ-Pseudo-Clique: For a given threshold ğœƒwith
0â‰¤ğœƒâ‰¤1, a node-set ğ‘ƒwith|ğ‘ƒ|â‰¥2is called ağœƒ-pseudo-clique if its
density,ğ‘‘ğ‘’ğ‘›(ğ‘ƒ)â‰¥ğœƒ.
Usually, we are interested in large pseudo-cliques. The following
definitions allow us to incorporate these requirements.
Definition 2.(â„“,ğœƒ)-Pseudo-Clique: Letğœƒandâ„“be two given
thresholds where 0â‰¤ğœƒâ‰¤1andâ„“â‰¥2. Thenğ‘ƒis called a(â„“,ğœƒ)-
pseudo-clique if ğ‘‘ğ‘’ğ‘›(ğ‘ƒ)â‰¥ğœƒand|ğ‘ƒ|â‰¥â„“.
Definition 3. Maximal(â„“,ğœƒ)-Pseudo-Clique: ğ‘ƒis called a
maximal(â„“,ğœƒ)-pseudo-clique if ğ‘ƒis a(â„“,ğœƒ)-pseudo-clique and there
is no(â„“,ğœƒ)-pseudo-clique ğ‘„, such thatğ‘ƒâŠ‚ğ‘„.
We aim to design a fast algorithm to solve the problem below.
Problem: Enumerate all maximal (â„“,ğœƒ)-pseudo-cliques in a sparse
graph for a given density threshold ğœƒand order threshold â„“.
Basic Algorithm: Explore all subgraphs in a given graph and
report the ones that are maximal (â„“,ğœƒ)-pseudo-cliques.
To systematically enumerate these subgraphs without visiting
the same subgraph twice, we want to represent each subgraph by a
unique order of its vertices. We define two such orderings below.
 
2480A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Table 1: Notations
Symbol Meaning/Definition
ğº Undirected graph with vertex set ğ‘‰and edge set ğ¸
ğº[ğ‘ƒ] Subgraph induced by the set of vertices ğ‘ƒâŠ†ğ‘‰
ğ¸[ğ‘ƒ] Set of edges in ğº[ğ‘ƒ]
ğ¾ğ‘Ÿ Anğ‘Ÿ-clique
ğ‘‘(ğ‘£) Degree of vertex ğ‘£in the whole graph ğº
ğ‘‘ğ‘ƒ(ğ‘£) Degree of vertex ğ‘£inğº[ğ‘ƒ]
ğ‘‘ğ‘ğ‘£(ğ‘ƒ)Average vertex-degree of ğº[ğ‘ƒ]=2|ğ¸[ğ‘ƒ]|/|ğ‘ƒ|
ğ›¿(ğ‘ƒ) Minimum degree of ğº[ğ‘ƒ]=ğ‘šğ‘–ğ‘›{ğ‘‘ğ‘ƒ(ğ‘£):ğ‘£âˆˆğ‘ƒ}
ğ‘(ğ‘£) Set of all neighbors of ğ‘£inğº
ğ¶ğ‘˜(ğº)ğ‘˜-core of graph ğº=ğ‘ğ‘Ÿğ‘”ğ‘šğ‘ğ‘¥ğ‘ƒâŠ†ğ‘‰{|ğ‘ƒ|:ğ›¿(ğ‘ƒ)â‰¥ğ‘˜}
ğ¶ğ‘˜(ğ‘ƒ)ğ‘˜-core of subgraph ğº[ğ‘ƒ]
ğ‘(ğ‘£) Coreness of vertex ğ‘£inğº=ğ‘šğ‘ğ‘¥{ğ‘˜:ğ‘£âˆˆğ¶ğ‘˜(ğº)}
ğ‘ğ‘ƒ(ğ‘£) Coreness of vertex ğ‘£inğº[ğ‘ƒ]
ğ‘(ğ‘ƒ) Coreness of vertex set ğ‘ƒ=ğ‘šğ‘ğ‘¥{ğ‘˜:ğ‘ƒâŠ†ğ¶ğ‘˜(ğº)}
ğœ‰ğº Degeneracy of ğº=ğ‘šğ‘ğ‘¥ğ‘£âˆˆğ‘‰{ğ‘(ğ‘£)}=ğ‘šğ‘ğ‘¥ğ»âŠ†ğ‘‰{ğ›¿(ğ»)}
ğœ‰ğ‘† Degeneracy of subgraph ğº[ğ‘†]
ğ‘‘ğ‘’ğ‘›(ğ‘ƒ)Density of subgraph ğ‘ƒ=ğ¸[ğ‘ƒ]/ |ğ‘ƒ|
2
Definition 4. Degree Ordering: The degree ordering â‰»of a sub-
graphğº[ğ‘ƒ]is a total order of nodes in ğ‘ƒs.t.ğ‘¢â‰»ğ‘£â‡”(ğ‘‘ğ‘ƒ(ğ‘¢)>ğ‘‘ğ‘ƒ(ğ‘£))
âˆ¨((ğ‘‘ğ‘ƒ(ğ‘¢)=ğ‘‘ğ‘ƒ(ğ‘£))âˆ§(ğ‘¢>ğ‘£)).
For a node-set ğ‘ƒ, we useğ‘ƒâ‰»to denote an ordered tuple of nodes in
ğ‘ƒordered by a given ordering â‰». For example, consider the subgraph
ğº[ğ‘ƒ]induced byğ‘ƒ={1,2,3,4,5}in graphğºof Figure 1. Assuming
â‰»denotes the degree ordering of ğº,ğ‘ƒâ‰»=<5,4,3,1,2>. However,
whenâ‰»represents the degree ordering of ğº[ğ‘ƒ],ğ‘ƒâ‰»=<4,3,2,1,5>.
We useğ‘£âˆ—(ğ‘ƒ)to denote the last element in degree ordering of
ğº[ğ‘ƒ],i.e.,for allğ‘¤âˆˆ(ğ‘‰[ğ‘ƒ]âˆ’{ğ‘£âˆ—(ğ‘ƒ)}),ğ‘¤â‰»ğ‘£âˆ—(ğ‘ƒ). Hereğ‘£âˆ—(ğ‘ƒ)=5.
Definition 5. MD Ordering: The MD ordering, a.k.a. reverse de-
generacy ordering of a subgraph ğº[ğ‘ƒ]for a node-set ğ‘ƒ={ğ‘£1,ğ‘£2,...,ğ‘£ğ‘›}
is a total order ğ‘ƒâ‰»=<ğ‘£1,ğ‘£2,...,ğ‘£ğ‘›>s.t.âˆ€ğ‘£ğ‘–âˆˆğ‘ƒ:ğ‘£ğ‘–=ğ‘£âˆ—(ğ‘ƒğ‘–)where
ğ‘ƒğ‘–=<ğ‘£1,ğ‘£2,...,ğ‘£ğ‘–>is theğ‘–-length prefix of ğ‘ƒâ‰».
For example, ifâ‰»denotes the MD ordering of ğº,ğ‘ƒâ‰»=<5,4,3,2,1>
but ifâ‰»denotes the MD ordering of ğº[ğ‘ƒ],ğ‘ƒâ‰»=<4,3,2,1,5>.
MD ordering sorts the vertices in descending order of their core-
nesses , a.k.a. core numbers [ 47] where coreness of a vertex is the
maximum core it belongs to (see Table 1 and Figure 1).
01011 1
3 42 9
56781-core
3-core
4-core
Figure 1: A toy graph. Here both ğ‘†1={1,2,3,4}andğ‘†2=
{1,2,3,4,5}are(0.7,4)-pseudo-cliques. ğ‘†2is a maximal(0.7,4)-
pseudo-clique but ğ‘†1is not. Coreness of each green node is
one, whereas coreness of each blue (red) node is three (four).Our algorithm explores subgraphs in MD ordering. To avoid
exploring non-pseudo-cliques, it exploits the following constraint.
Definition 6. Loosely Anti-monotone (LAM) Constraint: Let
an itemset (which is a node-set in our case) ğ‘†satisfy a constraint ğ‘.
Thenğ‘is called a loosely anti-monotone [ 7] or a quasi-hereditary con-
straint [29] if at least one subset of ğ‘†also satisfies ğ‘.
Everyğœƒ-pseudo-clique contains at least one ğœƒ-pseudo-clique as
a subset, i.e., ğœƒ-pseudo-cliques satisfy the LAM constraint [29]. It
implies that if no subset of ğ‘ƒis ağœƒ-pseudo-clique then ğ‘ƒis not
ağœƒ-pseudo-clique. Thus, this constraint helps reduce the search
space ofğœƒ-pseudo-cliques, as we only need to grow a subgraph as
long as it remains a ğœƒ-pseudo-clique. However, it is less effective
for search space reduction than the famous anti-monotone [ 7] or
convertible anti-monotone [36] constraints defined below.
Definition 7. Anti-monotone (AM) Constraint: Let an itemset
ğ‘†satisfy a constraint ğ‘. Thenğ‘is called a hereditary [ 29] or an anti-
monotone [36] constraint if each subset of ğ‘†also satisfies ğ‘.
Definition 8. Convertible Anti-monotone (CAM) Constraint:
Let a total orderâ‰»be defined over all the items in the universal set
(in our case, ğ‘‰). So the items in any itemset ğ‘†can be represented as
an ordered tuple, ğ‘†â‰»=<ğ‘¥1,ğ‘¥2,...,ğ‘¥|ğ‘†|>. Letğ‘†satisfy a constraint
ğ‘. Thenğ‘is called a convertible anti-monotone constraint [ 36] with
respect to the order â‰»if every prefix of ğ‘†â‰»also satisfies ğ‘.
For example, cliques satisfy anti-monotone constraint because
every subset of a clique is also a clique. On the other hand, average-
degree-based pseudo-cliques satisfy convertible anti-monotone con-
straint with respect to the degree ordering ( â‰») ofğºbecause for every
prefixğ‘ƒof any node-set ğ‘†âŠ†ğ‘‰it holds that ğ‘‘ğ‘ğ‘£(ğ‘ƒ)â‰¥ğ‘‘ğ‘ğ‘£(ğ‘†)[36].
4 Properties of Pseudo-cliques
In this section, we first show that pseudo-cliques may not satisfy
the convertible anti-monotone constraint â€“ which explains why
search-space reduction for pseudo-cliques is not as easy as that
for average-degree-based quasi-cliques. Next, we establish some
properties of pseudo-cliques, which we utilize later to prune the
search space of pseudo-cliques in our algorithm (Section 5).
Lemma 1. There exists no ordering of all vertices for which ğœƒ-
pseudo-cliques satisfy the convertible anti-monotone constraint.
Proof. Let there be a node-ordering â‰»for whichğœƒ-pseudo-
clique satisfies the convertible anti-monotone constraint. Take
the graph of Figure 1 after deleting 9. Consider two 0.7-pseudo-
cliques in that graph: ğ‘ƒ={1,2,3,4,5}andğ‘„={4,5,6,7,8}. Ac-
cording to the convertible anti-monotone constraint, every prefix
ofğ‘ƒâ‰»(respectively, ğ‘„â‰») must be a 0.7-pseudo-clique. But the only
subset ofğ‘ƒ(resp.,ğ‘„) having|ğ‘ƒ|âˆ’1(resp.,|ğ‘„|âˆ’1) nodes which
is also a 0.7-pseudo-clique is: ğ‘ƒâ€²=ğ‘ƒâˆ’{5}(resp.,ğ‘„â€²=ğ‘„âˆ’{4}).
Soğ‘ƒâ€²
â‰»(resp.,ğ‘„â€²
â‰») must be a prefix of ğ‘ƒâ‰»(resp.,ğ‘„â‰»). So 4(resp., 5)
must precede 5(resp, 4) in the ordering ğ‘ƒâ‰»(resp.,ğ‘„â‰»)i.e.,the order
of nodes 4 and 5 differs between ğ‘ƒâ‰»andğ‘„â‰»(contradiction).â–¡
This lemma shows that no algorithm can compute maximal (â„“,ğœƒ)-
pseudo-cliques by iterating over any global ordering of vertices
(unlike cliques or average-degree-based quasi-cliques). So we rely
on the following idea to solve our problem.
 
2481KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
Idea 1. To find all maximal (â„“,ğœƒ)-pseudo-cliques in ğº, extend
the current subgraph (initially, an empty graph) of ğºby adding one
vertex with the current subgraph at a time (Figure 2) in MD ordering
as long as the current subgraph remains a ğœƒ-pseudo-clique and finally,
report it when it becomes a maximal (â„“,ğœƒ)-pseudo-clique.
Since there are ğ‘‚(2|ğ‘‰|)subgraphs of a graph ğº=(ğ‘‰,ğ¸), the
search space of our algorithm is exponential. Below, we put forth
some properties of pseudo-cliques that may help us to prune our
search space. To save space, we provide all proofs in Appendix B.
The following two lemmas give two different bounds on the
maximum possible order of a (â„“,ğœƒ)-pseudo-clique â€“ which are then
used to establish our Pruning Technique 1 stated below.
Lemma 2. Ifğ‘†is a(â„“,ğœƒ)-pseudo-clique then ğœ‰ğ‘†â‰¥âŒˆğœƒ|ğ‘†|/2âŒ‰
Corollary 1. Ifğ‘†is ağœƒ-pseudo-clique then |ğ‘†|â‰¤âŒŠ2ğœ‰ğº/ğœƒâŒ‹
Lemma 3. Ifğ‘†is ağœƒ-pseudo-clique, the largest clique in ğº[ğ‘†]is of
orderğœ”, andğœƒ>(ğœ”âˆ’1)/ğœ”then|ğ‘†|â‰¤j
1
1âˆ’(ğœ”âˆ’1)/ğœ”ğœƒk
Corollary 2. Ifğ‘†is ağœƒ-pseudo-clique with ğœƒ>ğœ‰ğº/(ğœ‰ğº+1)then
|ğ‘†|â‰¤1
1âˆ’ğœ‰ğº/(ğœ‰ğº+1)ğœƒ
Pruning Techniqe 1 (Order Bound). No(â„“,ğœƒ)-pseudo-clique ex-
ists ifâ„“>ğœ‡whereğœ‡is the minimum of the two upper-bounds (on the
order of a(â„“,ğœƒ)-pseudo-clique) mentioned in Corollaries 1 and 2.
We also realize that each (â„“,ğœƒ)-pseudo-clique must contain a
certainğ‘Ÿ-clique (Theorem 1) and such cliques must be contained
within a certain ğ‘Ÿâ€²-core of the input graph (Lemma 4). These results
are then exploited in our Pruning Technique 2 stated below.
Theorem 1. Ağœƒ-pseudo-clique ğ‘†withâ„“vertices must contain an
ğ‘Ÿ-cliqueğ¾whereğ‘Ÿ=âŒˆ1/(1âˆ’ğœƒ(â„“âˆ’1)/â„“)âŒ‰.
Lemma 4. Ifğºcontains ağ‘¡-cliqueğ¾, thenğ¾âŠ†ğ¶ğ‘¡â€²[ğº]where
ğ‘¡â€²=ğ‘šğ‘–ğ‘›{ğ‘˜:ğ‘˜â‰¥ğ‘¡âˆ’1ğ‘ğ‘›ğ‘‘|ğ¶ğ‘˜|>0}.
Idea 2. Allğ‘Ÿ-cliques inğºcan be computed by enumerating all
(ğ‘Ÿ,1)-pseudo-cliques in ğº[ğ¶ğ‘Ÿâ€²]via Idea 1.
Pruning Techniqe 2 (Turan Filtering). Find allğ‘Ÿ-cliques in
ğºvia Idea 2 and extend them to get all maximal (â„“,ğœƒ)-pseudo-cliques.
5 Method
Our algorithm is a modified version of the PCE algorithm [ 45],
which we briefly introduce below for the readerâ€™s convenience.
PCE Algorithm: PCE recursively grows ğœƒ-pseudo-cliques. The
following holds for the corresponding recursion tree [45].
Property 1. ğ‘„=ğ‘ƒâˆª{ğ‘¢}is a child of a ğœƒ-pseudo-clique ğ‘ƒif and
only if (i)ğ‘„is ağœƒ-pseudo-clique and (ii) ğ‘¢=ğ‘£âˆ—(ğ‘„).
From this, we have derived the following corollary.
Corollary 3. A node-setğ‘„=ğ‘ƒâˆª{ğ‘¢}is a child of a ğœƒ-pseudo-
cliqueğ‘ƒif and only if (i) ğ‘„is ağœƒ-pseudo-clique and (ii) ğ‘ƒâ‰»is a prefix
ofğ‘„â‰»whereâ‰»is the MD ordering of ğ‘„.
It implies that PCE explores pseudo-cliques using Idea 1. Note
thatğ‘„has only one parent ( ğ‘„âˆ’{ğ‘£âˆ—(ğ‘„)}) sinceğ‘£âˆ—(ğ‘„)is unique for
ğ‘„. This property ensures the tree structure of the search-space ofPCE. PCE traverses this tree (a.k.a., reverse search tree [3]) in a DFS
manner to visit all ğœƒ-pseudo-cliques. It starts from each vertex and
continues growing the current ğœƒ-pseudo-clique ğ‘ƒuntil a maximal
ğœƒ-pseudo-clique is found (Figure 2). ğ‘ƒâˆª{ğ‘¢}becomes a child of
ğ‘ƒif it satisfies the conditions of Property 1. These conditions are
equivalent to the following three conditions [45].
Lemma 5. Ifğ‘ƒis ağœƒ-pseudo-clique and node ğ‘¢âˆ‰ğ‘ƒthenğ‘ƒâˆª
{ğ‘¢}is a child of ğ‘ƒif and only if the following conditions hold: (i)
ğ‘‘ğ‘ƒ(ğ‘¢)â‰¥ğœƒ |ğ‘ƒ|+1
2âˆ’ğ¸[ğ‘ƒ], (ii)(ğ‘‘ğ‘ƒ(ğ‘¢),ğ‘¢)<(ğ›¿(ğ‘ƒ)+1,ğ‘£âˆ—(ğ‘ƒ))), (iii)
ğ‘£â‰ºğ‘¢â‡’ğ‘£âˆˆğ‘(ğ‘¢)âˆ€ğ‘£âˆˆğ‘ƒwhereâ‰»is the degree ordering of ğº[ğ‘ƒ].
Corollary 4. Ifğ‘ƒ,ğ‘ƒâˆª{ğ‘¢}areğœƒ-pseudo-cliques and ğ‘ƒâˆª{ğ‘¢}is a
child ofğ‘ƒthenğœƒ |ğ‘ƒ|+1
2âˆ’ğ¸[ğ‘ƒ]â‰¤ğ›¿(ğ‘ƒ)+1
Our Algorithm: Our approach, namely FPCE, is a significant
modification of the PCE algorithm. Specifically, we added some
pruning techniques with PCE to reduce its search space. We dis-
cussed all but one of these techniques in Section 4. The last one is
based on the following lemmas (see proofs in Appendix B).
Lemma 6. Ifğ‘†,ğ‘ƒareğœƒ-pseudo-cliques such that |ğ‘†|=â„“andğ‘†is a
descendant of ğ‘ƒthenğœƒ â„“
2â‰¤ğ¸[ğ‘ƒ]+(â„“âˆ’|ğ‘ƒ|)(ğ›¿(ğ‘ƒ)+(â„“âˆ’|ğ‘ƒ|+1)/2).
Lemma 7. Letğ‘ƒ,ğ‘†areğœƒ-pseudo-cliques,|ğ‘†|=â„“,ğœğ‘ƒ=ğ›¿(ğ‘ƒ)+1
2,
ğœ‚(ğ‘ƒ)=ğ‘šğ‘–ğ‘›{ğ‘(ğ‘ƒ),ğ›¿(ğ‘ƒ)+â„“âˆ’|ğ‘ƒ|}, andğ‘ƒis an ancestor of ğ‘†in the
reverse search tree, then
ğœƒâ„“
2
â‰¤(
ğ¸[ğ‘ƒ]+(â„“âˆ’|ğ‘ƒ|)ğ›¿(ğ‘ƒ), ifğ‘(ğ‘ƒ)=ğ›¿(ğ‘ƒ)
ğ¸[ğ‘ƒ]+(â„“âˆ’ğ‘ƒ+ğœğ‘ƒ)ğœ‚(ğ‘ƒ)âˆ’(ğ›¿(ğ‘ƒ)+1)ğœğ‘ƒ,otherwise
Pruning Techniqe 3 (Edge Bound). If ağœƒ-pseudo-clique ğ‘ƒ
does not satisfy the inequalities in Lemma 6 or Lemma 7 then it
cannot be extended to obtain a ğœƒ-pseudo-clique of order â„“.
Algorithm 1 illustrates our overall idea. To compute core num-
bers of nodes in the input graph ğº, we implement an O(E) time
algorithm [ 5] (line 1) that iteratively deletes the first node from a
sorted (in ascending order of degrees) list ğ¿of nodes. Whenever
a node is deleted, its core number is set to its current degree, its
neighborsâ€™ degrees are updated, and they are re-positioned in ğ¿to
maintain their degree-wise ordering. We use these core numbers to
apply the Order Bound (lines 2 â€“ 4) and to compute ğ¶ğ‘Ÿâ€²[ğº](line 6).
We call a recursive method named recur on each node of ğ¶ğ‘Ÿâ€²[ğº]. It
takes a pseudo-clique ğ‘ƒand either (i) outputs ğ‘ƒ(if it is a maximal
pseudo-clique) or (ii) extends ğ‘ƒto get each child ğ‘„=ğ‘ƒâˆª{ğ‘¢}of
ğ‘ƒ(otherwise) â€“ where ğ‘„is either a clique (when |ğ‘ƒ|<ğ‘Ÿ; lines 12
â€“ 14) or a pseudo-clique (when |ğ‘ƒ|â‰¥ğ‘Ÿ; line 20). In case (ii), recur
calls itself on each child ğ‘„(lines 21 â€“ 23).
We design an algorithm called getChildrenClq to generate each
cliqueğ‘ƒâˆª{ğ‘¢}from a clique ğ‘ƒ. It relies on the following property.
Property 2. ğ‘ƒâˆª{ğ‘¢}is a clique having at least two nodes ğ‘¢,ğ‘£if
and only ifğ‘ƒis a clique,ğ‘¢âˆˆğ‘(ğ‘£), andğ‘ƒâˆ’{ğ‘£}âˆª{ğ‘¢}is a clique.
This property allows us to exploit the already known child-
cliques ofğ‘ƒâˆ’{ğ‘£}in a reverse-search tree. We use a compressed
bitset [ 10] to storeğ‘(ğ‘£)for each node ğ‘£, which lets us check con-
ditions in this Property in ğ‘‚(ğ‘™ğ‘”Î”)time to find each child of ğ‘ƒ.
We rely on the getChildrenPseudoClq method of PCE (line 20) to
generate children of the current pseudo-clique ğ‘ƒ. Briefly, it returns
nodes satisfying all conditions of Lemma 5.
 
2482A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
{ }
{0}{1} {2} {3} {4} {5}
{0,1} {0,2} {0,3} {0,4}{3,5}
{0,2,6} {0,2,7}
{0,2,6,7}{6}
{0,6}{2,6}{7}
{0,7}{2,7}{8}
{7,8}{9}
{7,9}{10}
{6,10}{11}
{10,11}{12}
{6,12}9 7 2 6 10
11 12 0 8
1 3 4
5  Pruned by Edge Bound
  Pruned by Turan FilteringTraversed by both PCE and FPCE
Figure 2: A graph (left) and the reverse search tree (right) traversed by PCE and FPCE to search (in vain) for all maximal
(5,0.8)-pseudo-cliques in it. This figure shows that FPCE significantly reduces the search space of PCE even for this small graph.
Figure 2 shows a reverse-search tree depicting recur calls on 0.8-
pseudo-cliques to search for maximal (5,0.8)-pseudo-cliques in a
graph. Here ğ‘Ÿ=3, so FPCE only searches for 3-cliques in the 2-core
({0,2,6,7}) of this graph, thereby pruning nodes outside that core
(Turan Filtering). It also detects that no child of {0,2,6}or{0,2,7}
can exist and thereby saves time by skipping getChildrenPseudoClq
calls on the corresponding tree-nodes (Edge Bound).
Time Complexity: We put a detailed time complexity analysis
in Appendix C. Briefly, FPCE time mainly depends on the time
taken by recur calls. The bottleneck of recur isgetChildrenPseudoClq,
which takes ğ‘‚(Î”ğ‘™ğ‘”ğ‘‰+ğ‘šğ‘–ğ‘›{Î”2,ğ‘‰+ğ¸})time, as per [ 45]. We exploit
properties of pseudo-cliques to derive a tighter time complexity of
ğ‘‚(Î”(ğ‘™ğ‘”ğ‘‰+ğœ‰ğº))for it. This is also the running time of recur. Since
recur is called once for each pseudo-clique, the time complexity of
FPCE isğ‘‚(2|ğ‘‰|Î”(ğ‘™ğ‘”ğ‘‰+ğœ‰ğº)), but typically it takes much less time.
Time Reduction: Although, time complexity of FPCE is the
same as PCE, FPCE often prunes many branches of the reverse-
search tree. If it prunes ğ‘˜branches or detects ğ‘˜nodes to be leaves
(for e.g. in Figure 2, Edge Bound detects {0,2,6}to be a leaf), it
savesğ‘‚(ğ‘˜Î”(ğ‘™ğ‘”ğ‘‰+ğœ‰ğº))time. When|ğ‘ƒ|â‰¤ğ‘Ÿ, it saves time by calling
getChildrenClq instead of slower getChildrenPseudoClq. When Order
Bound holds, it prunes the entire search space. So, FPCE should be
faster than PCE â€“ which is evident from our results, too (Section 8).
6 Datasets
Synthetic Datasets: We used Python Networkx library to create
two types of undirected graphs: (i) Scale-free (SF) graphs and (ii)
Small-world (SW) graphs because real graphs tend to have these
types of structures [48]. To generate SF graphs, we used a slightly
modified version of BarabÃ¡siâ€“Albert (BA) preferential attachment
model [ 4] with parameters(ğ‘›,ğ‘š). Starting with an initial graph (by
default, a star graph of ğ‘š+1nodes), it incrementally adds new nodes
one by one. A new node ğ‘¢is connected with ğ‘˜pre-existing nodes
in such a way that the probability of a pre-existing node ğ‘£being
a neighbor of ğ‘¢is proportional to ğ‘‘(ğ‘£). In the BA model, ğ‘˜=ğ‘š,
making it prone to generate graphs with an unrealistically high
minimum degree. To fix this issue, we modified the BA model so
that it chooses ğ‘˜uniformly at random from [1,ğ‘š]in each iteration.Input: Graphğº, minimum order â„“, minimum density ğœƒ
Output: All maximal(â„“,ğœƒ)-pseudo-cliques in ğº
1ğ‘= getCoreNumbers( ğº) //array of core numbers
2ğœ‰=ğ‘šğ‘ğ‘¥(ğ‘)//computeğœ‰ğº
3ğœ‡=ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿğµğ‘œğ‘¢ğ‘›ğ‘‘(ğœƒ,ğœ‰)
4ifâ„“>ğœ‡then return //Pruning Tech. 1
5ğ‘Ÿ=âŒˆ1/(1âˆ’ğœƒ(â„“âˆ’1)/â„“)âŒ‰
6ğ¶ğ‘Ÿâ€²=ğ‘”ğ‘’ğ‘¡ğ¶ğ‘œğ‘Ÿğ‘’(ğº,ğ‘,ğ‘Ÿ)
7forallğ‘£âˆˆğ¶ğ‘Ÿâ€²do
8ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘Ÿ(ğº,âˆ,{ğ‘£},ğ‘£,{})
9
10Procedure recur (ğº,ğ‘ğ‘,ğ‘ƒ,ğ‘£,ğ´ )
11ğ‘ğ‘=ğ‘šğ‘–ğ‘›(ğ‘ğ‘,ğ‘[ğ‘£])//compute c(P)
12 if|ğ‘ƒ|<ğ‘Ÿthen
13ğ·=ğ‘”ğ‘’ğ‘¡ğ¶â„ğ‘–ğ‘™ğ‘‘ğ‘Ÿğ‘’ğ‘›ğ¶ğ‘™ğ‘(ğº,ğ‘ƒ,ğ‘£,ğ´)
14 Go to line 21 //Pruning Tech. 2
15 ifğ‘ƒis a maximal(â„“,ğœƒ)-pseudo-clique then
16 outputğ‘ƒ
17 return
18 ifğ‘’ğ‘‘ğ‘”ğ‘’ğµğ‘œğ‘¢ğ‘›ğ‘‘(â„“,ğ‘ğ‘,ğ‘ƒ)then return //Pruning Tech. 3
19 ifğœƒ |ğ‘ƒ|+1
2âˆ’ğ¸[ğ‘ƒ]>ğ›¿(ğ‘ƒ)+1then return //Corollary 4
20ğ·=ğ‘”ğ‘’ğ‘¡ğ¶â„ğ‘–ğ‘™ğ‘‘ğ‘Ÿğ‘’ğ‘›ğ‘ƒğ‘ ğ‘’ğ‘¢ğ‘‘ğ‘œğ¶ğ‘™ğ‘ (ğº,ğ‘ƒ,ğ‘£)
21 forallğ‘¢âˆˆğ·do
22ğ‘„=ğ‘ƒâˆª{ğ‘¢}
23ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘Ÿ(ğº,ğ‘ğ‘,ğ‘„,ğ‘¢,ğ· )
24
25Procedure getChildrenClq (ğº,ğ‘ƒ,ğ‘£,ğ´ )
26 if|ğ‘ƒ|=1then return{ğ‘¢:ğ‘¢<ğ‘£ğ‘ğ‘›ğ‘‘ğ‘¢âˆˆğ‘(ğ‘£)}
27 else returnâˆªğ‘¢âˆˆğ´{ğ‘¢:ğ‘¢<ğ‘£ğ‘ğ‘›ğ‘‘ğ‘¢âˆˆğ‘(ğ‘£)}
Algorithm 1: FPCE(ğº,â„“,ğœƒ ) algorithm.
To generate SW graphs, we used Wattsâ€“Strogatz (WS) (ğ‘›,ğ‘š,ğ‘)
model [ 49]. Starting with a cycle graph of ğ‘›nodes, it connects each
node with its ğ‘šnearest neighbors to form a ring lattice. Then with
probabilityğ‘, it replaces each edge (ğ‘¢,ğ‘£)in that lattice with another
edge(ğ‘¢,ğ‘¤)whereğ‘¤is chosen uniformly at random from all nodes
while avoiding the creation of any self-loop/multi-edge.
 
2483KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
We created eight instances of each of these two types of graphs
by varying parameter ğ‘šin{5,10,15,..., 40}. We usedğ‘›=100,000
to get sufficiently large graphs. For the WS model, we chose ğ‘=0.2.
Table 2: Properties of synthetic graphs.
Scale Free (SF) Graphs Small World (SW) Graphs
ğ‘š|ğ¸|ğ‘‘ğ‘’ğ‘›(ğº)ğœ‰ğº|ğ¸|ğ‘‘ğ‘’ğ‘›(ğº)ğœ‰ğº
5 299,799 5.99e-5 5 200,000 4.00e-5 3
10 550,036 1.10e-4 8 500,000 1.00e-4 7
15 798,375 1.59e-4 11 700,000 1.40e-4 10
20 1,046,002 2.09e-4 15 1,000,000 2.00e-4 15
25 1,300,746 2.60e-4 18 1,200,000 2.40e-4 18
30 1,549,292 3.09e-4 22 1,500,000 3.00e-4 24
35 1,802,411 3.60e-4 25 1,700,000 3.40e-4 28
40 2,047,534 4.09e-4 28 2,000,000 4.00e-4 33
Real Datasets: We collected 18real graphs from [ 40] and re-
moved self-loops and multi-edges from them. Last 3of them are
dense and the rest are sparse (Table 3). We mostly considered sparse
graphs since organically formed networks tend to be sparse [48].
Table 3: Features of real graphs. Starred ones are dense.
IDGraph(ğº)Name |ğ‘½| |ğ‘¬| ğ’…ğ’†ğ’(ğ‘®)ğƒğ‘®
1 bio-grid-human 9,436 31,181 7.00eâˆ’412
2 web-webbase-2001 16,062 25,592 1.98eâˆ’432
3 scc_retweet-crawl 17,151 24,014 1.63eâˆ’419
4 soc-gplus 23,628 39,193 1.40eâˆ’412
5 dictionary28 39,327 89,037 1.15eâˆ’425
6 tech-internet-as 40,164 85,122 1.05eâˆ’423
7 PROTEINS-full 43,466 81,043 8.57eâˆ’54
8 soc-douban 154,908 327,161 2.72eâˆ’515
9 citationCiteseer 268,495 1,156,646 3.20eâˆ’515
10 ca-MathSciNet 332,689 820,643 1.48eâˆ’524
11 com-amazon 334,863 925,871 1.65eâˆ’56
12 TWITTER-Partial 580,768 717,557 4.25eâˆ’69
13 delaunay_n23 8,388,608 25,165,783 7.15eâˆ’74
14 inf-europe_osm 50,912,018 54,054,659 4.17eâˆ’83
15 socfb-konect 59,216,215 92,522,017 5.27eâˆ’816
16 bn-mouse-brain* 213 16,242 7.19eâˆ’1112
17 school-proximity* 242 8,317 2.85eâˆ’147
18 p-hat700-3* 700 183,010 7.48eâˆ’1426
7 Experiments
Investigation: We compare the performance of FPCE with two
exact algorithms: PCE and ODES. These algorithms were imple-
mented in C/CPP â€“ just like our FPCE code. ODES computes con-
nected pseudo-cliques only. So, to fairly compare all algorithms,
we modified PCE and FPCE codes so that they only compute con-
nected pseudo-cliques. We achieved this goal by noting that, for
connected pseudo-cliques, condition (i) of Lemma 5 for ğ‘ƒâˆª{ğ‘£}be-
ing a child of ğ‘ƒbecomes:ğ‘‘ğ‘ƒ(ğ‘£)â‰¥ğ‘šğ‘ğ‘¥
ğœƒ |ğ‘ƒ|+1
2âˆ’ğ¸[ğ‘ƒ],1
while
the other two conditions remain the same. We downloaded the PCE
code from https://research.nii.ac.jp/~uno/codes.htm and collected a
single-threaded implementation of ODES from [ 38]. To show the
effectiveness of our algorithm for finding large dense subgraphs,
we executed each algorithm with parameters: â„“=10,ğœƒ=0.9.Evaluation: We define following performance metrics for FPCE.
(i) Speedup w.r.t. algorithm ğ´=Execution Time of A
Execution Time of FPCE
(ii) Call reduction =ğ‘ğ‘ƒğ¶ğ¸âˆ’ğ‘ğ¹ğ‘ƒğ¶ğ¸
Hereğ´denotes PCE or ODES algorithm and ğ‘ğ‘ƒğ¶ğ¸(resp.,ğ‘ğ¹ğ‘ƒğ¶ğ¸ )
denotes the number of recur calls made by PCE (resp., FPCE).
Experimental Setup: We conducted our experiments on a work-
station with AMD Ryzen 9 5900X 3.7GHz 12 Core 24 thread CPU
and64GB RAM running on a 64-bit Ubuntu 20.04LTS O/S. To en-
sure fair comparison among algorithms, we compiled all codes using
the same GCC flag, turned off the â€˜Core Performance Boostâ€™ and â€™Fre-
quency Scalingâ€™ features, and fixed all processorsâ€™ frequencies to 3.7
GHz. We implemented FPCE in C and wrote Python scripts to pre-
process graphs and post-process results. Our code/data are shared
on our suppl. website: https://github.com/ahsanur-research/FPCE
8 Results
(i)No algorithm finished executing any of our three dense graphs
within five days, even though all of these graphs are quite small.
So, our results are based on the remaining 15graphs.
(ii)FPCE time tends to increase with the number of pseudo-cliques
and with the order of a graph (Figures 3 and 4) â€“ which is expected
from its time complexity (Section 5).
Figure 3: Bubble chart showing how FPCE time depends on
the number of pseudo-cliques in real graphs. Disk labels are
graph IDs (Table 3). Disk area varies with call reduction.
(iii)FPCE makes a lot fewer recursive calls than PCE for all graphs,
especially for large graphs . Increasing ğ‘šincreases both the size and
density of synthetic graphs (Table 2) and exponentially increases
both the number of pseudo-cliques and the time taken by FPCE to
enumerate them. But call reduction also increases almost exponen-
tially withğ‘š(Figure 4) because larger graphs tend to contain many
more unpromising subgraphs : subgraphs that can never be extended
to any(â„“,ğœƒ)-pseudo-cliques. Similarly, real graphs 13, 14, and 15
(respectively, graphs 1 â€“ 5) exhibit much larger (resp., smaller) call
reduction than others (Figure 3). These results indicate that FPCE
is more effective than PCE on larger graphs.
(iv)FPCE is always faster than PCE and ODES (Figure 5). For real
graphs, FPCE is, on average, 38.6and6.5times faster than ODES
and PCE, respectively. For synthetic graphs, FPCE is, on average,
39.7and3.1times faster than ODES and PCE, respectively. Among
synthetic graphs, SW graphs yield higher speedup (of FPCE w.r.t.
PCE) than SF graphs. The average speedup of FPCE w.r.t. PCE on
SW graphs (resp., on SF graphs) is 4.23(respectively, 1.88). This is
expected as SW graphs exhibit higher call reduction (Figure 4).
 
2484A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
510152025303540104107
(a)510152025303540 510152025303540 000101104
(b)510152025303540 510152025303540 000106108
(c)# Pseudo-cliques (SF)
# Pseudo-cliques (SW)FPCE time (SW)
PCE time (SW)FPCE time (SF)
PCE time (SF)Call reduction (SF)
Call reduction (SW)
Figure 4: (a) Number of pseudo-cliques, (b) PCE and FPCE execution times (in sec), and (c) Call reduction of FPCE for Small
World (SW) and Scale Free (SF) graphs. Here, X-axis denotes values of ğ‘šused to generate these synthetic graphs (see Section 6).
510152025303540024 3.6
1.41.31.92.22.1
1.41.2Scale Free Graph
5101520253035400102019.0
2.12.43.12.91.71.51.3Small World Graph
5101520253035400100
17.89.815.176.988.1165.3
**Scale Free Graph
510152025303540020
13.3
3.76.717.622.8
***Small World Graph
123456789101112131415100101
1.51.1 1.13.6
1.41.121.0
1.22.1
1.42.62.124.2 23.1
9.7
123456789101112131415101102
23.4
**193.2
**15.019.137.8
*8.1
2.49.5
**(a) (b)
(c) (d)
Figure 5: Speedup of FPCE w.r.t. (a) PCE and (b) ODES for synthetic graphs. Speedup of FPCE w.r.t. (c) PCE and (d) ODES for real
graphs. X-axis labels in (a) â€“ (b) denote values of ğ‘šused for synthetic graphs (see Section 6) and those in (c) â€“ (d) indicate real
graphsâ€™ IDs (see Table 3). Asterisks in (b) and (d) indicate real graphs on which ODES terminated prematurely.
(v)ODES is the worst of all. It terminates prematurely (showing
a memory overflow error) on many graphs and when it works, it
always takes much longer time than both PCE and FPCE (Figures 4
(b) and (d)). So we focus on comparing FPCE with PCE from now.
(vi)Among graphs with a similar number of pseudo-cliques, sparser
ones tend to yield higher call reduction and speedup w.r.t PCE. Real
graphs in each of the following groups have a similar number of
pseudo-cliques:{1,10},{2,12},{7,11,13,14,15}. In terms of den-
sity: 1>10,2>12,7>11>13>14â‰ˆ15. In terms of call
reduction (resp., speedup): 1<10,2<12,7<11<13<14<15
(resp., 1â‰ˆ10,2<12,7>11<13â‰ˆ14>15). Among synthetic
graphs without pseudo-cliques (SW graphs for m = 5, 10 and SF
graphs for m = 5, 10, 15), the denser the graph is, the lower the
speedup and call reduction of FPCE is. The same observation holds
for SW graph m = 25 and SF graph m = 40, which have a similar
number of pseudo-cliques (Tables 2 and 3, Figures 3â€“ 5). FPCEâ€™s
call reduction and speedup exhibit this behavior because if a sub-
graph is not embedded in a dense enough supergraph, then FPCE
identifies and prunes it as it is an unpromising subgraph.
(vii) FPCEâ€™s speedup w.r.t. PCE mostly depends on call reduction,
i.e.,it is mainly the effect of our pruning techniques (Appendix A).9 Ablation Study
When order-boundâ€™s condition is met (line 4, Algorithm 1), no (â„“,ğœƒ)-
pseudo-clique can exist â€“ which FPCE reports and terminates early.
Thus, we know that order-bound holds on real graphs 7,13,14, and
SW graph m=5. So, we see a high speedup (19 â€“ 24.2) of FPCE w.r.t.
PCE on these graphs (Figures 5(a),(c)). Since order-bound prunes
the entire search tree, FPCE skips the other two pruning techniques,
acting as FPCE-with-Order-Bound-only on these four graphs.
We created a version of FPCE called FPCE-EB which lacks Edge
Bound. We found that on our graphs other than these four graphs:
â€¢FPCE-EB is faster than PCE on almost all these graphs, having
an average speedup (w.r.t. PCE) of 2.2and1.6on these real
and synthetic graphs, respectively. It is the effect of Turan
Filtering alone as order-bound didnâ€™t hold on these graphs.
â€¢FPCE is faster than FPCE-EB on almost all these graphs,
with an average speedup (w.r.t. FPCE-EB) of 1.1and1.25
on these real and synthetic graphs, respectively, i.e.,adding
Edge Bound with FPCE-EB yields even more speedup.
These results imply that all pruning techniques of FPCE posi-
tively contribute to its efficiency.
 
2485KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
510152025303540012
1.11.31.41.61.6
1.11.21.0Scale Free Graphs
5101520253035400122.0
1.5
1.21.41.4
1.11.01.0Small World Graphs
123456789101112131415012
1.0 1.01.11.01.21.02.0
0.91.61.4
1.00.91.01.5
1.1Real Graphs
(a) (b) (c)
510152025303540023.2
1.10.91.21.41.9
1.21.1Scale Free Graphs
5101520253035400510 9.5
1.42.02.22.11.51.51.3Small World Graphs
12345678910111213141501020
1.5 1.1 1.03.51.1 1.110.5
1.2 1.3 0.92.5 2.323.4
15.2
8.5Real Graphs
(d) (e) (f)
Figure 6: Speedup of FPCE w.r.t. FPCE-EB for (a) â€“ (b) synthetic and (c) real graphs (top figure) and speedup of FPCE-EB w.r.t
PCE for (d) â€“ (e) synthetic and (f) real graphs (bottom figure).
10 Application and Comparison
We found a popular heuristic1method called ClusterONE [ 33]
(henceforth called CL1) that computes pseudo-cliques in PPI net-
works to identify protein complexes. So, we applied both CL1 and
FPCE on a PPI graph to see if the exact computation of pseudo-
cliques give any extra insights. We also applied an exact algorithm
called FastQC [51] to compute degree-based quasi-cliques (hence-
forth DQCs ) in that graph using the same parameters as FPCE.
An(â„“,ğœƒ)-DQC is a connected subgraph ğº[ğ‘ƒ]s.t.|ğ‘ƒ| â‰¥â„“and
ğ›¿(ğ‘ƒ)â‰¥ğœƒ(|ğ‘ƒ|âˆ’1)i.e.,it is always an(â„“,ğœƒ)-pseudo-clique but the op-
posite may not hold. We did not compare pseudo-cliques with other
types of dense subgraphs because there is no such correspondence
between their parameters and parameters of pseudo-cliques.
Dataset: To form a PPI network, we combined two PPI datasets
onEscherichia coli from [ 2] and [ 39]. We removed multi-edges and
self-loops from it. The resultant graph has 2119 nodes and 3778
edges. To prepare a gold standard, we downloaded known E. coli
protein complexes from ECOCYC2. Since it is easier to find very
small complexes, we only kept complexes with at least 5proteins.
There are 28such complexes. These form our gold-standard dataset.
Investigation: We applied FPCE and CL1 (respectively, FastQC)
on our PPI network to find all maximal (5,ğœƒ)-pseudo-cliques (re-
spectively,(5,ğœƒ)-DQCs) with ğœƒâˆˆ{0.9,0.8,0.7,0.6}.
Evaluation: We evaluate FPCE and CL1 based on:
(i)Ge
ometric A
ccuracy :Geometric Accuracy, a.k.a. Accuracy [33] is
a popular metric in protein complex prediction research. To define
it, letğ¶ğ‘–be theğ‘–-th complex in a gold standard, ğ‘›be the number
of such complexes, ğ‘ƒğ‘—be theğ‘—-th complex predicted (which is a
pseudo-clique/DQC in our experiment) by an algorithm, and ğ‘šbe
the number of such complexes. Then accuracy is the geometric
1Another heuristic was proposed to compute pseudo-cliques [ 1], but its code is not
publicly available and its authors could not provide it when we contacted them.
2https://ecocyc.org/group?id=:ALL-PROTEINS-2&orgid=ECOLImean of Sensitivity (SNS) andPositive Predictive Value (PPV) , where
ğ‘†ğ‘ğ‘†=Ãğ‘›
ğ‘–=1ğ‘šğ‘ğ‘¥ğ‘— |ğ¶ğ‘–âˆ©ğ‘ƒğ‘—|
Ãğ‘›
ğ‘–=1|ğ¶ğ‘–|ğ‘
ğ‘›ğ‘‘ğ‘ƒğ‘ƒğ‘‰ =Ãğ‘š
ğ‘—=1ğ‘šğ‘ğ‘¥ğ‘– |ğ¶ğ‘–âˆ©ğ‘ƒğ‘—|
Ãğ‘š
ğ‘—=1Ãğ‘›
ğ‘–=1|ğ¶ğ‘–âˆ©ğ‘ƒğ‘—|
(ii)Matching Comple
xes: If a pseudo-clique/DQC shares at least
ğœ†proteins with a known complex, we say that the complex matches
that pseudo-clique/DQC. We find complexes matching with pseudo-
cliques/DQCs (computed using FPCE/CL1/FastQC) for ğœ†âˆˆ{1,3}.
(iii)Biological Significance : As protein complex databases are
incomplete, a predicted complex not matching any known complex
may still be a valid complex or, at least, may form parts of the same
cellular component. So, researchers often estimate the biological
significance of their predicted complexes by Gene Ontology3(GO)
term4enrichment via Fisherâ€™s exact test, which takes a population
of genes/proteins (in our case, all proteins in our PPI network)
and a study set (in our case, a pseudo-clique/DQC) to compute a
ğ‘-value for each GO term. If a term has a low ğ‘-value, that means
the fraction of proteins annotated with that term in the study set
is significantly (statistically) higher than the fraction of proteins
annotated with that term in the population. In such a case, we
say that the study set is enriched in that term [ 19]. But this test
is not meaningful/applicable to our pseudo-cliques/DQCs directly,
due to their small sizes and high overlaps among them [ 27,42,52].
So, we combine pseudo-cliques/DQCs in the following way. We
build a graph whose nodes represent pseudo-cliques/DQCs and
place an edge between two nodes if their corresponding pseudo-
cliques/DQCs overlap. We merge the pseudo-cliques/DQCs in each
connected component of this graph to get some clusters. We use
GOATOOLS [ 19] to find GO Cellular Component (CC) terms that
are enriched in those clusters.
Results: (i)FPCE outperforms both CL1 and FastQC in terms of
SNS, PPV, and accuracy for almost all values of ğœƒ(Figure 7(a)).
(ii)All algorithms executed in < 1 sec for each density threshold ( ğœƒ).
3https://gene
ontology.org/
4A GO term denotes a function/component in a cell shared by a set of genes/proteins.
 
2486A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
0.6 0.7 0.8 0.90.00.51.0
(a)0.6 0.7 0.8 0.9102104
(b)SNS FPCE
SNS CL1
SNS FastQCPPV FPCE
PPV CL1
PPV FastQCAccuracy FPCE
Accuracy CL1
Accuracy FastQC# Pseudocliques FPCE
# Pseudocliques CL1
# DQCs FastQC
Figure 7: (a) Performance comparison between FPCE vs. ClusterONE (denoted CL1) and FastQC on protein-complex prediction
and (b) number of (5,ğœƒ)-pseudo-cliques/DQCs computed by them for this purpose. In both figures, X-axis indicates values of ğœƒ.
Table 4: Protein complexes that match (for ğœ†=3) with a FPCE pseudo-clique but do not match with any DQCs (starred ones
match with neither any DQCs nor any CL1-pseudo-cliques). Results for ğœ†=1are put in suppl. website to save space.
Complex Name Complex Members, ğ¶|ğ¶|Best Matched Pseudo-clique, ğ‘ƒ|ğ‘ƒ|ğ‘ƒâˆ©ğ¶|ğ‘ƒâˆ©ğ¶|
ATP synthase
F1 complex*atpA, atpC, atpD, atpG, atpH 5 atpA, atpC, atpD, atpG, atpH 5atpA, atpC, atpD,
atpG, atpH5
degradosome* eno, pnp, ppk, rhlB, rne 5 pnp, rhlB, rluB, rne, srmB, yfgB 6 pnp, rhlB, rne 3
ATP synthase
Fo complex*atpA, atpB, atpC, atpD,atpE,
atpF, atpG, atpH8 atpA, atpC, atpD, atpE, atpG 5atpA, atpC, atpD,
atpE, atpG5
DNA polymerase III,
holoenzymednaE, dnaN, dnaQ, dnaX,
holA, holB, . . . , holE9dnaE, dnaN, dnaQ, dnaX,
holA, holB, holC, holD8dnaE, dnaN, dnaQ,
dnaX, holA, . . . , holD8
hydrogenase 3 hycB, hycC . . . , hycG 6 fdhF, hycB, hycE, hycF, hycG 5 hycB, hycG 2
NADH:quinone
oxidoreductase InuoA, nuoB, nuoC,
nuoE, nuoF . . . , nuoN13 nuoJ, nuoK, nuoL, nuoM, nuoN 5nuoJ, nuoK, nuoL,
nuoM, nuoN5
formate hydrogenlyase
complexfdhF, hycB, hycC, hycD,
hycE, hycF, hycG7 fdhF, hycB, hycE, hycF, hycG 5fdhF, hycB, hycE,
hycF, hycG5
(iii)Number of pseudo-cliques decreases with the increase of ğœƒand as
such SNS and accuracy also decreases. We choseğœƒ=0.8for our next
analyses since it gives high enough accuracy (0 .41) and decreasing
ğœƒfurther increases accuracy a little bit (0 .49forğœƒ=0.7) but results
in many more pseudo-cliques (Figure 7 (b)).
(iv) Forğœ†=3, only 4 and 0 (respectively, 7) known complexes
match with some CL1-pseudo-cliques and FastQC-DQCs (resp.,
FPCE pseudo-cliques), respectively. If we lower ğœ†to1, then 7and
5(resp., 11) complexes match with some CL1 pseudo-cliques and
DQCs, respectively (resp., FPCE pseudo-cliques). For both values
ofğœ†(resp., forğœ†=3), each complex that matches with some CL1-
pseudo-cliques (resp., DQCs), also matches with some FPCE pseudo-
cliques (forğœ†=1, two complexes exist that match with some DQCs
but not with any FPCE pseudo-cliques â€“ which may be the effect
of the small value of ğœ†). These results imply that CL1/FastQC is less
useful compared to FPCE alone here. Forğœ†=3(resp., forğœ†=1), we
found 3 (resp., 4) complexes that match with some FPCE pseudo-
cliques but do not match with any CL1 pseudo-cliques (starred
complexes in Table 4), which implies that FPCE may unearth com-
plexes missed by a heuristic pseudo-clique miner. Similarly, For ğœ†=3
(resp., forğœ†=1), we found 7 (resp., 8) complexes that match with
some FPCE pseudo-cliques but do not match with any DQCs (Ta-
ble 4), which implies that FPCE may unearth complexes that cannot
be found by computing DQCs.(v) We got 18, 13, and 8 clusters by merging overlapping pseudo-
cliques/DQCs got from FPCE, CL1, and FastQC, respectively. Among
those, 13 FPCE-derived clusters, 8 CL1-derived clusters, and 6
FastQC-derived clusters are enriched in some GO CC terms. FPCE,
CL1, and FastQC-derived clusters are enriched in 64,42and35
unique GO CC terms, respectively. Among these terms, 28 (resp.,
only 6) are enriched in some FPCE clusters (resp, CL1 clusters) but
are not enriched in any CL1 (resp. FPCE) clusters; whereas 40 (resp.,
only 11) terms are enriched in some FPCE clusters (resp, FastQC
clusters) but are not enriched in any FastQC (resp., FPCE) clusters.
All these results indicate that FPCE outputs are biologically more
interesting than those of CL1/FastQC.
11 Conclusion and Future Directions
We present an exact algorithm to compute pseudo-cliques in a graph.
We show that it is the fastest one on our synthetic and real graphs.
But no exact algorithm (including ours) could enumerate pseudo-
cliques from dense graphs in a reasonable time. Other pruning
techniques may need to be devised to achieve that goal. More
speedup can be achieved via parallelization. Our ideas can also
be extended to find pseudo-cliques in weighted graphs.
Acknowledgments
This work was funded by NSU grant CTRG-20/SEPS/19. We thank
Osama Nadeem, Shahriar Kamal, Khan Asfi Reza for helping us.
 
2487KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
References
[1]James Abello, Mauricio G.C. Resende, and Sandra Sudarsky. 2002. Massive
quasi-clique detection. In Lecture Notes in Computer Science, Vol. 2286. Springer,
598â€“612.
[2]Mohammad Arifuzzaman, Maki Maeda, Aya Itoh, Kensaku Nishikata, Chiharu
Takita, Rintaro Saito, Takeshi Ara, Kenji Nakahigashi, Hsuan-Cheng Huang, Aki
Hirai, et al .2006. Large-scale identification of proteinâ€“protein interaction of
Escherichia coli K-12. Genome research 16, 5 (2006), 686â€“691.
[3]David Avis and Komei Fukuda. 1996. Reverse search for enumeration. Discrete
Applied Mathematics 65, 1-3 (1996), 21â€“46.
[4]Albert LÃ¡szlÃ³ BarabÃ¡si and RÃ©ka Albert. 1999. Emergence of scaling in random
networks. Science (1999).
[5]Vladimir Batagelj and Matjaz Zaversnik. 2003. An O(m) Algorithm for Cores
Decomposition of Networks. CoRR cs.DS/0310049 (2003).
[6]Malay Bhattacharyya and Sanghamitra Bandyopadhyay. 2009. Mining the largest
quasi-clique in human protein interactome. In Proceedings of the 2009 International
Conference on Adaptive and Intelligent Systems, ICAIS 2009. IEEE, 194â€“199.
[7]Francesco Bonchi and Claudio Lucchese. 2005. Pushing tougher constraints in
frequent pattern mining. In Lecture Notes in Computer Science. Springer, 114â€“124.
[8]Zvika Brakerski and Boaz Patt-Shamir. 2011. Distributed discovery of large
near-cliques. Distributed Computing 24 (2011), 79â€“89.
[9]Mauro Brunato, Holger H. Hoos, and Roberto Battiti. 2008. On effectively finding
maximal quasi-cliques in graphs. In Lecture Notes in Computer Science, Vol. 5313
LNCS. 41â€“55.
[10] Samy Chambi, Daniel Lemire, Owen Kaser, and Robert Godin. 2016. Better bitmap
performance with roaring bitmaps. Software: practice and experience 46, 5 (2016),
709â€“719.
[11] Jiejiang Chen, Shaowei Cai, Shiwei Pan, Yiyuan Wang, Qingwei Lin, Mengyu
Zhao, and Minghao Yin. 2021. NuQClq: An effective local search algorithm
for maximum quasi-clique problem. In Proceedings of the AAAI Conference on
Artificial Intelligence, Vol. 35. 12258â€“12266.
[12] Jie Chen and Yousef Saad. 2012. Dense Subgraph Extraction with Application to
Community Detection. IEEE Transactions on Knowledge and Data Engineering 24,
7 (2012), 1216â€“1230.
[13] Serena Dotolo, Anna Marabotti, Angelo Facchiano, and Roberto Tagliaferri. 2020.
A review on drug repurposing applicable to COVID-19. Briefings in Bioinformatics
22, 2 (2020), 726â€“741.
[14] A. V. Goldberg. 1984. Finding a Maximum Density Subgraph. Technical Report.
University of California at Berkeley.
[15] Mokhtarul Haque, Rosy Sarmah, and Dhruba K. Bhattacharyya. 2018. A common
neighbor based technique to detect protein complexes in PPI networks. Journal
of Genetic Engineering and Biotechnology 16, 1 (2018), 227â€“238.
[16] Steve Harenberg, Gonzalo Bello, L. Gjeltema, Stephen Ranshous, Jitendra Har-
lalka, Ramona Seay, Kanchana Padmanabhan, and Nagiza Samatova. 2014. Com-
munity detection in large-scale networks: A survey and empirical evaluation. ,
426â€“439 pages.
[17] Shweta Jain and C. Seshadhri. 2017. A Fast and Provable Method for Estimating
Clique Counts Using TurÃ¡nâ€™s Theorem. In Proceedings of the 26th International
Conference on World Wide Web. IW3C2, 441â€“449.
[18] Shweta Jain and C. Seshadhri. 2020. Provably and Efficiently Approximating
Near-cliques using the TurÃ¡n Shadow: PEANUTS. In Proceedings of The Web
Conference 2020 (WWW â€™20) . 1966â€“1976.
[19] DV Klopfenstein, Liangsheng Zhang, Brent S Pedersen, Fidel RamÃ­rez, Alex
Warwick Vesztrocy, AurÃ©lien Naldi, Christopher J Mungall, Jeffrey M Yunes, Olga
Botvinnik, Mark Weigel, et al .2018. GOATOOLS: A Python library for Gene
Ontology analyses. Scientific reports 8, 1 (2018), 10872.
[20] Christian Komusiewicz and Manuel Sorge. 2015. An algorithmic framework
for fixed-cardinality optimization in sparse graphs applied to dense subgraph
problems. Discrete Applied Mathematics 193 (2015), 145â€“161.
[21] Christian Komusiewicz, Manuel Sorge, and Kolja Stahl. 2015. Finding Connected
Subgraphs of Fixed Minimum Density: Implementation and Experiments. In
Proceedings of the 14th International Symposium on Experimental Algorithms -
Volume 9125. Springer-Verlag, 82â€“93.
[22] Georg Kustatscher, Martina HÃ¶dl, Edward Rullmann, Piotr Grabowski, Emmanuel
Fiagbedzi, Anja Groth, and Juri Rappsilber. 2023. Higher-order modular regulation
of the human proteome. Molecular Systems Biology 19, 5 (2023), e9503.
[23] Victor E. Lee, Ning Ruan, Ruoming Jin, and Charu Aggarwal. 2010. A Survey of
Algorithms for Dense Subgraph Discovery. Springer, 303â€“336.
[24] Guimei Liu and Limsoon Wong. 2008. Effective pruning techniques for mining
quasi-cliques. In Lecture Notes in Computer Science, Vol. 5212 LNAI. Springer B.H.,
Berlin, Heidelberg, 33â€“49.
[25] Jiewei Liu, Ming Li, Xiong-Jian Luo, and Bing Su. 2018. Systems-level analysis of
risk genes reveals the modular nature of schizophrenia. Schizophrenia Research
201 (2018), 261â€“269.
[26] James Long and Chris Hartman. 2010. ODES: An overlapping dense sub-graph
algorithm. Bioinformatics 26, 21 (2010), 2788â€“2789.[27] Weijun Luo, Michael S Friedman, Kerby Shedden, Kurt D Hankenson, and Peter J
Woolf. 2009. GAGE: generally applicable gene set enrichment for pathway
analysis. BMC bioinformatics 10 (2009), 1â€“17.
[28] Xiuli Ma, Guangyu Zhou, Jingbo Shang, Jingjing Wang, Jian Peng, and Jiawei Han.
2017. Detection of Complexes in Biological Networks Through Diversified Dense
Subgraph Mining. Journal of computational biology : a journal of computational
molecular cell biology 24 (2017), 923â€“941. Issue 9.
[29] Foad Mahdavi Pajouh, Zhuqi Miao, and Balabhaskar Balasundaram. 2014. A
branch-and-bound approach for maximum quasi-cliques. Annals of Operations
Research 216, 1 (2014), 145â€“161.
[30] Fabrizio Marinelli, Andrea Pizzuti, and Fabrizio Rossi. 2020. LP-based dual bounds
for the maximum quasi-clique problem. Discrete Applied Mathematics (2020).
[31] David W. Matula and Leland L. Beck. 1983. Smallest-last ordering and clustering
and graph coloring algorithms. Journal of the ACM (JACM) 30, 3 (1983), 417â€“427.
[32] Michael Mitzenmacher, Jakub Pachocki, Richard Peng, Charalampos Tsourakakis,
and Shen Chen Xu. 2015. Scalable Large Near-Clique Detection in Large-Scale
Networks via Sampling. In Proceedings of the 21th ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining. 815â€“824.
[33] TamÃ¡s Nepusz, Haiyuan Yu, and Alberto Paccanaro. 2012. Detecting overlapping
protein complexes in protein-protein interaction networks. Nature Methods
(2012).
[34] Grigory Pastukhov, Alexander Veremyev, Vladimir Boginski, and Oleg A
Prokopyev. 2018. On maximum degree-based-quasi-clique problem: Complexity
and exact approaches. Networks 71, 2 (2018), 136â€“152.
[35] Jeffrey Pattillo, Alexander Veremyev, Sergiy Butenko, and Vladimir Boginski.
2013. On the maximum quasi-clique problem. Discrete Applied Mathematics 161,
1-2 (2013), 244â€“257.
[36] Jian Pei, Jiawei Han, and Laks V.S. Lakshmanan. 2001. Mining frequent itemsets
with convertible constraints. Proceedings - International Conference on Data
Engineering (2001), 433â€“442,.
[37] Lu Qin, Rong-Hua Li, Lijun Chang, and Chengqi Zhang. 2015. Locally Dens-
est Subgraph Discovery. In Proceedings of the 21th ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining. 965â€“974.
[38] Ahsanur Rahman, Steve T. K. Jan, Hyunju Kim, B. Aditya Prakash, and T. M.
Murali. 2016. Unstable Communities in Network Ensembles. In Proceedings of
the 2016 SIAM International Conference on Data Mining. SIAM, 504â€“512.
[39] Seesandra V Rajagopala, Patricia Sikorski, Ashwani Kumar, Roberto Mosca, James
Vlasblom, Roland Arnold, Jonathan Franca-Koh, Suman B Pakala, Sadhna Phanse,
Arnaud Ceol, et al .2014. The binary protein-protein interaction landscape of
Escherichia coli. Nature biotechnology 32, 3 (2014), 285â€“290.
[40] Ryan A. Rossi and Nesreen K. Ahmed. 2015. The network data repository with
interactive graph analytics and visualization. In Proceedings of the Twenty-Ninth
AAAI Conference on Artificial Intelligence. 4292 â€“ 4293.
[41] Seyed Vahid Sanei-Mehri, Apurba Das, and Srikanta Tirthapura. 2018. Enumer-
ating Top-k Quasi-Cliques. In Proceedings - 2018 IEEE International Conference on
Big Data, Big Data 2018. IEEE, 1107â€“1112.
[42] Cedric Simillion, Robin Liechti, Heidi EL Lischer, Vassilios Ioannidis, and RÃ©my
Bruggmann. 2017. Avoiding the pitfalls of gene set enrichment analysis with
SetRank. BMC bioinformatics 18, 1 (2017), 1â€“14.
[43] Shu Tadaka and Kengo Kinoshita. 2016. NCMine: Core-peripheral based func-
tional module detection using near-clique mining. Bioinformatics 32, 22 (2016),
3454â€“3460.
[44] Charalampos E. Tsourakakis, Francesco Bonchi, Aristides Gionis, Francesco
Gullo, and Maria A. Tsiarli. 2013. Denser than the densest subgraph: Extracting
optimal quasi-cliques with quality guarantees. In Proceedings of the ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining. 104â€“112.
[45] Takeaki Uno. 2010. An efficient algorithm for solving pseudo clique enumeration
problem. Algorithmica (New York) 56, 1 (2010), 3â€“16.
[46] Alexander Veremyev, Oleg A. Prokopyev, Sergiy Butenko, and Eduardo L. Pasiliao.
2016. Exact MIP-based approaches for finding maximum quasi-cliques and dense
subgraphs. Computational Optimization and Applications 64, 1 (2016), 177â€“214.
[47] Jose L Walteros and Austin Buchanan. 2020. Why is maximum clique often easy
in practice? Operations Research 68, 6 (2020), 1866â€“1895.
[48] Xiao Fan Wang and Guanrong Chen. 2003. Complex networks: small-world,
scale-free and beyond. IEEE circuits and systems magazine 3, 1 (2003), 6â€“20.
[49] Duncan J Watts and Steven H Strogatz. 1998. Collective dynamics of â€˜small-
worldâ€™networks. nature 393, 6684 (1998), 440â€“442.
[50] Qiu Xiao, Haiming Yu, Jiancheng Zhong, Cheng Liang, Guanghui Li, Pingjian
Ding, and Jiawei Luo. 2020. An in-silico method with graph-based multi-label
learning for large-scale prediction of circRNA-disease associations. Genomics
112, 5 (2020), 3407â€“3415.
[51] Kaiqiang Yu and Cheng Long. 2023. Fast Maximal Quasi-clique Enumeration:
A Pruning and Branching Co-Design Approach. Proc. ACM Manag. Data 1, 3,
Article 211 (2023), 26 pages.
[52] Qi Zheng and Xiu-Jie Wang. 2008. GOEAST: a web-based software toolkit for
Gene Ontology enrichment analysis. Nucleic acids research 36, suppl_2 (2008),
W358â€“W363.
 
2488A Fast Exact Algorithm to Enumerate Maximal Pseudo-cliques in Large Sparse Graphs KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
A Supplementary Results
FPCEâ€™s speedup varies with call ratio (ratio of no. of recursive calls
of PCE vs. FPCE), i.e.,its speedup is mainly the effect of its pruning
techniques, not merely that of implementation tactics (Figure 8).
1 2 4 8 16
Call Ratio1248SpeedupScale Free Graph
Small World Graph
Real Graph
Figure 8: Call ratio vs. speedup of FPCE w.r.t. PCE.
On real graphs, FPCE and FPCE-EB achieve an average speedup
of 6.5 and 5, respectively. Both use an average of 2.9 times more
memory than PCE (Table 5). For space limitation, we put other
results for(â„“,ğœƒ)=(10,0.9)and those for(10,0.8)in our suppl.
website.
Table 5: Time (in sec) and Memory (Resident Set Size, in
MB) of PCE, FPCE-EB, and FPCE on real graphs. Memory
consumptions of FPCE and FPCE-EB are almost the same.
Graph Time Memory
ID PCE FPCE-EB FPCE PCE FPCE
1 0.69 0.45 0.46 3.1 5.8
229,713.24 27,345.89 27,498.36 3.6 7.1
3 548.66 552.35 490.87 3.6 7.2
4 2.27 0.64 0.63 4.0 9.2
5 215.52 189.23 158.51 5.5 14.5
6 1,727.02 1,604.64 1,598.60 5.6 14.6
7 0.21 0.02 0.01 5.6 13.3
8 1.21 0.97 1.03 14.2 50.9
9 18.45 13.78 8.83 27.5 127.9
10 224.50 237.39 164.08 29.0 124.0
11 3.89 1.54 1.48 29.7 127.7
12 1.94 0.83 0.93 43.1 160.3
13 260.63 11.13 10.79 706.2 3,003.3
14 453.52 29.86 19.64 3,521.9 12,184.8
15 1,797.16 212.36 185.51 4,322.4 19,220.3
B Proofs
At first, we prove Lemmas 8 to 10 and derive some corollaries
from them. Then we use those results to prove Lemmas 2 to 7 and
Theorem 1 â€“ which have already been stated in Sections 4 and 5.
Lemma 8.ğ‘(ğ‘ƒ)=ğ‘šğ‘–ğ‘›ğ‘£âˆˆğ‘ƒğ‘(ğ‘£)Proof.ğ‘(ğ‘ƒ)=ğ‘šğ‘ğ‘¥ğ‘ƒâŠ†ğ¶ğ‘˜(ğº){ğ‘˜}=ğ‘¡=â‡’ğ‘(ğ‘£) â‰¥ğ‘¡âˆ€ğ‘£âˆˆğ‘ƒ
because some vertices ğ‘£âˆˆğ‘ƒmay belong to a(ğ‘¡+ğ‘¥)-core (for
someğ‘¥>0) â€“ which must be a subgraph of the ğ‘¡-core [ 31]. On the
other hand, there must be a vertex ğ‘£âˆˆğ‘ƒs.t.ğ‘(ğ‘£)=ğ‘¡because if
âˆ€ğ‘£âˆˆğ‘ƒ:ğ‘(ğ‘£)>ğ‘¡, thenğ‘(ğ‘†)>ğ‘¡. â–¡
Corollary 5. ğ‘(ğ‘ƒ)â‰¤ğ‘(ğ‘£) âˆ€ğ‘£âˆˆğ‘ƒ
Lemma 9. For any subset of vertices ğ‘ƒ,ğ›¿(ğ‘ƒ)â‰¤ğ‘(ğ‘ƒ).
Proof. Letğ›¿(ğ‘ƒ)>ğ‘(ğ‘ƒ). Soâˆ€ğ‘£âˆˆğ‘ƒ:ğ‘‘ğ‘ƒ(ğ‘£) â‰¥ğ›¿(ğ‘ƒ)>ğ‘(ğ‘ƒ).
Soğ‘ƒâŠ†ğ¶ğ‘¡(ğº)whereğ‘¡â‰¥ğ›¿(ğ‘ƒ)>ğ‘(ğ‘ƒ)=â‡’ğ‘(ğ‘ƒ)=ğ‘¡>ğ‘(ğ‘ƒ)
(contradiction). â–¡
Corollary 6. ğ›¿(ğ‘ƒ)â‰¤ğ‘(ğ‘ƒ)â‰¤ğ‘(ğ‘£) âˆ€ğ‘£âˆˆğ‘ƒ
The last inequality follows from Corollary 5.
Lemma 10. ğ‘ƒâŠ†ğ‘‰=â‡’ğ‘ğ‘ƒ(ğ‘£)â‰¤ğ‘(ğ‘£) âˆ€ğ‘£âˆˆğ‘ƒ
Proof. Letğ‘£be any node in ğ‘ƒandğ‘ğ‘ƒ(ğ‘£)=ğ‘˜i.e.,ğ‘£âˆˆğ¶ğ‘˜(ğ‘ƒ)âŠ†ğ‘ƒ.
According to Corollary 6, ğ‘(ğ‘£)â‰¥ğ›¿(ğ¶ğ‘˜(ğ‘ƒ))=ğ‘˜=ğ‘ğ‘ƒ(ğ‘£)â–¡
Corollary 7. ğ‘ƒâŠ†ğ‘†=â‡’ğ‘ğ‘ƒ(ğ‘£)â‰¤ğ‘ğ‘†(ğ‘£) âˆ€ğ‘£âˆˆğ‘ƒ
Lemma 2: Ifğ‘†is a(â„“,ğœƒ)-pseudo-clique then ğœ‰ğ‘†â‰¥âŒˆğœƒ|ğ‘†|/2âŒ‰.
Proof. Each vertex in the MD ordering of ğº[ğ‘†]is adjacent to
at mostğœ‰ğ‘†preceding nodes [47]. So
|ğ¸[ğ‘†]|â‰¤0+1+2+...+(ğœ‰ğ‘†âˆ’1)+(|ğ‘†|âˆ’ğœ‰ğ‘†)ğœ‰ğ‘†=
|ğ‘†|âˆ’ğœ‰ğ‘†+1
2
ğœ‰ğ‘†
Sinceğ‘†is a(â„“,ğœƒ)-pseudo-clique of order |ğ‘†|,|ğ¸[ğ‘†]|â‰¥ğœƒ |ğ‘†|
2.
âˆ´ğœƒ|ğ‘†|
2
â‰¤
|ğ‘†|âˆ’ğœ‰ğ‘†+1
2
ğœ‰ğ‘†=â‡’ğœ‰ğ‘†â‰¥âŒˆğœƒ|ğ‘†|/2âŒ‰
It follows from the solution of the quadratic inequality in the LHS,
which was simplified by ğœ‰ğ‘†â‰¥1(sinceğº[ğ‘†]is connected). â–¡
Lemma 3: Ifğ‘†is ağœƒ-pseudo-clique, the largest clique in ğº[ğ‘†]is
of orderğœ”, andğœƒ>(ğœ”âˆ’1)/ğœ”then|ğ‘†|â‰¤j
1
1âˆ’(ğœ”âˆ’1)/ğœ”ğœƒk
.
Proof. Let|ğ‘†|=ğ‘›. Since the maximum clique of ğºhasğœ”nodes,
ğºisğ¾ğœ”+1-free. So by Turanâ€™s theorem [ 17],|ğ¸[ğ‘†]|â‰¤(1âˆ’1/ğœ”)ğ‘›2/2.
Sinceğ‘†is ağœƒ-pseudo-clique|ğ¸[ğ‘†]|â‰¥ğœƒ ğ‘›
2. Soğœƒ ğ‘›
2â‰¤(1âˆ’1/ğœ”)ğ‘›2/2.
Simplifying this, we get this upper bound on |ğ‘†|=ğ‘›.â–¡
Theorem 1: Ağœƒ-pseudo-clique ğ‘†withâ„“vertices must contain an
ğ‘Ÿ-cliqueğ¾whereğ‘Ÿ=âŒˆ1/(1âˆ’ğœƒ(â„“âˆ’1)/â„“)âŒ‰.
Proof. According to Turanâ€™s theorem, if a subgraph ğº[ğ‘†]con-
tains noğ¾ğ‘—+1then|ğ¸[ğ‘†]|â‰¤( 1âˆ’1/ğ‘—)â„“2/2. Sinceğ‘†is ağœƒ-pseudo-
clique withâ„“vertices,|ğ¸[ğ‘†]|â‰¥ğœƒ â„“
2. So ifğ¾ğ‘—+1is not a subgraph of
ğº[ğ‘†]thenğ‘—â‰¥âŒˆ1/(1âˆ’ğœƒ(â„“âˆ’1)/â„“)âŒ‰. Taking contrapositive: ğº[ğ‘†]
must contain a ğ‘—-clique for each value of ğ‘—âˆˆ{1,2,...ğ‘Ÿ}where
ğ‘Ÿ=âŒˆ1/(1âˆ’ğœƒ(â„“âˆ’1)/â„“)âŒ‰. â–¡
Lemma 4: Ifğºcontains ağ‘¡-cliqueğ¾, thenğ¾âŠ†ğ¶ğ‘¡â€²[ğº]where
ğ‘¡â€²=ğ‘šğ‘–ğ‘›{ğ‘˜:ğ‘˜â‰¥ğ‘¡âˆ’1ğ‘ğ‘›ğ‘‘|ğ¶ğ‘˜|>0}.
Proof. Let<ğ‘£1,ğ‘£2,...,ğ‘£|ğ‘‰|>be the MD ordering of ğºand
ğ‘£ğ‘›be the last vertex of ğ¾in that ordering. Let ğ‘ƒ={ğ‘£1,ğ‘£2,...ğ‘£ğ‘›}.
Clearly,ğ¾âŠ†ğ‘ƒ. According to Corollary 6, ğ‘(ğ‘£)â‰¥ğ›¿(ğ‘ƒ)=ğ‘‘ğ‘ƒ(ğ‘£ğ‘›)â‰¥
ğ‘‘ğ¾(ğ‘£ğ‘›)â‰¥ğ‘¡âˆ’1for allğ‘£âˆˆğ‘ƒ. Thereforeğ¾âŠ†ğ‘ƒâŠ†ğ¶ğ‘¡â€²[ğº].â–¡
 
2489KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ahsanur Rahman, Kalyan Roy, Ramiza Maliha, and Townim Faisal Chowdhury
Lemma 6: Ifğ‘†,ğ‘ƒareğœƒ-pseudo-cliques such that |ğ‘†|=â„“andğ‘†is a
descendant of ğ‘ƒthenğœƒ â„“
2â‰¤ğ¸[ğ‘ƒ]+(â„“âˆ’|ğ‘ƒ|)(ğ›¿(ğ‘ƒ)+(â„“âˆ’|ğ‘ƒ|+1)/2)
Proof. By condition (ii) of Lemma 5, if ğ‘ƒâˆª{ğ‘¢}is a child ofğ‘ƒthen
ğ‘‘ğ‘ƒâˆª{ğ‘¢}(ğ‘¢)=ğ›¿(ğ‘ƒâˆª{ğ‘¢})â‰¤ğ›¿(ğ‘ƒ)+1. By condition (i) of the same
lemma,ğœƒ |ğ‘ƒ|+1
2â‰¤ğ¸[ğ‘ƒ]+ğ›¿(ğ‘ƒ)+1. Generalizing this condition
for a descendant ğ‘†ofğ‘ƒwe getğœƒ |ğ‘†|
2â‰¤ğ¸[ğ‘ƒ]+Ãğ›¿(ğ‘ƒ)+â„“âˆ’|ğ‘ƒ|
ğ‘–=ğ›¿(ğ‘ƒ)+1ğ‘–=
ğ¸[ğ‘ƒ]+(â„“âˆ’|ğ‘ƒ|)
ğ›¿(ğ‘ƒ)+â„“âˆ’|ğ‘ƒ|+1
2
â–¡
Lemma 7: Letğ‘ƒ,ğ‘†areğœƒ-pseudo-cliques,|ğ‘†|=â„“,ğœğ‘ƒ=ğ›¿(ğ‘ƒ)+1
2,
ğœ‚(ğ‘ƒ)=ğ‘šğ‘–ğ‘›{ğ‘(ğ‘ƒ),ğ›¿(ğ‘ƒ)+â„“âˆ’|ğ‘ƒ|}, andğ‘ƒis an ancestor of ğ‘†in the
reverse search tree, then
ğœƒâ„“
2
â‰¤(
ğ¸[ğ‘ƒ]+(â„“âˆ’|ğ‘ƒ|)ğ›¿(ğ‘ƒ), ifğ‘(ğ‘ƒ)=ğ›¿(ğ‘ƒ)
ğ¸[ğ‘ƒ]+(â„“âˆ’ğ‘ƒ+ğœğ‘ƒ)ğœ‚(ğ‘ƒ)âˆ’(ğ›¿(ğ‘ƒ)+1)ğœğ‘ƒ,otherwise
Proof. Letğ‘†ğ‘–be theğ‘–-length prefix of ğ‘†â‰»andğ‘£ğ‘–be the last
node ofğ‘†ğ‘–. By Lemma 9 and Corollary 7: ğ›¿(ğ‘†) â‰¥ğ›¿(ğ‘ƒ). When
ğ›¿(ğ‘†)=ğ›¿(ğ‘ƒ), each node ğ‘£ğ‘–âˆˆğ‘†âˆ’ğ‘ƒhas degreeğ›¿(ğ‘ƒ)inğº[ğ‘†ğ‘–]. So,
ğœƒ â„“
2â‰¤ğœ“1(ğ‘ƒ)=ğ¸[ğ‘ƒ]+(â„“âˆ’|ğ‘ƒ|)ğ›¿(ğ‘ƒ). Whenğ›¿(ğ‘†)>ğ›¿(ğ‘ƒ),ğœƒ â„“
2â‰¤
ğ¸[ğ‘ƒ]+Ãğ›¿(ğ‘†)âˆ’1
ğ‘–=ğ›¿(ğ‘ƒ)+1ğ‘–+(â„“âˆ’|ğ‘ƒ|âˆ’(ğ›¿(ğ‘†)âˆ’ğ›¿(ğ‘ƒ)âˆ’1))ğ›¿(ğ‘†). Asğ›¿(ğ‘†)â‰¤
ğœ‚(ğ‘ƒ),ğœƒ â„“
2â‰¤ğœ“2(ğ‘ƒ)=ğ¸[ğ‘ƒ]+(â„“âˆ’|ğ‘ƒ|+ğœğ‘ƒ)ğœ‚(ğ‘ƒ)âˆ’(ğ›¿(ğ‘ƒ)+1)ğœğ‘ƒ.
Altogether ğœƒ â„“
2â‰¤ğ‘šğ‘ğ‘¥(ğœ“1(ğ‘ƒ),ğœ“2(ğ‘ƒ)). Ifğ‘(ğ‘ƒ)=ğ›¿(ğ‘ƒ),ğœ“1(ğ‘ƒ)>
ğœ“2(ğ‘ƒ). Otherwise, i.e.,whenğ‘(ğ‘ƒ)>ğ›¿(ğ‘ƒ),ğœ“2(ğ‘ƒ)>ğœ“1(ğ‘ƒ)for both
possible values of ğœ‚(ğ‘ƒ). Putting these together, we get this bound.
â–¡
C Time Complexity Analysis
The PCE algorithm (Algorithm 2) is similar to our FPCE algorithm
except that it does not apply our pruning techniques. As compared
to PCE, FPCE takes an extra ğ‘‚(ğ¸)time during preprocessing for
core calculation (line 1 of Algorithm 1) and an extra ğ‘‚(1)time
during each call of recur for applying Edge Bound. When Turan
Filtering is applied, FPCE takes less time than PCE because in that
case, it calls getChildrenClq instead of slower getChildrenPseudoClq.
So, the time complexity of FPCE remains the same as PCE. Since
our pruning techniques do not incur any extra time complexity,
the worst case time complexity of FPCE is the same as that of PCE,
even though in reality, significant speedup is achieved via FPCE,
as shown in Section 8. Therefore, to derive the time complexity of
FPCE, it suffices to derive the time complexity of the PCE algorithm â€“
which we do below, along with a discussion of its working principle.
To explore the reverse search tree, PCE calls a recursive subrou-
tine called recur-basic on each pseudo-clique of order one, i.e.,on
each node in ğ‘‰[ğº]. This subroutine relies on a procedure called
getChildrenPseudoClq (line 9 of Algorithm 2) to generate child
pseudo-cliques of the current pseudo-clique ğ‘ƒ. This procedure re-
turns a setğ·of nodes that satisfy the conditions of Lemma 5. Note
that, condition (iii) of this lemma is equivalent to the following
condition: either (a) ğ‘¢â‰ºğ‘£âˆ—(ğ‘ƒ), or (b)ğ‘¢â‰ºğ›¾(ğ‘¢,ğ‘ƒ)whereğ›¾(ğ‘¢,ğ‘ƒ)is
the last node in degree ordering of ğ‘ƒwhich is not in ğ‘(ğ‘¢)(ifğ‘¢is a
neighbor of all nodes in ğ‘ƒ, thenğ‘¢â‰ºğ›¾(ğ‘¢,ğ‘ƒ), by default) [ 45]. To find
such nodes efficiently, PCE maintains a binary tree ğ‘‡(henceforth
called degree tree ) that stores all nodes in ğ‘‰[ğº]at its leaves in the
degree orderingâ‰»ofğº[ğ‘ƒ]. It exploits this tree to find nodes ğ‘¢âˆ‰ğ‘ƒsatisfying the first two conditions of Lemma 5 and condition (a) or
(b),i.e.,it generates nodes having either of the following properties:
Input: Graphğº, minimum order â„“, minimum density ğœƒ
Output: All maximal(â„“,ğœƒ)-pseudo-cliques in ğº
1forallğ‘£âˆˆğ‘‰[ğº]do
2ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘Ÿâˆ’ğ‘ğ‘ğ‘ ğ‘–ğ‘(ğº,{ğ‘£},ğ‘£,{})
3
4Procedure recur-basic (G,ğ‘ƒ,ğ‘£,ğ´ )
5 ifğ‘ƒis a maximal(â„“,ğœƒ)-pseudo-clique then
6 outputğ‘ƒ
7 return
8 ifğœƒ |ğ‘ƒ|+1
2âˆ’ğ¸[ğ‘ƒ]>ğ›¿(ğ‘ƒ)+1then return
9ğ·=ğ‘”ğ‘’ğ‘¡ğ¶â„ğ‘–ğ‘™ğ‘‘ğ‘Ÿğ‘’ğ‘›ğ‘ƒğ‘ ğ‘’ğ‘¢ğ‘‘ğ‘œğ¶ğ‘™ğ‘ (ğº,ğ‘ƒ,ğ‘£)
10 forallğ‘¢âˆˆğ·do
11ğ‘„=ğ‘ƒâˆª{ğ‘¢}
12ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘Ÿâˆ’ğ‘ğ‘ğ‘ ğ‘–ğ‘(ğº,ğ‘„,ğ‘¢,ğ· )
Algorithm 2: PCE(ğº,â„“,ğœƒ ) algorithm.
(1)Nodes satisfying the aforementioned condition (a): for such
a nodeğ‘¢,ğ‘„=ğ‘ƒâˆª{ğ‘¢}must be a child of ğ‘ƒ(by Lemma 5).
SogetChildrenPseudoClq simply returns all such nodes and
then recur-basic is called on each of them iteratively. Finding
each such node from ğ‘‡requiresğ‘‚(ğ‘™ğ‘”ğ‘‰)time.
(2)Nodes satisfying condition (b): Such a node must be a neigh-
bor ofğ‘£âˆ—(ğ‘ƒ)[45]. But if a node ğ‘£âˆˆğ‘(ğ‘£âˆ—(ğ‘ƒ))satisfies
condition (ii) of Lemma 5, then ğ›¾(ğ‘£,ğ‘ƒ)must be in the first
ğ‘‘(ğ‘£)+1=ğ‘‚(Î”)vertices in the degree ordering of ğ‘ƒinğ‘‡. So
searching for ğ›¾(ğ‘£,ğ‘ƒ)requiresğ‘‚(ğ‘šğ‘–ğ‘›{Î”,|ğ‘ƒ|})time for each
ğ‘£âˆˆğ‘(ğ‘£âˆ—(ğ‘ƒ)). Since|ğ‘ƒ|â‰¤2Î”/ğœƒ[20], this time is equivalent
toğ‘‚(|ğ‘ƒ|). So the total time to compute all such neighbors
ofğ‘£âˆ—(ğ‘ƒ)isğ‘‚(Î”|ğ‘ƒ|). This time is equivalent to ğ‘‚(Î”ğœ‰ğº)since
|ğ‘ƒ|isğ‘‚(ğœ‰ğº)as per Corollary 1. Thus, the time required to
find each such node ğ‘¢isğ‘‚(Î”ğœ‰ğº/ğ‘˜)whereğ‘˜is the number
of such nodes. Since ğ‘˜â‰¥1(because otherwise ğ‘ƒwould be a
maximal pseudo-clique), we simply count the upper bound
ğ‘‚(Î”ğœ‰ğº)as the time spent to find each such node.
The recur-basic algorithm takes each of these nodes and calls it-
self on each extension ğ‘„=ğ‘ƒâˆª{ğ‘¢}ofğ‘ƒ(lines 10 â€“ 12 of Algorithm 2).
Note that it is computationally expensive to copy a set of nodes and
its corresponding degree tree. So, in the actual implementation, a
global set of nodes ğ‘ƒand its degree tree ğ‘‡is maintained. Whenever
ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘Ÿâˆ’ğ‘ğ‘ğ‘ ğ‘–ğ‘(ğº,ğ‘„,ğ‘¢,ğ·)is called (respectively, returned), ğ‘¢is added
with (respectively, deleted from) ğ‘ƒ, and its neighborsâ€™ degrees are
updated in the degree tree ğ‘‡. No update is required for all the other
nodesğ‘¤âˆ‰ğ‘(ğ‘¢)sinceğ‘‘ğ‘’ğ‘”ğ‘ƒ(ğ‘¤)remains the same. Thus, this update
operation takes ğ‘‚(Î”ğ‘™ğ‘”ğ‘‰)time in each call of recur-basic.
So, the total time spent by recur-basic algorithm for generat-
ing (done by getChildrenPseudoClq ) and processing each pseudo-
clique isğ‘‚(Î”(ğ‘™ğ‘”ğ‘‰+ğœ‰ğº)). Assuming there are ğ‘ğœƒ-pseudo-cliques in
the input graph (therefore, ğ‘treenodes in the reverse-search tree),
the total time complexity of PCE is ğ‘‚(ğ‘Î”(ğ‘™ğ‘”ğ‘‰+ğœ‰ğº))which is
ğ‘‚(2|ğ‘‰|Î”(ğ‘™ğ‘”ğ‘‰+ğœ‰ğº)), in the worst case.
 
2490