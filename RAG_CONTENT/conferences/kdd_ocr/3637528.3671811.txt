An Efficient Local Search Algorithm for Large GD Advertising
Inventory Allocation with Multilinear Constraints
Xiang He
hexiang@ios.ac.cn
Key Laboratory of System Software
(Chinese Academy of Sciences) and
State Key Laboratory of Computer
Science, Institute of Software, Chinese
Academy of Sciences
Beijing, China
School of Computer Science and
Technology, University of Chinese
Academy of Sciences
Beijing, ChinaWuyang Mao
wuyang.mwy@alibaba-inc.com
Alibaba Group
Beijing, ChinaZhenghang Xu
zhenghangxu97@gmail.com
Key Laboratory of Symbolic
Computation and Knowledge
Engineering Ministry of Education,
Jilin University
Changchun, China
Yuanzhe Gu
guyuanzhe1996@gmail.com
Alibaba Group
Hangzhou, ChinaYundu Huang
yundu.hyd@alibaba-inc.com
Alibaba Group
Beijing, ChinaZhonglin Zu
zhonglin.zuzl@alibaba-inc.com
Alibaba Group
Hangzhou, China
Liang Wang
liangbo.wl@alibaba-inc.com
Alibaba Group
Beijing, ChinaMengyu Zhao
zhaomy@ios.ac.cn
Key Laboratory of System Software
(Chinese Academy of Sciences) and
State Key Laboratory of Computer
Science, Institute of Software, Chinese
Academy of Sciences
Beijing, China
School of Computer Science and
Technology, University of Chinese
Academy of Sciences
Beijing, ChinaMengchuan Zouâˆ—
zoumc@ios.ac.cn
Key Laboratory of System Software
(Chinese Academy of Sciences) and
State Key Laboratory of Computer
Science, Institute of Software, Chinese
Academy of Sciences
Beijing, China
ABSTRACT
The Guaranteed Delivery (GD) advertising is a crucial component
of the online advertising industry, and the allocation of inventory
in GD advertising is an important procedure that influences di-
rectly the ability of the publisher to fulfill the requirements and
increase its revenues. Nowadays, as the requirements of advertisers
become more and more diverse and fine-grained, the focus ratio
requirement, which states that the portion of allocated impres-
sions of a designated contract on focus media among all possible
media should be greater than another contract, often appears in
âˆ—Corresponding Author
This work is licensed under a Creative Commons Attribution-
NonCommercial International 4.0 License.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s).
ACM ISBN 979-8-4007-0490-1/24/08.
https://doi.org/10.1145/3637528.3671811business scenarios. However, taking these requirements into ac-
count brings hardness for the GD advertising inventory allocation
as the focus ratio requirements involve non-convex multilinear
constraints. Existing methods which rely on the convex properties
are not suitable for processing this problem, while mathematical
programming or constraint-based heuristic solvers are unable to
produce high-quality solutions within the time limit. Therefore,
we propose a local search framework to address this challenge. It
incorporates four new operators designed for handling multilinear
constraints and a two-mode algorithmic architecture. Experimental
results demonstrate that our algorithm is able to compute high-
quality allocations with better business metrics compared to the
state-of-the-art mathematical programming or constraint based
heuristic solvers. Moreover, our algorithm is able to handle the
general multilinear constraints and we hope it could be used to
solve other problems in GD advertising with similar requirements.
CCS CONCEPTS
â€¢Information systems â†’Computational advertising.
 
1040
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Xiang He et al.
KEYWORDS
Guaranteed Delivery Advertising, Inventory Allocation, Focus Ratio
Requirements, Integer Multilinear Programming, Local Search
ACM Reference Format:
Xiang He, Wuyang Mao, Zhenghang Xu, Yuanzhe Gu, Yundu Huang, Zhonglin
Zu, Liang Wang, Mengyu Zhao, and Mengchuan Zou. 2024. An Efficient
Local Search Algorithm for Large GD Advertising Inventory Allocation
with Multilinear Constraints. In Proceedings of the 30th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining (KDD â€™24), August
25â€“29, 2024, Barcelona, Spain. ACM, New York, NY, USA, 10 pages. https:
//doi.org/10.1145/3637528.3671811
1 INTRODUCTION
Guaranteed delivery advertising is a crucial component of the on-
line advertising industry, which assumes a pivotal role in online
commerce marketing and promotion for brands. The allocation
of impression inventory to contracts stays as a key component of
this process. As depicted in Figure 1, in typical GD procedures, the
contract is signed months before the advertising campaign, the
advertiser places an order on the publisherâ€™s commercial platform,
while the latter needs to return available advertising results within
a few minutes. To fulfill the agreement, publishers must possess
the ability to make plans for the inventory of ad impressions and
allocate them to different advertisers adhering to various objectives
and constraints. The core technological capabilities of the publisher
significantly influence the sales of advertising and its ability to meet
contractual obligations. The failure to fulfill these contracts or low-
quality allocations could lead to subpar marketing performance for
advertisers and a decrease in revenue for publishers.
In previous advertising inventory allocation studies, the prob-
lems only contain linear constraints, and are formulated as linear
programs [ 10]. Although mathematical programming solvers are
widely-used tools for solving general linear programs, in ad allo-
cation scenarios, the inputs are usually of large-scale and those
solvers typically cannot provide solutions within a few minutes,
which is the timeframe required for commercial needs. On the other
hand, in real applications, it is usually not necessary to achieve the
optimal solution to the problem, but obtain an approximate optimal
solution [ 35]. Consequently, inexact methods such as algorithms
leveraging duality and KKT conditions, were employed to rapidly
address the problem, including algorithms like NLS, RAP [ 26,35].
However, these algorithms rely on the linearity or convexity of the
problemâ€™s constraints, thereby they are only able to handle linear
or convex constraints.
With the growing expansion of commercial demands, more and
more fine-grained requirements are raised, some types of them state
nonlinear relationships and are indeed non-convex constraints in
the mathematical form. Assume an advertiser has two products, a
skin essence and an earphone, and designates a beauty app as the
focus media of skin essence compared to earphone. The advertiser
intends to make the impressions of the skin essence be more focused
on the beauty app than the earphone. As in Figure 2, if the advertiser
demand 1000 impressions for the skin essence and 300 for the
earphone, and if for the skin essence we allocate 300 on the beauty
app and 700 on other media, and for the earphone we allocate 200
on the beauty app and 100 on other media. Then although the
Figure 1: The system architecture for GD advertising.
amount of allocations of skin essence is more than the earphone on
the beauty app (300 v.s. 200), the portion of the impressions of the
skin essence allocated on the beauty app is much smaller than that
of the earphone (300/1000 v.s. 200/300). This allocation is regarded
as irrational and is required to be avoided by the advertiser, as
the advertiser hope the portion of allocation on the beauty app
among all allocations of the skin essence be larger than that of
the earphone, to make his impressions be more concentratedly
allocated on suitable media.
Figure 2: An allocation plan violates advertiserâ€™s requirement
We call this type of requirements as focus ratio requirements,
since they involve the ratio between the amount of allocated im-
pressions of a product on focus media and all possible media, which
is referred to as the focus ratio. Specifically, those requirements are
addressing to the priority relationship of focus ratio between two
contracts (products) and could be raised from the estimations on the
CTR of different products on different media [ 11]. Moreover, the sit-
uation in practical business scenarios is usually more complex than
in the above example, where there may be multiple requirements
from different advertisers and between different products, also the
focus media could be a set of media rather than a specific media. In
addition, similar requirements also have appeared on other perfor-
mance indicators. These requirements are naturally formulated as
multilinear constraints which are non-convex. We pay attention to
the focus ratio requirements, as they are highly demanded and con-
firmed requirements in our business scenarios. We hope to study it
as a starting point for similar multilinear requirements.
As the efficiency or capability of existing solvers and methods are
not enough to handle these constraints in business scenarios. This
 
1041An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
necessitates the exploration of novel technologies and algorithms
to solve these problems effectively. In this paper, we employ a
lightweight local search algorithm technique to efficiently address
GD advertising inventory allocation problems that involve non-
convex multilinear constraints.
1.1 Related works
The guaranteed delivery advertising represents a challenging prob-
lem in the advertising industry and has inspired many research
developments. In general, the guaranteed delivery advertising con-
tains selling and serving phases. The selling phase decides the
allocation of inventory to advertisers (offline allocation) and the
serving phase executes the allocation plan to users in real-time
(online allocation).
In recent years, research on contract advertising mainly focus
on the serving phase (implemented by a serving system, as in Fig-
ure 1), which serves ads in real-time when an actual user request
arrives by determining which of the thousands of eligible contracts
should be displayed for each opportunity in split-second latency.
An important class of algorithms of serving process are online
algorithms, such as algorithms based on stochastic arrival mod-
els [3,16,25,27]. A collection of algorithms is proposed based on
impressions [2, 5, 12, 15, 20], some of which leverage duality such
as HWM, SHALE [ 6,10] to rapidly finished advertising allocation.
In comparison to the serving phase, there has been relatively
little research on the inventory allocation problem in the selling
phase (by a selling system, as in Figure 1). Recently, a Lagrangian
dual algorithm has been introduced for the selling stage, facilitating
the rapid resolution of large-scale inventory allocation problems
with linear constraints [ 35]. Some works considered fairness in ad
allocations and the quality of advertisements [ 11,14] but didnâ€™t take
into account the specific contract requirements from the advertisers
which contain multilinear constraints, as focus ratio requirement.
Meanwhile, there is limited research on problems with non-convex
constraints and mathematical programming or constraint-based
heuristic solvers such as Gurobi [19], SCIP [1] and Yuck [8], often
have relatively slow convergence speeds and in general cannot
meet the demands of commercial advertising problems.
Local search algorithms play an important role in solving NP-
hard combinatorial problems [ 17,18,21,22,24,29â€“32,34]. These
algorithms apply modifications to the current solution iteratively
to quickly find high-quality solutions to large-scale problems. How-
ever, rare works study the local search for combinatorial problems
with multilinear constraints, the only work we found is the local
search for SMT on Multilinear Real Arithmetic [ 23], which is a
verification problem without an optimization objective. To the best
of our knowledge, there hasnâ€™t been any local search algorithm
dedicated to solving integer multilinear optimization problem.
1.2 Our Contributions
In this work, we propose a novel approach to address the GD ad-
vertising inventory allocation problem, including the following:
(1) We introduce the inventory allocation problem with the focus
ratio requirement for the very first time and we build its mathe-
matical formulation as an integer programming problem involving
multilinear constraints.(2) We design a lightweight local search solver, LS-IMP, to solve
the problem. We propose four new neighborhood operators to
handle the multilinear constraints and two switching modes to
quickly find approximately optimal solutions to the problem. Our
solver can easily handle general multilinear constraints in business
scenarios, including but not limited to the focus ratio constraint.
(3) We perform experiments on GD inventory allocation with our
solver, on the real online advertising application data. Experimental
results demonstrate that our solver computes allocations that fulfill
the requirements on more instances and with better quality on
business metrics, outperforming mathematical programming or
constraint-based heuristic solvers.
2 PROBLEM MODELING
2.1 GD Advertising Inventory Allocation with
Focus Ratio Requirements
The GD advertising inventory allocation problem is to compute the
maximum possible impression for the new contract while ensuring
the impression amounts satisfy the constraints imposed by the
publisher, and the demand of advertisers.
Figure 3: Bipartite graph model of GD advertising allocation
The problem can be described using the bipartite graph as shown
in Figure 3. On the left side, supply nodes set ğ´correspond to
impressions of basic dimensions (city Ã—mediaÃ—operating system).
On the right side, demand nodes set ğµcorrespond to the contracts
in the selling system. Where demand node 0represents the new
contract while the other demand nodes ğ‘âˆˆğµ,ğ‘â‰¥1represent
existing contracts. Decision variables ğ‘¥ğ‘ğ‘represent the amount of
impression allocated from supply ğ‘to demandğ‘. The problem aims
to decideğ‘¥ğ‘ğ‘to maximize the impression allocated for the new
contract and satisfy three types of constraints:
(1) Supply constraint: the total allocation amount for each supply
node should not exceed its supply capacity;
(2) Demand constraints: the amount of impressions allocated to
a demand node should not be less than its demand;
(3) Focus ratio constraints: the focus ratio of a contract must
be not less than another contract on focus media. This constraint
 
1042KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Xiang He et al.
involves pairs of two contracts ğ‘Ÿandğ‘ of the same advertiser and
a selection of a specified media set ğ¾ğ‘Ÿğ‘ , representing the focus
media ofğ‘Ÿcompared to ğ‘ . Then the focus ratio of contracts ğ‘Ÿand
ğ‘ on the supply set ğ¾ğ‘Ÿğ‘ are required to fit the advertiserâ€™s priority
requirement: the focus ratio of contract ğ‘Ÿonğ¾ğ‘Ÿğ‘ should be greater
than that of contract ğ‘ .
We use an adjacency matrix ğ‘´=[ğ‘€ğ‘ğ‘]ğ‘âˆˆğ´,ğ‘âˆˆğµ,ğ‘€ğ‘ğ‘âˆˆ{0,1}
to denote connections between supply nodes and demand nodes,
ğ‘€ğ‘ğ‘=1if there exists a connection between supply node ğ‘and
demand node ğ‘.
The multilinear programming formulation of our problem could
be described as the following:
maxâˆ‘ï¸
ğ‘âˆˆğ´ğ‘€ğ‘0ğ‘¥ğ‘0 (1)
s.t.âˆ‘ï¸
ğ‘âˆˆğµğ‘€ğ‘ğ‘ğ‘¥ğ‘ğ‘â‰¤capacity(ğ‘),âˆ€ğ‘âˆˆğ´ (2)
âˆ‘ï¸
ğ‘âˆˆğ´ğ‘€ğ‘ğ‘ğ‘¥ğ‘ğ‘â‰¥demand(ğ‘),âˆ€ğ‘âˆˆğµ,ğ‘â‰ 0 (3)
Ã
ğ‘˜âˆˆğ¾ğ‘Ÿğ‘ ğ‘€ğ‘˜ğ‘Ÿğ‘¥ğ‘˜ğ‘ŸÃ
ğ‘âˆˆğ´ğ‘€ğ‘ğ‘Ÿğ‘¥ğ‘ğ‘Ÿâ‰¥Ã
ğ‘˜âˆˆğ¾ğ‘Ÿğ‘ ğ‘€ğ‘˜ğ‘ ğ‘¥ğ‘˜ğ‘ Ã
ğ‘âˆˆğ´ğ‘€ğ‘ğ‘ ğ‘¥ğ‘ğ‘ ,âˆ€ğ‘Ÿ,ğ‘ âˆˆğµ (4)
ğ‘¥ğ‘ğ‘âˆˆN,âˆ€ğ‘âˆˆğ´,ğ‘âˆˆğµ (5)
Here the objective function is the allocated impressions for the
new contract, and the Supply constraints, Demand constraints and
Focus ratio constraints are formulated as Formula (2) to (4). We
then show that our problem fits the general IMP form.
2.2 Integer Multilinear Programming
The general form of an integer multilinear programming (IMP)
problem is as follows:
ğ‘€ğ‘–ğ‘›ğ‘–ğ‘šğ‘–ğ‘§ğ‘’ ğ’„ğ‘‡ğ’™
ğ‘ ğ‘¢ğ‘ğ‘—ğ‘’ğ‘ğ‘¡ğ‘¡ğ‘œ ğ¹(ğ’™)â‰¤ğ’ƒ
ğ’™ğ‘™â‰¤ğ’™â‰¤ğ’™ğ‘¢
ğ’™âˆˆZğ‘›(6)
where ğ’ƒâˆˆRğ‘š,ğ’„âˆˆRğ‘›,ğ’™ğ‘™âˆˆ(Zâˆªâˆ’âˆ)ğ‘›,ğ’™ğ‘¢âˆˆ(Zâˆª+âˆ)ğ‘›are
inputs and ğ’™the decision variable. ğ¹(ğ’™)is multilinear meaning the
highest exponent of any variable is 1[13].
We denote the ğ‘–-th constraint in the constraint system ğ¹(ğ’™)â‰¤ğ’ƒ
byğ‘ğ‘œğ‘›ğ‘–:ğ¹ğ‘–(ğ’™)â‰¤ğ‘ğ‘–. The variablesâ€™ bounds are denoted as ğ’™ğ‘™â‰¤
ğ’™â‰¤ğ’™ğ‘¢and we denote ğ‘ğ‘‘(ğ‘¥ğ‘¡)=[ğ‘¥ğ‘™
ğ‘¡,ğ‘¥ğ‘¢
ğ‘¡]. Note that in our problem,
ğ‘¥ğ‘™=0andğ‘¥ğ‘¢is the capacity for its corresponding supply node.
Given a variable ğ‘¥ğ‘¡, every constraint could be written as:
ğ‘ğ‘œğ‘›ğ‘–=ğ»(ğ‘–,ğ‘¥ğ‘¡)Â·ğ‘¥ğ‘¡+ğ¼(ğ‘–,ğ‘¥ğ‘¡)â‰¤ğ‘ğ‘– (7)
whereğ»(ğ‘–,ğ‘¥ğ‘¡)is the coefficient polynomial of ğ‘¥ğ‘¡inğ‘ğ‘œğ‘›ğ‘–, andğ¼(ğ‘–,ğ‘¥ğ‘¡)
is the intercept polynomial of ğ‘¥ğ‘¡inğ‘ğ‘œğ‘›ğ‘–. Intuitively, if we regard
onlyğ‘¥ğ‘¡as a variable, then ğ»(ğ‘–,ğ‘¥ğ‘¡)is the coefficient of ğ‘¥ğ‘¡and the
ğ¼(ğ‘–,ğ‘¥ğ‘¡)are monomials that do not contain ğ‘¥ğ‘¡.
It is easy to see our problem in Formula (1) to (5) could be
transformed into the general IMP form since linear constraints
are multilinear and the focus ratio constraints are equivalent toÃ
ğ‘˜âˆˆğ¾ğ‘Ÿğ‘ ğ‘€ğ‘˜ğ‘Ÿğ‘¥ğ‘˜ğ‘ŸÂ·Ã
ğ‘âˆˆğ´ğ‘€ğ‘ğ‘ ğ‘¥ğ‘ğ‘ âˆ’Ã
ğ‘âˆˆğ´ğ‘€ğ‘ğ‘Ÿğ‘¥ğ‘ğ‘ŸÂ·Ã
ğ‘˜âˆˆğ¾ğ‘Ÿğ‘ ğ‘€ğ‘˜ğ‘ ğ‘¥ğ‘˜ğ‘ â‰¥0
that is multilinear.In the following, we consider our problem in the form of For-
mula (6). A complete assignment (referred to as â€œassignment" for
short)ğ›¼for an IMP instance ğ‘„is a mapping that assigns to each
variable an integer, and ğ›¼(ğ‘¥ğ‘Ÿ)denotes the value of ğ‘¥ğ‘Ÿunderğ›¼. An
assignment ğ›¼satisfies the constraint ğ‘ğ‘œğ‘›ğ‘–ifğ‘ğ‘œğ‘›ğ‘–(ğ›¼)â‰¤ğ‘ğ‘–, other-
wise the constraint is violated. An assignment ğ›¼is feasible if and
only if it satisfies all constraints in ğ‘„. The value of the objective
function ofğ›¼is denoted as ğ‘œğ‘ğ‘—(ğ›¼). Also, we denote ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))the
value of coefficient polynomial of ğ‘¥ğ‘¡inğ‘ğ‘œğ‘›ğ‘–with assignment ğ›¼, and
ğ›¼(ğ¼(ğ‘–,ğ‘¥ğ‘¡))for the intercept polynomial respectively.
3 LS-IMP: OUR LOCAL SEARCH ALGORITHM
We introduce each component and the routine of our algorithm. The
key innovations enabling our algorithm to address GD advertising
inventory allocation with multilinear constraints, consisting of four
new operators in the local search process. Moreover, we design a
two-mode architecture of our algorithm to help the algorithm find
high-quality solutions.
3.1 Operators Treating Multilinear Constraints
In the local search algorithm, an operator defines how to modify
variables to generate new assignments, when an operator is in-
stantiated with a variable, we obtain an operation. A local search
algorithm progressively takes operations to generate new assign-
ments and tracks the best assignment obtained.
We present four new operators for general integer multilinear
programs, including three single-variable operators and one pair-
variable operator. They are designed to handle unsatisfied con-
straints or optimize the objective function which will be used in
different modes in our algorithm.
3.1.1 Multilinear Critical Move. Our multilinear critical move oper-
ator considers modifying variables in violated constraints towards
making them satisfied. The multilinear critical move modifies the
variableâ€™s value to the boundary value that makes the literal true.
We define the multilinear critical move operator:
Definition 3.1. The multilinear critical move operator ğ‘šğ‘(ğ‘¥ğ‘˜,ğ‘ğ‘œğ‘›ğ‘–
,ğ›¼), takes an assignment ğ›¼and assigns an integer variable ğ‘¥ğ‘˜to the
threshold value ğ‘£ğ‘˜making violated constraint ğ‘ğ‘œğ‘›ğ‘–satisfied and
keeping the global bound of ğ‘£ğ‘˜satisfied, where ğ‘ğ‘œğ‘›ğ‘–is a violated
constraint containing ğ‘¥ğ‘˜.
The multilinear critical move could be constructed in the follow-
ing way: given a violated multilinear constraint ğ‘ğ‘œğ‘›ğ‘–, variableğ‘¥ğ‘¡âˆˆ
ğ‘ğ‘œğ‘›ğ‘–, we knowğ‘ğ‘œğ‘›ğ‘–=ğ»(ğ‘–,ğ‘¥ğ‘¡)Â·ğ‘¥ğ‘¡+ğ¼(ğ‘–,ğ‘¥ğ‘¡)â‰¤ğ‘ğ‘–by Formula (7). Un-
der an assignment ğ›¼, we denote Î”=ğ›¼(ğ¼(ğ‘–,ğ‘¥ğ‘¡))+ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))Â·ğ›¼(ğ‘¥ğ‘¡)âˆ’ğ‘ğ‘–
ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡)),
ağ‘šğ‘(ğ‘¥ğ‘¡,ğ‘ğ‘œğ‘›ğ‘–,ğ›¼)operator for ğ‘¥ğ‘¡is:
â€¢ifğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))<0andğ›¼(ğ‘¥ğ‘¡)+|âŒŠÎ”âŒ‹|âˆˆğ‘ğ‘‘(ğ‘¥ğ‘¡):ğ‘šğ‘(ğ‘¥ğ‘¡,ğ‘ğ‘œğ‘›ğ‘–,ğ›¼)
increasesğ›¼(ğ‘¥ğ‘¡)by|âŒŠÎ”âŒ‹|.
â€¢ifğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))>0andğ›¼(ğ‘¥ğ‘–)âˆ’|âŒˆÎ”âŒ‰|âˆˆğ‘ğ‘‘(ğ‘¥ğ‘¡):ğ‘šğ‘(ğ‘¥ğ‘¡,ğ‘ğ‘œğ‘›ğ‘–,ğ›¼)
decreasesğ›¼(ğ‘¥ğ‘¡)by|âŒˆÎ”âŒ‰|.
â€¢otherwise:ğ›¼stay unchanged.
Example 3.2. Given two violated constraints: ğ‘ğ‘œğ‘›1=(ğ‘¥1âˆ’ğ‘¥2â‰¤
âˆ’2),ğ‘ğ‘œğ‘› 2=(ğ‘¥1ğ‘¥2âˆ’ğ‘¥3ğ‘¥4â‰¤âˆ’2). All variables have a lower bound of
0 and the current assignment is ğ›¼={ğ‘¥1=0,ğ‘¥2=0,ğ‘¥3=1,ğ‘¥4=1}.
There exist three multilinear critical move operations: ğ‘šğ‘(ğ‘¥2,ğ‘¥1âˆ’
 
1043An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
ğ‘¥2â‰¤âˆ’2,ğ›¼),ğ‘šğ‘(ğ‘¥3,ğ‘¥1ğ‘¥2âˆ’ğ‘¥3ğ‘¥4â‰¤âˆ’2,ğ›¼)andğ‘šğ‘(ğ‘¥4,ğ‘¥1ğ‘¥2âˆ’ğ‘¥3ğ‘¥4â‰¤
âˆ’2,ğ›¼), referring to assigning ğ‘¥2to2,ğ‘¥3to2, andğ‘¥4to2respectively.
3.1.2 Bound Move Operator. The bound move operator considers
optimizing the objective function when all constraints are satisfied.
The basic idea of reducing the value of the objective function is
to change the values of the variables within it. Let ğ½be the set of
variables that appear in the objective function, i.e. ğ½={ğ‘¥ğ‘¡|ğ‘ğ‘¡â‰ 
0,âˆ€ğ‘¡}, whereğ‘ğ‘¡is the coefficient of ğ‘¥ğ‘¡inğ’„ğ‘‡ğ’™. The idea of the bound
move operator is to move the variable towards its upper bound or
lower bound according to its coefficient in the objective function,
which will result in the most rapid decrease in the objective function.
We design the bound move operator denoted as ğ‘ğ‘š(ğ‘¥,ğ›¼)as follows:
â€¢ifğ‘ğ‘¡<0, thenğ‘ğ‘š(ğ‘¥ğ‘¡,ğ›¼)assignğ‘¥ğ‘¡to its upper bound.
â€¢ifğ‘ğ‘¡>0, thenğ‘ğ‘š(ğ‘¥ğ‘¡,ğ›¼)assignğ‘¥ğ‘¡to its lower bound.
3.1.3 Reduce Move Operator. Similar to the role of bound move,
reduce move also aims to optimize the objective function. In some
cases, setting a variable to its global bound may lead to more con-
straints being violated. For variables within the objective function,
bound move pays attention to their bounds, while reduce move fo-
cuses on the constraints they are subject to. For a variable ğ‘¥ğ‘¡âˆˆğ½and
a satisfied constraint ğ‘ğ‘œğ‘›ğ‘–that contains ğ‘¥ğ‘¡, we design reduce move
operator to both maintain the satisfied state of ğ‘ğ‘œğ‘›ğ‘–and achieve
the reduction in the value of the objective function.
Definition 3.3. The reduce move operator, represented as ğ‘Ÿğ‘‘(ğ‘¥ğ‘¡,
ğ‘ğ‘œğ‘›ğ‘–,ğ›¼), assigns an integer variable ğ‘¥âˆˆğ½to a threshold value which
both make the constraint ğ‘ğ‘œğ‘›ğ‘–remains satisfied while achieving
the maximum reduction in the value of objective function without
violatingğ‘¥ğ‘¡â€™s upper or lower bounds.
Given a variable ğ‘¥ğ‘¡âˆˆğ½and its associated satisfied constraint
ğ‘ğ‘œğ‘›ğ‘–,ğ‘ğ‘œğ‘›ğ‘–=ğ»(ğ‘–,ğ‘¥ğ‘¡)Â·ğ‘¥ğ‘¡+ğ¼(ğ‘–,ğ‘¥ğ‘¡)â‰¤ğ‘ğ‘–. Under an assignment ğ›¼, we
denote Î”=ğ‘ğ‘–âˆ’ğ›¼(ğ¼(ğ‘–,ğ‘¥ğ‘¡))âˆ’ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))Â·ğ›¼(ğ‘¥ğ‘¡)
ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡)), ağ‘Ÿğ‘‘(ğ‘¥ğ‘¡,ğ‘ğ‘œğ‘›ğ‘–,ğ›¼)opera-
tor forğ‘¥ğ‘–is:
â€¢ğ‘ğ‘¡<0,ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))>0,ğ›¼(ğ‘¥ğ‘¡)+|âŒŠÎ”âŒ‹|âˆˆğ‘ğ‘‘(ğ‘¥ğ‘¡): increase
ğ›¼(ğ‘¥ğ‘¡)by|âŒˆÎ”âŒ‰|, which leads to the most significant decrease
in the value of the objective function.
â€¢ğ‘ğ‘¡>0,ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))<0,ğ›¼(ğ‘¥ğ‘¡)âˆ’|âŒˆÎ”âŒ‰|âˆˆğ‘ğ‘‘(ğ‘¥ğ‘¡): decrease
ğ›¼(ğ‘¥ğ‘¡)by|âŒˆÎ”âŒ‰|, which leads to the most significant decrease
in the value of the objective function.
â€¢otherwise:ğ›¼stay unchanged.
Example 3.4. Consider an instance ğ‘šğ‘–ğ‘› :âˆ’ğ‘¥1âˆ’ğ‘¥2, s.t.ğ‘ğ‘œğ‘›1=
(ğ‘¥2+ğ‘¥4â‰¤2),ğ‘ğ‘œğ‘› 2=(ğ‘¥1ğ‘¥3âˆ’ğ‘¥3ğ‘¥4â‰¤2). Given the current assign-
ment isğ›¼={ğ‘¥1=1,ğ‘¥2=1,ğ‘¥3=1,ğ‘¥4=0}. There exist three reduce
move operations: ğ‘Ÿğ‘‘(ğ‘¥1,ğ‘¥1ğ‘¥2âˆ’ğ‘¥3ğ‘¥4â‰¤2,ğ›¼),ğ‘Ÿğ‘‘(ğ‘¥2,ğ‘¥2+ğ‘¥4â‰¤2,ğ›¼)
referring to assigning ğ‘¥1to2andğ‘¥2to2respectively.
3.1.4 Propel Move Operator. Regardless of whether itâ€™s a bound
move or reduce move, the operator is linked to variables in the
objective function. However, certain variables might not directly
influence the objective function if they donâ€™t appear in it. Yet, if
these variables share constraints with those within the objective
function, they can impact the variable range by altering their values,
subsequently affecting the objective function.
Example 3.5. Consider an instance ğ‘šğ‘–ğ‘› :âˆ’ğ‘¥1âˆ’ğ‘¥5, s.t.ğ‘ğ‘œğ‘›1=
(ğ‘¥2+ğ‘¥4â‰¤2),ğ‘ğ‘œğ‘› 2=(ğ‘¥1ğ‘¥2âˆ’ğ‘¥3ğ‘¥4â‰¤2),ğ‘ğ‘œğ‘›3=(ğ‘¥3+ğ‘¥5â‰¤2).Given the current assignment ğ›¼={ğ‘¥1=1,ğ‘¥2=1,ğ‘¥3=1,ğ‘¥4=
1,ğ‘¥5=0}, forğ‘¥1inğ‘ğ‘œğ‘›2, to maintain the satisfiability of constraint
ğ‘ğ‘œğ‘›2, the range of values for ğ‘¥1is the interval[âˆ’âˆ,2+ğ‘¥3Â·ğ‘¥4
ğ‘¥2]. If
other variables are held constant while only changing the value of
ğ‘¥1, then the range of values for ğ‘¥1is[âˆ’âˆ,3]. However, if ğ‘¥3is also
simultaneously moved from 1 to 2, constraint ğ‘ğ‘œğ‘›3which contains
ğ‘¥3is still satisfied, while the range of values for ğ‘¥1will be[âˆ’âˆ,4]
to satisfyğ‘ğ‘œğ‘›2, thereby increasing the magnitude of the ascent in
ğ‘¥1and decrease the objective.
Next, we intend to formally define and search for a pair of vari-
ables, similar to ğ‘¥1andğ‘¥3in the example above, along with the
corresponding operator.
Definition 3.6. Valid auxiliary constraint. Given an assignment
ğ›¼and a variable ğ‘¥ğ‘¡, we say constraint ğ‘ğ‘œğ‘›ğ‘–is a valid auxiliary
constraint for ğ‘¥ğ‘¡ifğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))Â·ğ‘ğ‘¡<0.
Theğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))Â·ğ‘ğ‘¡<0indicates that the auxiliary constraint
limitsğ‘¥ğ‘¡to move in the direction of decreasing the objective. We
define the valid range ofğ‘¥ğ‘¡in constraint ğ‘ğ‘œğ‘›ğ‘–the range that ğ‘¥ğ‘¡
can move and keeps ğ‘ğ‘œğ‘›ğ‘–satisfied. For multilinear constraints, this
range is an interval. Now we are to identify the variables that will
make it possible to change the valid range of ğ‘¥ğ‘¡in the auxiliary
constraint.
Definition 3.7. Valid auxiliary variable. Given an assignment ğ›¼,
for anyğ‘¥ğ‘¡âˆˆğ½, a variableğ‘¥ğ‘¢,ğ‘¢â‰ ğ‘¡is a valid auxiliary variable for
ğ‘¥ğ‘¡, ifğ‘¥ğ‘¢satisfy following conditions: (1) ğ‘¥ğ‘¢âˆ‰ğ½(2)âˆƒğ‘ğ‘œğ‘›ğ‘–thatğ‘ğ‘œğ‘›ğ‘–
is a valid auxiliary constraint for ğ‘¥ğ‘¡, bothğ‘¥ğ‘¡andğ‘¥ğ‘¢appear inğ‘ğ‘œğ‘›ğ‘–.
Intuitively, since ğ‘¥ğ‘¢andğ‘¥ğ‘¡are within the same constraint, the
value ofğ‘¥ğ‘¢might affect the valid range of ğ‘¥ğ‘¡inğ‘ğ‘œğ‘›ğ‘–. Now we try to
find the value of ğ‘¥ğ‘¢that enlarges the valid range of ğ‘¥ğ‘¡inğ‘ğ‘œğ‘›ğ‘–. Since
the valid range of ğ‘¥ğ‘¡is an interval, its endpoints are monotone with
the change of value of ğ‘¥ğ‘¢. Therefore, we desire the alteration of ğ‘¥ğ‘¢
to be as large as possible. For this reason, we define the value by
whichğ‘¥ğ‘¢should change as follows:
Definition 3.8. Auxiliary value. Given an assignment ğ›¼, for any
ğ‘¥ğ‘¢and its associated ğ‘ğ‘œğ‘›ğ‘—s.t.ğ‘¥ğ‘¢âˆˆğ‘ğ‘œğ‘›ğ‘—, we define the auxiliary
value ofğ‘¥ğ‘¢givenğ‘ğ‘œğ‘›ğ‘—, denote asğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢), to be the value that
makingğ‘ğ‘œğ‘›ğ‘—satisfied and as tight as possible: Precisely, let Î”=
ğ‘ğ‘—âˆ’ğ›¼(ğ¼(ğ‘—,ğ‘¥ğ‘¢))âˆ’ğ›¼(ğ»(ğ‘—,ğ‘¥ğ‘¢))Â·ğ›¼(ğ‘¥ğ‘¢)
ğ›¼(ğ»(ğ‘—,ğ‘¥ğ‘¢)), thenğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢)is computed as
follows:
â€¢ifğ›¼(ğ»(ğ‘—,ğ‘¥ğ‘¢))>0:ğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢)=ğ›¼(ğ‘¥ğ‘¢)+|âŒŠÎ”âŒ‹|.
â€¢ifğ›¼(ğ»(ğ‘—,ğ‘¥ğ‘¢))<0:ğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢)=ğ›¼(ğ‘¥ğ‘¢)âˆ’|âŒˆÎ”âŒ‰|.
The way we define the auxiliary value is from the fact that
tightening the constraints ğ‘ğ‘œğ‘›ğ‘—can maximize the range of change
ofğ‘¥ğ‘¢. Now, we will proceed to calculate whether altering ğ‘¥ğ‘¢can
result in a broader range of movement for ğ‘¥ğ‘¡that decreases the
objective function.
Definition 3.9. Valid propel pair. Given an assignment ğ›¼, an or-
dered pair of variables (ğ‘¥ğ‘¡,ğ‘¥ğ‘¢),ğ‘¡â‰ ğ‘¢is a valid propel pair if
(1)âˆƒğ‘ğ‘œğ‘›ğ‘–s.t.ğ‘¥ğ‘¡,ğ‘¥ğ‘¢âˆˆğ‘ğ‘œğ‘›ğ‘–,ğ›¼(ğ»(ğ‘–,ğ‘¥ğ‘¡))Â·ğ‘ğ‘¡<0.
(2)âˆƒğ‘ğ‘œğ‘›ğ‘—s.t.ğ‘¥ğ‘¡âˆ‰ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢âˆˆğ‘ğ‘œğ‘›ğ‘—,ğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢)âˆˆğ‘ğ‘‘(ğ‘¥ğ‘¢)and
fixingğ‘¥ğ‘¢toğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢)will not change the sign of ğ»ğ›¼(ğ‘–,ğ‘¥ğ‘¡).
(3)ğ‘œğ‘ğ‘—(ğ‘Ÿğ‘‘(ğ‘ğ‘œğ‘›ğ‘–,ğ‘¥ğ‘¡,ğ›¼ğ‘ğ‘¢ğ‘¥))<ğ‘œğ‘ğ‘—(ğ‘Ÿğ‘‘(ğ‘ğ‘œğ‘›ğ‘–,ğ‘¥ğ‘¡,ğ›¼)), whereğ›¼ğ‘ğ‘¢ğ‘¥is
updated by fixing ğ‘¥ğ‘¢toğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢)
 
1044KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Xiang He et al.
Based on the above ideas, the propel move operator is defined
as follows:
Definition 3.10. Propel move operator. Given an assignment ğ›¼, a
propel move operator ğ‘ğ‘š(ğ‘ğ‘œğ‘›ğ‘–,ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¡,ğ‘¥ğ‘¢,ğ›¼)takes a valid propel
pair(ğ‘¥ğ‘¡,ğ‘¥ğ‘¢)with the associated constraint ğ‘ğ‘œğ‘›ğ‘–,ğ‘ğ‘œğ‘›ğ‘—as in the
definition of valid propel pair, the propel move operator fixing the
values ofğ‘¥ğ‘¡,ğ‘¥ğ‘¢as following:
(1) fix the value of ğ‘¥ğ‘¢toğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›ğ‘—,ğ‘¥ğ‘¢), and get a new auxiliary
assignment ğ›¼ğ‘ğ‘¢ğ‘¥.
(2) fix the value of ğ‘¥ğ‘¡by taking ağ‘Ÿğ‘‘(ğ‘ğ‘œğ‘›ğ‘–,ğ‘¥ğ‘¡,ğ›¼ğ‘ğ‘¢ğ‘¥)operation.
Recall the Example 3.5, there is a propel move operator which
is calculated as: compute ğ‘¡ğ‘£ğ›¼(ğ‘ğ‘œğ‘›3,ğ‘¥3), which leads to ğ‘¥3change
from 1 to 2 and get a new auxiliary assignment ğ›¼ğ‘ğ‘¢ğ‘¥; compute
ğ‘Ÿğ‘‘(ğ‘ğ‘œğ‘›2,ğ‘¥1,ğ›¼ğ‘ğ‘¢ğ‘¥)which leads to ğ‘¥1change from 1 to 4.
3.2 Weighting Scheme and Score Function
3.2.1 Weighting Scheme. Weighting scheme can guide the search
in a promising direction. It associates an additional property called
weight (which is an integer number) to constraints and objective
function dynamically adjusts them during the search. The weight
of constraints and the objective function are dynamically adjusted
during the search and are used to compute the score functions.
We denoteğ‘¤(ğ‘ğ‘œğ‘›ğ‘–)for weight of constraint ğ‘–andğ‘¤(ğ‘œğ‘ğ‘—)for the
weight of objective function. ğ‘¤(ğ‘ğ‘œğ‘›ğ‘–)andğ‘¤(ğ‘œğ‘ğ‘—)are initialized
with a weight of 1 and are dynamically updated as follows:
â€¢for violated constraint ğ‘ğ‘œğ‘›ğ‘–,ğ‘¤(ğ‘ğ‘œğ‘›ğ‘–):=ğ‘¤(ğ‘ğ‘œğ‘›ğ‘–)+1;
â€¢ifğ‘œğ‘ğ‘—(ğ›¼)>ğ‘œğ‘ğ‘—âˆ—andğ‘¤(ğ‘œğ‘ğ‘—)<ğœ, thenğ‘¤(ğ‘œğ‘ğ‘—):=ğ‘¤(ğ‘œğ‘ğ‘—)+1,
whereğ‘œğ‘ğ‘—âˆ—is objective value under best found solution, ğœ
limits the maximum value that objective function weight
can get.
3.2.2 Scoring Function. The scoring function is also an important
component of local search algorithms. During the process of local
search, scoring function is employed to compare various operations.
Given the weights of constraints and the objective function, we
design the scoring function as follows:
for the constraint score, consider an operation ğ‘œğ‘changing an
assignment ğ›¼toğ›¼â€², if this operation makes a constraint ğ‘ğ‘œğ‘›ğ‘–from
satisfied to violated, it incurs a score of âˆ’ğ‘¤(ğ‘ğ‘œğ‘›ğ‘–). Conversely, if it
makesğ‘ğ‘œğ‘›ğ‘–from violated to satisfied, it yields a score of ğ‘¤(ğ‘ğ‘œğ‘›ğ‘–).
Definition 3.11. The constraint score of an operator ğ‘œğ‘, denoted
byğ‘ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘œğ‘)is the sum of scores of all constraints caused by
applyingğ‘œğ‘.
For the objective score, if an operation reduces the value of the
objective function, it will be rewarded with ğ‘¤(ğ‘œğ‘ğ‘—). Otherwise, it
will incur a penalty of ğ‘¤(ğ‘œğ‘ğ‘—).
Definition 3.12. The objective score of an operator is denoted
byğ‘œğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘œğ‘).ğ‘œğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘œğ‘)=ğ‘¤(ğ‘œğ‘ğ‘—)(orâˆ’ğ‘¤(ğ‘œğ‘ğ‘—)), if op make the
value of objective function decrease(or increase),
For this problem, we consider that satisfying the constraints and
reducing the objective function are equally important. Therefore,
the score function is defined as follows:
ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘œğ‘)=ğ‘ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘œğ‘)+ğ‘œğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘œğ‘) (8)
Figure 4: Two-modes switching algorithm
Algorithm 1: Infeasible Mode
1whileâˆƒviolated constraints do
2 ifâˆƒdecreasing multilinear critical move in violated
constraints then
3ğ‘œğ‘=a decreasing multilinear critical move with the
greatest score via BMS;
4 else
5 update weights by Weighting Scheme;
6ğ‘ğ‘œğ‘›=a random violated constraint;
7ğ‘œğ‘=a decreasing multilinear critical move with the
greatest score in ğ‘ğ‘œğ‘›via BMS;
8 perform op to modify ğ›¼;
An operation is decreasing if its score is greater than 0. It implies
that performing this operation will lead the search in a promising
direction. If there is no decreasing operation, it indicates that the
algorithm is stuck in a local optimum, and the weighting scheme is
required to be activated.
3.3 Two-Mode Local Search Algorithm
Our algorithm primarily consists of two aims: 1.satisfy all violated
constraints 2. optimize the objective function. Therefore, we design
an algorithm with a two-mode structure: the Infeasible mode and the
Feasible mode, each mode associates with its appropriate operators.
In the Infeasible mode, the algorithm focuses on making violated
constraints satisfied, while in the Feasible mode, the algorithm
emphasizes minimizing the objective function.
The routine of our algorithm is described in Algorithm 3. First,
the best assignment ğ›¼âˆ—and current assignment ğ›¼are initialized
(Line 1). All variables are initialized to their lower bound of 0. Then,
the algorithm iteratively modifies ğ›¼by performing operations on
integer variables. Once variable values change, the satisfaction
status of all constraints might change. As depicted in Figure 4, the
algorithm dynamically switches between two modes as iterations
advance, guided by the satisfaction status of the constraints. At the
end of the time limit, if no feasible solution is found, output NA;
otherwise, output the best solution found.
If there exist violated constraints, then our algorithm enters
Infeasible mode. As described in Algorithm 1, the algorithm first
tries to find decreasing multilinear critical move operation with the
greatest score via BMS heuristic [ 9] (Line 2â€“3). Specifically, the BMS
heuristic samples ğ‘¡operations ( ğ‘¡is a parameter), and selects the
decreasing one with the greatest score. If no decreasing operation
 
1045An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Algorithm 2: Feasible Mode
1whileâˆ€constraints is satisfied do
2 ifâˆƒdecreasing bound move then
3ğ‘œğ‘:=a decreasing bound move with the greatest
score picked by BMS;
4 else ifâˆƒdecreasing reduce move then
5ğ‘œğ‘:=a decreasing reduce move with the greatest
score picked by BMS;
6 else ifâˆƒdecreasing propel move then
7ğ‘œğ‘:=a decreasing propel move with the greatest
score picked by BMS;
8 else
9 update weights by Weighting Scheme;
10ğ‘œğ‘=a random simple move;
11 perform op to modify ğ›¼;
Algorithm 3: Local Search Algorithm
Input: GD advertising instance ğ¹, cutoff time cutoff
Output: A feasible assignment ğ›¼âˆ—ofğ¹andğ‘œğ‘ğ‘—(ğ›¼âˆ—)or NA
1ğ›¼âˆ—:=âˆ…,ğ›¼:=an initial complete assignment;
2while time not exceeds ğ‘ğ‘¢ğ‘¡ğ‘¡ğ‘œğ‘“ğ‘“ do
3 ifğ›¼is feasible and ğ‘œğ‘ğ‘—(ğ›¼)<ğ‘œğ‘ğ‘—âˆ—then
4ğ›¼âˆ—:=ğ›¼, ğ‘œğ‘ğ‘—âˆ—:=ğ‘œğ‘ğ‘—(ğ›¼);
5 ifâˆƒviolated constraints then
6 Enter Infeasible Mode and perform corresponding
operation;
7 else
8 Enter Feasible Mode and perform corresponding
operations;
9ifğ›¼âˆ—is feasible then return (ğ‘œğ‘ğ‘—âˆ—, ğ›¼âˆ—);
10else return NA;
is found, it indicates that the algorithm may reach a local optimum.
The algorithm further escapes from the local optimum in the same
way as WalkSAT-family SAT solvers [ 4,7,30], that is: 1. updates
the weights of the constraints based on the weighting scheme. 2.
randomly selects one of the violated constraints and chooses a
multilinear critical move operation with the greatest score via BMS.
Otherwise, our algorithm enters Feasible mode. The algorithm
in Feasible mode is described in Algorithm 2. In each iteration, the
algorithm first tries to find a decreasing bound move operation
with the greatest score via BMS heuristic (Line 2â€“3). If there exists
no such operation, then we consider the decreasing reduce move
operations and select the one with the greatest score via BMS (Line
4â€“5). If it fails to find any decreasing reduce move, then it continues
to search the neighbourhood of propel move operation (Line 6-7).
If there still exists no decreasing operation. the algorithm further
escapes from the local optimum by updating the weights (Line 9)
and selects a random variable ğ‘¥ğ‘¡âˆˆğ½performing a simple move: if
ğ‘ğ‘¡<0, then increase ğ‘¥ğ‘¡by1, otherwise decrease ğ‘¥ğ‘¡by1(Line 10).4 EXPERIMENTS
In this section, we evaluate our solver LS-IMP with real GD inven-
tory allocation of a company (temporally anonymous for double-
blind review). Experimental results indicate that our algorithm is
efficient and effective on inventory contract allocation problem.
Implementation and Setup: LS-IMP is programmed in C++,
compiled by g++ with â€™-O3â€™ option. There are 2 parameters in the
solver:ğ‘¡the number of samples for the BMS heuristic, ğœfor the
Upper Limit of objective function weight. The parameters are tuned
according to our preliminary experiments and suggestions from
the literature and are set as follows: ğ‘¡=100.ğœ=100.
All experiments are conducted on a server with Intel Xeon Plat-
inum 8153 2.00GHz and 2048G RAM under the system CentOS
7.7.1908. The source code and the detailed results of the experiment
are in the repository1.
Competitors: We compare our solver to two mathematical pro-
gramming solvers, Gurobi 10.0.0 (2022) and SCIP 8.0.1 (2021), that
are the best commercial and best open-source solver in the well-
known mathematical solver rankings [ 28]. In addition to mathemat-
ical programming solvers, we also compare the constraint-based
heuristic solver Yuck, which is the champion of the local search
track in the 2022 and 2023 MiniZinc challenge, a representative
competition of constraint programming solvers [ 33]. We use both
the exact and heuristic versions of Gurobi denoted as Exact and
Heur. SCIP and Yuck is employed with the default parameters.
Datasets: The datasets for experiments come from real GD ad-
vertising inventory allocation of Alibaba company. 5 datasets are
generated by sampling and aggregating real online request data
covering different time periods including regular days and holidays
to encompass a comprehensive range of business scenarios. We
take uniformly random samplings among all populations.
The datasets are shown in Table 1. The table shows the instance
count (#ins), supply node range (Supply), demand node range (De-
mand), and newly introduced multilinear constraint range (ML
Constraint) for each dataset. The datasets used are in the reposi-
tory2.
Table 1: Datasets description
Dataset #ins Supply Demand ML Constraint
D1 200 50âˆ¼100 40âˆ¼50 1000âˆ¼1500
D2 200 50âˆ¼100 20âˆ¼30 1000âˆ¼1500
D3 200 150âˆ¼200 100âˆ¼150 1000âˆ¼1500
D4 200 200âˆ¼250 300âˆ¼400 1000âˆ¼1500
D5 200 700âˆ¼800 40âˆ¼50 1000âˆ¼1500
4.1 Evaluation Metrics
There are 5 metrics in this subsection to be compared:
Inventory utilization rate: denoted as #UR. We denote the total
inventory level at all supply nodes as ğ‘†all, and the total demand
quantity from all orders is denoted as ğ·all. #UR is calculated as:Ã|ğ´|
ğ‘=1ğ‘€ğ‘0ğ‘¥ğ‘0/(ğ‘†allâˆ’ğ·all). A higher #UR leads to a greater number
of advertisements sold and subsequently results in better revenue.
1https://github.com/LS-IMP/-ls-imp
2https://mega.nz/file/sOlk0byD#ahjRxeZJJjKF6IKK0q-r0nqlT8R7ylg8-k24xitSX2k
 
1046KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Xiang He et al.
Ideal inventory fulfilment rate: denoted as #FR. The ideal allo-
cation quantity is denoted as ğ‘‚ğ‘ğ‘—ğ¼ğ‘‘ğ‘’ğ‘ğ‘™ , which equals to the value of
the objective function setting all variables in the objective function
to their upper bounds. #FR is calculated as : (Ã|ğ´|
ğ‘=1ğ‘€ğ‘0ğ‘¥ğ‘0)/ğ‘‚ğ‘ğ‘—ğ¼ğ‘‘ğ‘’ğ‘ğ‘™ .
#FR represents a narrower gap between inventory and optimal in-
ventory, which means selling as many ads as feasible while still
meeting contractual obligations. #FR is desired to be as close to
100% as possible in order to fulfil customer contracts.
Winning solution: denoted as #win, the number of instances
where a solver finds the best solution among all solutions output
by tested solvers. This measures the ability of the algorithm to find
a high-quality allocation in terms of the objective value.
Feasible solution: denoted as #feas, the number of instances
where a solver can find a feasible solution within this time limit.
This measures the number of instances in which a solver finds an
allocation plan that fulfills all requirements.
Solving time: the runtime comparison between LS-IMP and
competitor solvers if both solvers can find a solution with the same
value of the objective function.
4.2 Result Analysis
#UR and #FR analysis: We compared the average #UR and #FR
for each set of instances. The result is shown in Table 2. A selling
instance of GD advertising inventory allocation typically requires a
solving time within 60 seconds in a business scenario. The effective-
ness of SCIP and Yuck in addressing this problem is comparatively
lower, as seen by the lower #UR and #FR metrics observed in the
business solution time.
We have included a comparison between both the heuristic and
exact versions of Gurobi and LS-IMP in Figure 5. Gurobi lags behind
LS-IMP in terms of both the #UR and #FR within the 60-second
business-solving time 60s. To validate and compare the capabilities
of our solver, experiments are also conducted with a solving time
extended to 300 and 1000 seconds, surpassing the business-defined
limit. The experiments reveal that even though Gurobi shows an
increase in the #UR and #FR, LS-IMP is still the most competitive
algorithm. Moreover, the results from the 300-second and 1000-
second solving time show no obvious improvement in either #UR
and #FR compared to the 60-second results with LS-IMP. It sug-
gests that LS-IMP has essentially converged within the 60-second
timeframe, demonstrating the effectiveness of our algorithm.
/uni00000019/uni00000013/uni00000056 /uni00000016/uni00000013/uni00000013/uni00000056 /uni00000014/uni00000013/uni00000013/uni00000013/uni00000056
/uni0000002c/uni00000051/uni00000059/uni00000048/uni00000051/uni00000057/uni00000052/uni00000055/uni0000005c/uni00000003/uni00000058/uni00000057/uni0000004c/uni0000004f/uni0000004c/uni0000005d/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000055/uni00000044/uni00000057/uni00000048/uni00000013/uni00000018/uni00000014/uni00000013/uni00000014/uni00000018/uni00000015/uni00000013/uni00000015/uni00000018/uni00000016/uni00000013/uni00000033/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni00000003/uni0000000b/uni00000008/uni0000000c
/uni00000013/uni00000011/uni00000017/uni00000019/uni00000011/uni00000013/uni00000014/uni00000016/uni00000011/uni00000019
/uni00000014/uni00000011/uni00000017/uni00000015/uni00000011/uni0000001a/uni00000019/uni00000011/uni00000015/uni00000014/uni00000019/uni00000011/uni00000017/uni00000014/uni0000001a/uni00000011/uni00000018 /uni00000014/uni0000001a/uni00000011/uni00000018/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033
(a) #UR
/uni00000019/uni00000013/uni00000056 /uni00000016/uni00000013/uni00000013/uni00000056 /uni00000014/uni00000013/uni00000013/uni00000013/uni00000056
/uni0000002c/uni00000051/uni00000059/uni00000048/uni00000051/uni00000057/uni00000052/uni00000055/uni0000005c/uni00000003/uni00000049/uni00000058/uni0000004f/uni00000049/uni0000004c/uni0000004f/uni0000004f/uni00000050/uni00000048/uni00000051/uni00000057/uni00000003/uni00000055/uni00000044/uni00000057/uni00000048/uni00000013/uni00000014/uni00000013/uni00000015/uni00000013/uni00000016/uni00000013/uni00000017/uni00000013/uni00000018/uni00000013/uni00000019/uni00000013/uni0000001a/uni00000013/uni0000001b/uni00000013/uni0000001c/uni00000013/uni00000014/uni00000013/uni00000013/uni00000033/uni00000048/uni00000055/uni00000046/uni00000048/uni00000051/uni00000057/uni00000044/uni0000004a/uni00000048/uni00000003/uni0000000b/uni00000008/uni0000000c
/uni00000014/uni00000011/uni0000001c/uni00000016/uni00000013/uni00000011/uni00000016/uni00000018/uni00000018/uni00000011/uni0000001a
/uni00000017/uni00000011/uni0000001c/uni00000014/uni00000014/uni00000011/uni0000001a/uni00000015/uni00000017/uni00000011/uni0000001a/uni00000019/uni00000015/uni00000011/uni0000001b/uni00000019/uni00000017/uni00000011/uni0000001b/uni00000019/uni00000018/uni00000011/uni00000013/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033 (b) #FR
Figure 5: Inventory metrics between Gurobi and LS-IMPTable 2: #UR and #FR results between different solvers.
DatasetSCIPGurobiYuck LS-IMP
Exact Heur
#UR #FR #UR #FR #UR #FR #UR #FR #UR #FR
cutoff = 60s
D10.1% 0.6% 1.7% 5.8% 1.7% 5.8% 0.06% 0.2% 15.5% 64.7%
D20.1% 0.6% 0.6% 1.9% 1.7% 5.7% 0 0 16.4% 60.7%
D3 0 0 0 0 2.3% 9.0% 0 0 16.7% 62.0%
D4 0 0 0 0 1.2% 5.0% 0 0 16.3% 61.6%
D5 0 0 0 0 1.8% 4.8% 0 0 17.0% 65.0%
Avg. 0.06% 0.2% 0.4% 1.9% 1.4% 4.9% 0.01% 0.04% 16.4% 62.8%
cutoff = 300s
D10.2% 1.2% 7.7% 39.6% 1.8% 7.0% 0.08% 0.3% 17.7% 68.8%
D20.2% 1.2% 6.0% 35.5% 2.6% 13.9% 0.05% 0.2% 17.7% 62.8%
D3 0 0 5.1% 22.8% 4.3% 14.7% 0 0 18.1% 64.3%
D4 0 0 5.9% 28.8% 2.4% 11.7% 0 0 16.6% 62.5%
D5 0 0 5.3% 24.7% 3.4% 11.2% 0 0 17.3% 65.7%
Avg. 0.1% 0.5% 6.0% 30.3% 2.7% 11.7% 0.02% 0.08% 17.5% 64.8%
cutoff = 1000s
D10.3% 1.8% 15.3% 62.3% 6.6% 24.1% 0.08% 0.03% 17.7% 68.9%
D20.3% 1.8% 14.7% 61.3% 6.3% 28.4% 0.05% 0.2% 17.7% 62.9%
D3 0 0 11.4% 46.8% 7.0% 25.2% 0 0 18.1% 64.4%
D4 0 0 12.1% 52.6% 4.2% 22.2% 0 0 16.6% 62.6%
D5 0 0 14.6% 55.6% 6.8% 23.8% 0 0 17.4% 66.0%
Avg. 0.1% 0.7% 13.6% 55.7% 6.2% 24.7% 0.02% 0.08% 17.5% 65.0%
#win and #feas analysis: It can be observed that within 60
seconds, LS-IMP holds a significant advantage in both the count of
feasible solutions and the count of winning solutions. It is apparent
that SCIP and Yuck, when applied to the available dataset, is not
able to provide a feasible solution for most of the instances. As
a commercial solver, Gurobi falls significantly short of LS-IMP in
terms of both the quantity of feasible solutions and the quality
of solutions found in the 60s time frame. Even with longer time
(300s,1000s), these two metrics still do not surpass LS-IMP.
Solving time analysis: Due to the performance of SCIP and
Yuck at all times and Gurobi in 60s being not so competent as in
Table 3, we only conduct a comparison of the solving time of the LS-
IMP and Gurobi solvers, specifically examining their running times
at 300 seconds and 1000 seconds to validate the convergence speed
of our algorithm. In this analysis, we do a comparison between
the heuristic and exact versions of the Gurobi. The solving time
result is shown in Table Figure 6. It can be observed that, whether
within a 300-second or a 1000-second timeframe, for instances
where the same solution is found, LS-IMP steadily obtains solutions
in a shorter period of time. This demonstrates the rapid convergence
speed of our solver.
Statistical significance analysis: We conducted two experi-
ments. 1. Repetitive running our algorithm for 20 times; 2. A sensi-
tivity analysis experiments on the parameters. The results are in
Table 1 and Table 2 in the appendix3. The two experiments show
3https://github.com/LS-IMP/appendix/blob/main/appendix.pdf
 
1047An Efficient Local Search Algorithm for Large GD Advertising Inventory Allocation with Multilinear Constraints KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
that our algorithm is stable with randomness and fluctuations in
the parameters.
Table 3: #win and #feas results between solvers.
DatasetSCIPGurobiYuck LS-IMP
Exact Heur
#win #feas #win #feas #win #feas #win #feas #win #feas
cutoff = 60s
D1 1 1 12 12 12 12 0 1 179 179
D2 1 1 4 4 11 26 0 0 164 166
D3 0 0 0 0 16 43 0 0 172 178
D4 0 0 0 0 5 29 0 0 170 171
D5 0 0 0 0 10 41 0 0 175 176
Total 2 2 16 16 54 151 0 1 860 870
cutoff = 300s
D1 2 2 69 96 13 17 0 2 146 180
D2 2 2 61 82 24 44 0 1 141 167
D3 0 0 42 66 17 56 0 0 159 179
D4 0 0 47 74 17 43 0 0 153 172
D5 0 0 42 67 21 53 0 0 165 176
Total 4 4 261 385 92 213 0 3 764 874
cutoff = 1000s
D1 3 3 115 150 34 81 0 2 117 180
D2 3 3 109 151 40 91 0 2 112 167
D3 0 0 87 124 30 87 0 0 131 179
D4 0 0 92 132 35 71 0 0 124 172
D5 0 0 105 141 33 90 0 0 130 176
Total 6 6 508 698 172 420 0 4 614 874
/uni00000014/uni00000013 /uni00000014/uni00000013/uni00000013 /uni00000014/uni00000013/uni00000013/uni00000013
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033 /uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000014/uni00000013/uni00000014/uni00000013/uni00000013/uni00000014/uni00000013/uni00000013/uni00000013/uni0000002a/uni00000058/uni00000055/uni00000052/uni00000045/uni0000004c/uni00000003/uni00000032/uni00000053/uni00000057/uni0000004c/uni00000050/uni0000004c/uni0000005d/uni00000048/uni00000055/uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046
(a) cutoff: 300s
/uni00000014/uni00000013 /uni00000014/uni00000013/uni00000013 /uni00000014/uni00000013/uni00000013/uni00000013
/uni0000002f/uni00000036/uni00000010/uni0000002c/uni00000030/uni00000033 /uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000014/uni00000013/uni00000014/uni00000013/uni00000013/uni00000014/uni00000013/uni00000013/uni00000013/uni0000002a/uni00000058/uni00000055/uni00000052/uni00000045/uni0000004c/uni00000003/uni00000032/uni00000053/uni00000057/uni0000004c/uni00000050/uni0000004c/uni0000005d/uni00000048/uni00000055/uni00000003/uni0000003e/uni00000056/uni00000048/uni00000046/uni00000040/uni00000028/uni0000005b/uni00000044/uni00000046/uni00000057
/uni0000002b/uni00000048/uni00000058/uni00000055/uni0000004c/uni00000056/uni00000057/uni0000004c/uni00000046 (b) cutoff: 1000s
Figure 6: Run time comparison for Gurobi and LS-IMP
4.3 Effectiveness of Proposed Strategies
To analyze the effectiveness of our proposed strategies, four modi-
fied versions of LS-IMP are proposed as follows. Our ablation exper-
iments are conducted with a time setting aligned to business-related
solving: 60 seconds.
â€¢To analyze the effectiveness of bound move, we modify LS-
IMP by only using the reduce move and the propel move
operators, named the version ğ‘£ğ‘›ğ‘œ_ğ‘ğ‘œğ‘¢ğ‘›ğ‘‘ .â€¢To analyze the effectiveness of reduce move, we modify LS-
IMP by only using the bound move and the propel move
operators, named the version ğ‘£ğ‘›ğ‘œ_ğ‘Ÿğ‘’ğ‘‘ğ‘¢ğ‘ğ‘’ .
â€¢To analyze the effectiveness of propel move, we modify LS-
IMP by only using the bound move and the reduce move
operators, named the version ğ‘£ğ‘›ğ‘œ_ğ‘ğ‘Ÿğ‘œğ‘ğ‘’ğ‘™ .
â€¢To analyze the effectiveness of all operation in Feasible Mode,
we modify LS-IMP by only using simple move, named the
versionğ‘£ğ‘›ğ‘œ_ğ‘ğ‘™ğ‘™.
Table 4: Comparing LS-IMP with its modified versions. The
number of instances where LS-IMP achieves better and worse
performance, denoted as #better and #worse.
ğ‘£ğ‘›ğ‘œ_ğ‘ğ‘œğ‘¢ğ‘›ğ‘‘ğ‘£ğ‘›ğ‘œ_ğ‘Ÿğ‘’ğ‘‘ğ‘¢ğ‘ğ‘’ğ‘£ğ‘›ğ‘œ_ğ‘ğ‘Ÿğ‘œğ‘ğ‘’ğ‘™ğ‘£ğ‘›ğ‘œ_ğ‘ğ‘™ğ‘™
#better 220 305 34 426
#worse 177 279 3 248
The results of the ablation experiment are presented in Table 4
and confirm the effectiveness of the proposed strategies.
5 CONCLUSION AND FUTURE WORK
In this paper, we focus on the local search algorithm for the GD
advertising inventory allocation problem. We model the GD ad-
vertising inventory allocation with focus ratio requirements as an
integer multilinear programming problem and propose an efficient
two-mode local search algorithm to solve it. Experiments demon-
strate that our algorithm produces a higher quality allocation plan
compared to the state-of-the-art solvers for this problem.
Our algorithm is able to handle the general multilinear con-
straints and could be applied to other scenarios of contract alloca-
tions. In the future, we also consider extending our algorithm to
solve problems with requirements involving ratios of other business
metrics. Local search algorithm is new for computational advertisng
and we think is a promising domain to explore. We hope our new
local search algorithm could provide inspiration for future research.
6 ACKNOWLEDGMENTS
This research is supported by National Key R&D Program of China
(2023YFA1009500).
REFERENCES
[1]Tobias Achterberg. Scip: solving constraint integer programs. Mathematical
Programming Computation, 1:1â€“41, 2009.
[2]Shipra Agrawal and Nikhil R Devanur. Fast algorithms for online stochastic
convex programming. In Proceedings of the twenty-sixth annual ACM-SIAM
symposium on Discrete algorithms, pages 1405â€“1424. SIAM, 2014.
[3]Shipra Agrawal, Zizhuo Wang, and Yinyu Ye. A dynamic near-optimal algorithm
for online linear programming. Operations Research, 62(4):876â€“890, 2014.
[4]Adrian Balint and Uwe SchÃ¶ning. Choosing probability distributions for stochas-
tic local search and the role of make versus break. In Proc. of SAT 2012, pages
16â€“29, 2012.
[5]Anand Bhalgat, Jon Feldman, and Vahab Mirrokni. Online allocation of display
ads with smooth delivery. In Proceedings of the 18th ACM SIGKDD international
conference on Knowledge discovery and data mining, pages 1213â€“1221, 2012.
[6]Vijay Bharadwaj, Peiji Chen, Wenjing Ma, Chandrashekhar Nagarajan, John
Tomlin, Sergei Vassilvitskii, Erik Vee, and Jian Yang. Shale: an efficient algorithm
for allocation of guaranteed display advertising. In Proceedings of the 18th ACM
 
1048KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Xiang He et al.
SIGKDD international conference on Knowledge discovery and data mining, pages
1195â€“1203, 2012.
[7]Armin Biere. Splatz, Lingeling, Plingeling, Treengeling, YalSAT entering the SAT
competition 2016. Proc. of SAT Competition 2016, pages 44â€“45, 2016.
[8]Gustav BjÃ¶rdal, Jean-NoÃ«l Monette, Pierre Flener, and Justin Pearson. A
constraint-based local search backend for minizinc. Constraints, 20:325â€“345,
2015.
[9]Shaowei Cai. Balance between complexity and quality: Local search for minimum
vertex cover in massive graphs. In Twenty-Fourth International Joint Conference
on Artificial Intelligence, pages 747â€“753, 2015.
[10] Peiji Chen, Wenjing Ma, Srinath Mandalapu, Chandrashekhar Nagarjan, Jayavel
Shanmugasundaram, Sergei Vassilvitskii, Erik Vee, Manfai Yu, and Jason Zien.
Ad serving using a compact allocation plan. In Proceedings of the 13th ACM
Conference on Electronic Commerce, pages 319â€“336, 2012.
[11] Liang Dai, Zhonglin Zu, Hao Wu, Liang Wang, and Bo Zheng. Fairness-aware
guaranteed display advertising allocation under traffic cost constraint. In Pro-
ceedings of the ACM Web Conference 2023, pages 3572â€“3580, 2023.
[12] Nikhil R Devanur, Kamal Jain, Balasubramanian Sivan, and Christopher A
Wilkens. Near optimal online algorithms and fast approximation algorithms
for resource allocation problems. In Proceedings of the 12th ACM conference on
Electronic commerce, pages 29â€“38, 2011.
[13] RF Drenick. Multilinear programming: Duality theories. Journal of optimization
theory and applications, 72:459â€“486, 1992.
[14] Zhen Fang, Yang Li, Chuanren Liu, Wenxiang Zhu, Yu Zheng, and Wenjun Zhou.
Large-scale personalized delivery for guaranteed display advertising with real-
time pacing. In 2019 IEEE International Conference on Data Mining (ICDM), pages
190â€“199. IEEE, 2019.
[15] Jon Feldman, Monika Henzinger, Nitish Korula, Vahab S Mirrokni, and Cliff
Stein. Online stochastic packing applied to display ad allocation. In European
Symposium on Algorithms, pages 182â€“194. Springer, 2010.
[16] Jon Feldman, Aranyak Mehta, Vahab Mirrokni, and Shan Muthukrishnan. Online
stochastic matching: Beating 1-1/e. In 2009 50th Annual IEEE Symposium on
Foundations of Computer Science, pages 117â€“126. IEEE, 2009.
[17] Paul W Goldberg. Bounds for the convergence rate of randomized local search
in a multiplayer load-balancing game. In Proceedings of the twenty-third annual
ACM symposium on principles of distributed computing, pages 131â€“140, 2004.
[18] Jun Gu. Efficient local search for very large-scale satisfiability problems. ACM
SIGART Bulletin, 3(1):8â€“12, 1992.
[19] LLC Gurobi Optimization. Gurobi optimizer reference manual (gurobi optimiza-
tion, llc). 2022.
[20] Bernhard Haeupler, Vahab S Mirrokni, and Morteza Zadimoghaddam. Online sto-
chastic weighted matching: Improved approximation algorithms. In Internet and
Network Economics: 7th International Workshop, WINE 2011, Singapore, December
11-14, 2011. Proceedings 7, pages 170â€“181. Springer, 2011.[21] Larry W Jacobs and Michael J Brusco. Note: A local-search heuristic for large
set-covering problems. Naval Research Logistics (NRL), 42(7):1129â€“1140, 1995.
[22] Alejandro Lara-Caballero and Diego GonzÃ¡lez-Moreno. A population-based local
search algorithm for the identifying code problem. Mathematics, 11(20):4361,
2023.
[23] Bohan Li and Shaowei Cai. Local search for smt on linear and multilinear real
arithmetic. arXiv preprint arXiv:2303.06676, 2023.
[24] Desmond S Lun, Graham Rockwell, Nicholas J Guido, Michael Baym, Jonathan A
Kelner, Bonnie Berger, James E Galagan, and George M Church. Large-scale
identification of genetic design strategies using local search. molecular systems
biology, 5(1):296, 2009.
[25] Vahideh H Manshadi, Shayan Oveis Gharan, and Amin Saberi. Online stochastic
matching: Online actions based on offline statistics. Mathematics of Operations
Research, 37(4):559â€“573, 2012.
[26] Wuyang Mao, Chuanren Liu, Yundu Huang, Zhonglin Zu, M Harshvardhan, Liang
Wang, and Bo Zheng. End-to-end inventory prediction and contract allocation
for guaranteed delivery advertising. In Proceedings of the 29th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining, pages 1677â€“1686, 2023.
[27] Vahab S Mirrokni, Shayan Oveis Gharan, and Morteza Zadimoghaddam. Simulta-
neous approximations for adversarial and stochastic online budgeted allocation.
InProceedings of the twenty-third annual ACM-SIAM symposium on Discrete
Algorithms, pages 1690â€“1701. SIAM, 2012.
[28] Hans Mittelmann. Visualizations of mittelmann benchmarks, 2023. URL: https:
//mattmilten.github.io/mittelmann-plots/.
[29] Baruch Schieber and Soroush Vahidi. Approximating connected maximum cuts
via local search. In 31st Annual European Symposium on Algorithms (ESA 2023).
Schloss-Dagstuhl-Leibniz Zentrum fÃ¼r Informatik, 2023.
[30] Bart Selman, Henry A Kautz, Bram Cohen, et al. Local search strategies for
satisfiability testing. Cliques, coloring, and satisfiability, 26:521â€“532, 1993.
[31] Karthik Sindhya, Kalyanmoy Deb, and Kaisa Miettinen. A local search based
evolutionary multi-objective optimization approach for fast and accurate conver-
gence. In International Conference on Parallel Problem Solving from Nature, pages
815â€“824. Springer, 2008.
[32] Karthik Sindhya, Kalyanmoy Deb, and Kaisa Miettinen. Improving convergence
of evolutionary multi-objective optimization with local search: a concurrent-
hybrid algorithm. Natural Computing, 10:1407â€“1430, 2011.
[33] Peter J Stuckey, Ralph Becket, and Julien Fischer. Philosophy of the m ini z inc
challenge. Constraints, 15:307â€“316, 2010.
[34] Robert Johannes Maria Vaessens, Emile Hubertus Leonardus Aarts, and Jan Karel
Lenstra. Job shop scheduling by local search. Informs Journal on computing,
8(3):302â€“317, 1996.
[35] Hong Zhang, Lan Zhang, Lan Xu, Xiaoyang Ma, Zhengtao Wu, Cong Tang, Wei
Xu, and Yiguo Yang. A request-level guaranteed delivery advertising planning:
Forecasting and allocation. In Proceedings of the 26th ACM SIGKDD International
Conference on Knowledge Discovery & Data Mining, pages 2980â€“2988, 2020.
 
1049