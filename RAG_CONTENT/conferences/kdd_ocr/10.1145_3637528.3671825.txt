Making Temporal Betweenness Computation Faster and Restless
Filippo Brunelli
European Commission â€” JRC
Seville, Spain
filippo.brunelli@ec.europa.euPierluigi Crescenzi
Gran Sasso Science Institute
Lâ€™Aquila, Italy
pierluigi.crescenzi@gssi.itLaurent Viennot
Inria, DI ENS
Paris, France
laurent.viennot@inria.fr
ABSTRACT
BuÃŸ et al [KDD 2020] recently proved that the problem of com-
puting the betweenness of all nodes of a temporal graph is com-
putationally hard in the case of foremost and fastest paths, while
it is solvable in time ğ‘‚(ğ‘›3ğ‘‡2)in the case of shortest and shortest
foremost paths, where ğ‘›is the number of nodes and ğ‘‡is the number
of distinct time steps. A new algorithm for temporal betweenness
computation is introduced in this paper. In the case of shortest and
shortest foremost paths, it requires ğ‘‚(ğ‘›+ğ‘€)space and runs in time
ğ‘‚(ğ‘›ğ‘€)=ğ‘‚(ğ‘›3ğ‘‡), whereğ‘€is the number of temporal edges, thus
significantly improving the algorithm of BuÃŸ et al in terms of time
complexity (note that ğ‘‡is usually large). Experimental evidence is
provided that our algorithm performs between twice and almost
250 times better than the algorithm of BuÃŸ et al. Moreover, we were
able to compute the exact temporal betweenness values of several
large temporal graphs with over a million of temporal edges. For
such size, only approximate computation was possible by using
the algorithm of Santoro and Sarpe [WWW 2022]. Maybe more
importantly, our algorithm extends to the case of restless walks (that
is, walks with waiting constraints in each node), thus providing
a polynomial-time algorithm (with complexity ğ‘‚(ğ‘›ğ‘€)) for com-
puting the temporal betweenness in the case of several different
optimality criteria. Such restless computation was known only for
the shortest criterion (Rymar et al [JGAA 2023]), with complexity
ğ‘‚(ğ‘›2ğ‘€ğ‘‡2). We performed an extensive experimental validation by
comparing different waiting constraints and different optimisation
criteria. Moreover, as a case study, we investigate six public tran-
sit networks including Berlin, Rome, and Paris. Overall we find a
general consistency between the different variants of betweenness
centrality. However, we do measure a sensible influence of waiting
constraints, and note some cases of low correlation for certain pairs
of criteria in some networks.
CCS CONCEPTS
â€¢Theory of computation â†’Shortest paths; â€¢Networksâ†’
Network algorithms ;â€¢Mathematics of computing â†’Graph al-
gorithms.
KEYWORDS
node centrality, betweenness, temporal graphs, graph mining
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671825ACM Reference Format:
Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot. 2024. Making
Temporal Betweenness Computation Faster and Restless. In Proceedings of
the 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining
(KDD â€™24), August 25â€“29, 2024, Barcelona, Spain. ACM, New York, NY, USA,
12 pages. https://doi.org/10.1145/3637528.3671825
1 INTRODUCTION
Social network analysis is usually considered to start with the book
of Moreno [ 32], where sociograms (that is, graphs) are used to study
the relationships between kids from kindergarten to the 8th grade.
Successively, Bavelas [ 1] used sociogram analysis (that is, graph
mining) techniques to identify the most important members of a
group. Several notions of node importance were successively in-
troduced until Freeman [ 22] proposed precise different definitions
ofnode centrality, such as the degree centrality, the closeness cen-
trality, and the betweenness centrality. This latter centrality, which
measures how often a node participates in an optimal path, has been
repeatedly applied in different research contexts, such as, for ex-
ample, the analysis of brain, collaboration, citation and, in general,
social networks. From a computational point of view, Brandes [ 7]
proposed an algorithm for computing the betweenness centrality
of all nodes in time ğ‘‚(ğ‘›ğ‘š), whereğ‘›is the number of nodes and ğ‘š
is the number of edges. Due to the huge size of some real-world
networks, several approximation algorithms for computing the be-
tweenness centrality have also been proposed in the last twenty
years (such as, for example, the ABRA and KADABRA algorithms
described in [6, 35]), mostly based on sampling techniques.
More recently, the notion of betweenness centrality has been
also applied to the case of temporal graphs. Indeed, many real-world
complex networks evolve over time, in the sense that edges can
appear and disappear at specific time instants. As observed in [ 28],
this is due to the fact that interactions between nodes take place
over time, as it happens, for example, in the case of collaboration,
communication, user-product, and transport networks. Many differ-
ent modelizations of these evolving networks have been proposed
in the literature, such as the evolving graph model analysed in [ 20],
thetime-dependent graph model studied in [ 21], the time-varying
graph model [ 12], or the link stream model introduced in [ 28]. In
this paper we refer to this latter model, also known as the temporal
graph model [ 31]. Atemporal graph is a collection of temporal edges
over a fixed set of nodes. Each temporal edge is an edge (ğ‘¢,ğ‘£)with
an associated availability ordeparture timeğœand a traversal or
travel timeğœ†. A temporal edge ğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)can then be traversed
starting from ğ‘¢at timeğœand arriving in ğ‘£at timeğœ+ğœ†. The no-
tion of walk (or of path, if node repetitions are not allowed) can
be easily adapted to the case of temporal graphs by imposing the
natural condition of traversing the temporal edges in ascending
time: that is, for any two consecutive temporal edges (ğ‘¢,ğ‘£,ğœ 1,ğœ†1)
 
163
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
and(ğ‘£,ğ‘¤,ğœ 2,ğœ†2)in the walk, ğœ2â‰¥ğœ1+ğœ†1.1However, introducing
the temporal dimension arises different notions of optimal walks
or paths, the most common used being the shortest one (with the
fewest number of temporal edges), the foremost one (with the earli-
est arrival time), and the fastest one (with the smallest total travel
time). Once a notion of optimal walk or path is adopted, the cor-
responding notion of betweenness can be analysed in terms of its
computational complexity. Indeed, this has been done in [ 11] in
the case of paths, where the authors proved that computing the
shortest betweenness of all nodes can be done in time ğ‘‚(ğ‘›3ğ‘‡2),
whereğ‘›is the number of nodes and ğ‘‡is the number of distinct time
steps in the temporal graph, while computing the foremost and the
fastest betweenness is #P-hard, that is, most likely computationally
intractable. These cases are also studied in [ 38], where, among other
results, the authors proved that the restless shortest betweenness
(in the case of walks) can be computed in time ğ‘‚(ğ‘›2ğ‘€ğ‘‡2), where
ğ‘€is the number of temporal edges (interestingly, the #P-hardness
result does not hold when considering walks rather than paths). A
restless walk (or path) is a walk in which we do not â€œwaitâ€ at the
same node more than ğ›½time units, where ğ›½is a constant: that is, for
any two consecutive temporal edges (ğ‘¢,ğ‘£,ğœ 1,ğœ†1)and(ğ‘£,ğ‘¤,ğœ 2,ğœ†2)
in the walk, ğœ2â‰¤ğœ1+ğœ†1+ğ›½in addition to ğœ2â‰¥ğœ1+ğœ†1. Note that, in
the restless case, even deciding whether there exists a path between
two specific nodes is NP-complete [ 13]. Hence, in this case, we are
forced to consider walks instead of paths. Our main contributions
are the following.
â€¢We propose an algorithm for computing the betweenness in
timeğ‘‚(ğ‘›ğ‘€)=ğ‘‚(ğ‘›3ğ‘‡)in the case of shortest and shortest
foremost paths (note that, in these cases, optimal non-restless
walks are always paths). Our algorithm significantly outper-
forms the previously known algorithm (whose complexity
wasğ‘‚(ğ‘›3ğ‘‡2)) for computing the shortest and the shortest
foremost betweenness [11].
â€¢We propose an algorithm for computing the betweenness in
timeğ‘‚(ğ‘›ğ‘€)in the case of fastest, foremost, shortest, shortest
fastest, and shortest foremost restless walks. The only previ-
ously known polynomial-time algorithm (with complexity
ğ‘‚(ğ‘›2ğ‘€ğ‘‡2)) was in the case of shortest restless walks [ 38]:
our algorithm significantly improves this algorithm. As far
as we know, in all the other cases our algorithm is the first
polynomial-time one and we conjecture it is optimal. Indeed,
the algorithm is based on a new way of counting the number
of optimal walks from a given source in time ğ‘‚(ğ‘€). This
complexity is clearly optimal.
â€¢We perform an extensive experimental evaluation of our
non-restless algorithm, based on a diverse set of real-world
networks that includes all publicly available networks from
the works of [ 2,11,39]. In particular, we compare the exe-
cution time of our algorithm and of the algorithm proposed
in [11] for computing the shortest and the shortest foremost
betweenness. It turns out that our algorithm is between twice
and almost 250 faster than the algorithm of [11].
â€¢By using our non-restless algorithm, we are able to compute
in a reasonable amount of time the shortest betweenness
1In this paper, we assume that the traversal time is always positive, which corresponds
to the case called strict in the literature.of all nodes of three quite large temporal graphs analysed
in [39], for which only approximate values were available so
far by making use of the ONBRA approximation algorithm
proposed in that paper and based on a sampling technique.
From the results reported in [ 39], it also follows that our
algorithm is almost always significantly faster than ONBRA.
â€¢We apply our restless algorithm for computing the fastest,
foremost, shortest, shortest foremost, and shortest fastest be-
tweenness of all nodes of the temporal graphs considered in
the first experiment. By referring to the (weighted) Kendallâ€™s
ğœcorrelation and to the intersection of the top-50 node sets,
we compare the node rankings produced by the different
betweenness measures and by different waiting constraints
and we observe that there exists a general consistency be-
tween the different variants of betweenness centrality. We
do also measure a sensible influence of waiting constraints,
and note some cases of low correlation for certain pairs of
criteria in some networks.
â€¢As a case study, we apply our algorithm to the analysis of
several public transport networks among the ones published
in [15,26]. In particular, we compare the execution time,
the (weighted) Kendallâ€™s ğœ, and the size of the intersection
of the top-100 node sets for two different notions between-
ness, that is, the shortest fastest and the shortest foremost
betweenness. We observe a strong consistency between the
two different variants of betweenness centrality, and a much
lower consistency with the rankings produced by the be-
tweenness of the static underlying graph, thus suggesting
that this latter measure cannot be used as a â€˜proxyâ€™ of the
shortest fastest and the shortest foremost betweenness.
Both our algorithm and the algorithm proposed in [ 11] follow a
two phase approach (that is a path counting forward phase and a
betweenness accumulation backward phase) and are both inspired
by Brandesâ€™ algorithm [ 7]. A first difference between our algorithm
and the algorithm of [ 11] is that the latter focuses on temporal
vertices and explore their temporal neighbors, while our algorithm
focuses on temporal edges and explore their temporal extensions.
A second (and maybe, main) difference is that we leverage on two
orderings of the temporal edges to overall consider each temporal
edge (both in the forward phase and in the backward phase) a con-
stant number of times, rather than considering a temporal neighbor
for each of its predecessors. Third, our data structure allows to store
predecessors in linear space with respect to the number of temporal
edges. Finally, we note that the approach used in [ 39] is different
as it is an approximation algorithm and it works through sampling.
However, the way the paths are counted is similar to [11].
2 RELATED WORK
The literature on centrality measures being vast (as demonstrated
by the clever periodic table of network centrality developed by
David Schoch [ 42,43]), we restrict our attention to approaches that
are closest to ours, that is, to the realm of temporal graphs. Several
introductions to temporal graphs also include surveys on temporal
centrality measures (see, e.g., [ 24,28,41]). Clearly related to our
work is the literature on the efficient computation of temporal paths
and walks, such as the seminal paper of Bui-Xuan, Ferreira, and
 
164Making Temporal Betweenness Computation Faster and Restless KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Jarry [ 10] and the more recent paper by Wu et al [ 49] (the reader
may also refer to the quite exhaustive analysis of this literature
appeared in [ 9]). Besides the references given in the introduction,
our paper is mostly related to all work on the definition and compu-
tation of different temporal centrality measures, such as (in order
of appearance) the temporal pagerank defined in [ 37], the temporal
Katz centrality introduced in [ 4], the temporal reachability used
in [19], theğ‘“-PageRank centrality defined in [ 30], the temporal
betweenness centrality defined in [ 47], the temporal closeness cen-
trality treated in [ 16,33], the temporal walk centrality introduced
in [34], and the temporal betweenness centrality analysed in [ 44],
just to mention the most recent ones. Finally, more â€œlocalâ€ notions
of centrality in temporal graphs have also been analysed such as the
temporal version of ego betweenness introduced in Ghanem [ 23]
and the pass-through degree defined in [ 2]: these centralities are
clearly more efficient in terms of execution time, but not always
satisfying in terms of the quality of their rankings.
3 BASIC DEFINITIONS AND RESULTS
Temporal graphs. Atemporal graph is a tupleğº=(ğ‘‰,ğ¸,ğ›½), where
ğ‘‰is the set of nodes,ğ¸is the set of temporal edges, and ğ›½âˆˆNâˆª{+âˆ}
is the maximum waiting-time (we say that waiting is unrestricted
whenğ›½=+âˆ). Atemporal edge ğ‘’is a quadruple(ğ‘¢,ğ‘£,ğœ,ğœ†), where
ğ‘¢âˆˆğ‘‰is the tailofğ‘’,ğ‘£âˆˆğ‘‰is the head ofğ‘’,ğœâˆˆNis the departure (or
availability )time ofğ‘’, andğœ†âˆˆN+is the travel (ortraversal )time of
ğ‘’. We also define the arrival time ofğ‘’asğœ+ğœ†, and we let dep(ğ‘’)=ğœ
andarr(ğ‘’)=ğœ+ğœ†denote the departure time and arrival time of
ğ‘’, respectively. We let ğ‘›=|ğ‘‰|andğ‘€=|ğ¸|denote the number of
nodes and temporal edges, respectively, and ğ‘‡denote the number
of distinct availability times. Finally, for any node ğ‘£,ğ¸hğ‘£will denote
the set of temporal edges whose head is ğ‘£.
Temporal graph representation. We use a doubly-sorted repre-
sentation of a temporal graph (ğ‘‰,ğ¸,ğ›½), which consists of two lists
ğ¸arrandğ¸dep, each containing|ğ¸|quadruples representing the tem-
poral edges in ğ¸:ğ¸arris a list sorted by non-decreasing arrival time
andğ¸depis a list sorted by non-decreasing departure time. More
precisely, we assume that ğ¸depis specified through implicit pointers
fromğ¸deptoğ¸arr, that link each (logical) quadruple in ğ¸depto the
(physical) quadruple in ğ¸arrrepresenting the same temporal edge.
Temporal walks. Given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), awalk
ğ‘Šfrom (a source) ğ‘ to (a target) ğ‘¡, or ağ‘ ğ‘¡-walk for short, is a
sequence of temporal edges ğ‘’ğ‘–=(ğ‘¢ğ‘–,ğ‘£ğ‘–,ğœğ‘–,ğœ†ğ‘–)forğ‘–âˆˆ [ğ‘˜], such
thatğ‘ =ğ‘¢1,ğ‘£ğ‘˜=ğ‘¡, and, for each ğ‘–âˆˆ [ğ‘˜âˆ’1],2ğ‘¢ğ‘–+1=ğ‘£ğ‘–and
arr(ğ‘’ğ‘–)â‰¤ğœğ‘–+1â‰¤arr(ğ‘’ğ‘–)+ğ›½(ğ‘Šis also called a ğ‘ ğ‘’ğ‘˜-walk). A walk is
said to be a path if, for anyğ‘–,ğ‘—âˆˆ[ğ‘˜]withğ‘–â‰ ğ‘—,ğ‘¢ğ‘–â‰ ğ‘¢ğ‘—andğ‘¢ğ‘–â‰ ğ‘£ğ‘˜.
Note that, since travel times are positive, walks are strict in the
sense thatğœğ‘–<ğœğ‘–+1, forğ‘–âˆˆ[ğ‘˜âˆ’1]. The departure time dep(ğ‘Š)ofğ‘Š
is defined as dep(ğ‘’1), while the arrival time arr(ğ‘Š)ofğ‘Šis defined
asarr(ğ‘’ğ‘˜). The duration ofğ‘Šis defined as arr(ğ‘Š)âˆ’dep(ğ‘Š). We
say that a temporal edge ğ‘’=(ğ‘¡,ğ‘¤,ğœ,ğœ†)extendsğ‘Šifarr(ğ‘Š)â‰¤ğœâ‰¤
arr(ğ‘Š)+ğ›½. Whenğ‘’extendsğ‘Š, we can indeed define the ğ‘ ğ‘¤-walk
ğ‘Š.ğ‘’=âŸ¨ğ‘’1,...,ğ‘’ğ‘˜,ğ‘’âŸ©fromğ‘ toğ‘¤. Moreover, we also say that ğ‘’
extendsğ‘’ğ‘˜as it indeed extends any ğ‘ ğ‘’ğ‘˜-walk. Finally, we say that a
temporal edge ğ‘’isğ‘ -reachable when there exists a ğ‘ ğ‘’-walk.
2In the following, for any non-negative integer ğ‘›,[ğ‘›]will denote the set{1,2,...,ğ‘›},
with[0]=âˆ….Given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), ağ‘ ğ‘¡-walkğ‘Šis ashort-
est(respectively, foremost, latest, and fastest )walk, if there is no
ğ‘ ğ‘¡-walk that contains less temporal edges than ğ‘Š(respectively, has
an earlier arrival time, has a later departure time, and has a smaller
duration). Moreover, a shortest foremost (respectively, latest and
fastest )walk is a foremost (respectively, latest and fastest) tempo-
ral walk that is not longer than any other foremost (respectively,
latest and fastest) temporal walk. In the following we will focus
on shortest foremost ( SFo) walks, since these walks will allow us
to introduce our algorithms in an easier way, without hiding the
generality of our approach. In the appendix, we show how our al-
gorithms can be adapted to the other types of walks by introducing
the notions of cost and target cost structure.
SFobetweenness. Given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), two
nodesğ‘ ,ğ‘¡âˆˆğ‘‰withğ‘ â‰ ğ‘¡, and a temporal edge ğ‘’âˆˆğ¸, we letğœâˆ—
ğ‘ ,ğ‘’,ğ‘¡
denote the number of SFowalks fromğ‘ toğ‘¡that contain ğ‘’. We also
denote byğœâˆ—
ğ‘ ,ğ‘¡=Ã
ğ‘’âˆˆğ¸h
ğ‘¡ğœâˆ—
ğ‘ ,ğ‘’,ğ‘¡the number of SFowalks from ğ‘ toğ‘¡.
We define the ğ‘ -SFobetweenness of a temporal edge ğ‘’asğ‘ğ‘ ,ğ‘’=Ã
ğ‘£âˆˆğ‘‰:ğœ’ğ‘ ,ğ‘¡=1ğœâˆ—
ğ‘ ,ğ‘’,ğ‘¡/ğœâˆ—
ğ‘ ,ğ‘¡, whereğœ’ğ‘ ,ğ‘¡=1ifğ‘ â‰ ğ‘¡and there exists a
ğ‘ ğ‘¡-walk (and, hence, ğœâˆ—
ğ‘ ,ğ‘¡â‰ 0), andğœ’ğ‘ ,ğ‘¡=0otherwise.
Given three pairwise-distinct nodes ğ‘ ,ğ‘¢, andğ‘¡we denote by
ğœâˆ—
ğ‘ ,ğ‘¢,ğ‘¡=Ã
ğ‘’âˆˆğ¸hğ‘¢ğœâˆ—
ğ‘ ,ğ‘’,ğ‘¡the number of SFowalks fromğ‘ toğ‘¡that con-
tainğ‘¢. Note that a walk where ğ‘¢appearsğœ‡times is counted with
multiplicity ğœ‡.3TheSFobetweenness of a vertex ğ‘¢is defined as ğ‘ğ‘¢=Ã
ğ‘ ,ğ‘¡âˆˆğ‘‰\{ğ‘¢}:ğœ’ğ‘ ,ğ‘¡=1ğœâˆ—
ğ‘ ,ğ‘¢,ğ‘¡/ğœâˆ—
ğ‘ ,ğ‘¡. The SFobetweenness of any vertex ğ‘¢
can easily be computed from the ğ‘ -SFobetweenness ğ‘ğ‘ ,ğ‘’of all tem-
poral edges ğ‘’enteringğ‘¢, sinceğ‘ğ‘¢=Ã
ğ‘ âˆˆğ‘‰\{ğ‘¢}Ã
ğ‘’âˆˆğ¸hğ‘¢ğ‘ğ‘ ,ğ‘’âˆ’ğœ’ğ‘ ,ğ‘¢
.
Given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½)and a temporal edge ğ‘’âˆˆğ¸,
letğœğ‘ ,ğ‘’(respectively, ğœâˆ—ğ‘ ,ğ‘’) denote the number of Sh(respectively,
SFo)ğ‘ ğ‘’-walks, where a ğ‘ ğ‘’-walkğ‘ŠisSFoif there is no ğ‘ ğ‘’-walkğ‘‹
such that(arr(ğ‘‹),|ğ‘‹|)â—(arr(ğ‘Š),|ğ‘Š|)(in the following, for any
ğ‘,ğ‘,ğ‘,ğ‘‘âˆˆN,(ğ‘,ğ‘)â—(ğ‘,ğ‘‘)if and only(ğ‘<ğ‘)âˆ¨(ğ‘=ğ‘âˆ§ğ‘<ğ‘‘)).
Moreover, given two nodes ğ‘ ,ğ‘¡âˆˆğ‘‰withğ‘ â‰ ğ‘¡, letWğ‘ ,ğ‘’,ğ‘¡denote
the set of SFoğ‘ ğ‘¡-walk containing ğ‘’(hence,|Wğ‘ ,ğ‘’,ğ‘¡|=ğœâˆ—
ğ‘ ,ğ‘’,ğ‘¡). Each
walkğ‘ŠâˆˆWğ‘ ,ğ‘’,ğ‘¡can be decomposed into a prefix ğ‘Š1(fromğ‘ to
ğ‘£) ending with ğ‘’and a suffix ğ‘Š2(fromğ‘£toğ‘¡). Letğœƒğ‘ ,ğ‘’,ğ‘¡denote the
number of distinct suffixes of walks in Wğ‘ ,ğ‘’,ğ‘¡(eventually including
the empty suffix). It is easy to prove that ğœâˆ—
ğ‘ ,ğ‘’,ğ‘¡=ğœğ‘ ,ğ‘’Â·ğœƒğ‘ ,ğ‘’,ğ‘¡.
Given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), two nodes ğ‘ ,ğ‘¡âˆˆğ‘‰with
ğ‘ â‰ ğ‘¡, and a temporal edge ğ‘’âˆˆğ¸, let succğ‘ ,ğ‘’,ğ‘¡denote the set of
temporal edges ğ‘“such thatğ‘’andğ‘“are one after the other in a
walkğ‘ŠâˆˆWğ‘ ,ğ‘’,ğ‘¡. Moreover, let succğ‘ ,ğ‘’=Ã
ğ‘¡âˆˆğ‘‰\{ğ‘ }succğ‘ ,ğ‘’,ğ‘¡. In
the following, if ğ‘“âˆˆsuccğ‘ ,ğ‘’, we say that ğ‘“issuccessor ofğ‘’and that
ğ‘’is apredecessor ofğ‘“.
Lemma 1. Given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½)and a temporal
edgeğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†), the following hold:
ğ‘ğ‘ ,ğ‘’=ğœğ‘ ,ğ‘’âˆ‘ï¸
ğ‘“âˆˆsuccğ‘ ,ğ‘’ğ‘ğ‘ ,ğ‘“
ğœğ‘ ,ğ‘“+(ğœâˆ—
ğ‘ ,ğ‘’
ğœâˆ—ğ‘ ,ğ‘£ifğœâˆ—ğ‘ ,ğ‘’>0,
0 otherwise.
The above lemma will be used in the backward phase of our
algorithms in order to compute the ğ‘ -SFobetweenness of a tempo-
ral edgeğ‘’having already computed the ğ‘ -SFobetweenness of all
successorsğ‘“ofğ‘’.
3It is quite natural to take into account how many times a node appears in a walk
when considering walks rather than paths in the betweenness definition.
 
165KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
1
1,1
3
4,1
7
2,55
4,2
9
6,32
2,24
4,1
6
5,1
8
7,1
12
9,113
10,110
6,3
11
9,1ğ‘£1 ğ‘£2ğ‘£3 ğ‘£4
ğ‘£5 ğ‘£6
ğ‘£7 ğ‘£8ğ¸arr
1 :(ğ‘£1,ğ‘£2,1,1)
2 :(ğ‘£2,ğ‘£3,2,2)
3 :(ğ‘£1,ğ‘£2,4,1)
4 :(ğ‘£3,ğ‘£4,4,1)
5 :(ğ‘£2,ğ‘£5,4,2)
6 :(ğ‘£4,ğ‘£2,5,1)
7 :(ğ‘£1,ğ‘£5,2,5)
8 :(ğ‘£5,ğ‘£7,7,1)
9 :(ğ‘£2,ğ‘£5,6,3)
10 :(ğ‘£5,ğ‘£6,6,3)
11 :(ğ‘£5,ğ‘£6,9,1)
12 :(ğ‘£7,ğ‘£8,9,1)
13 :(ğ‘£5,ğ‘£8,10,1)ğ¸dep
1:1
2 :2
3 :7
4 :3
5 :4
6 :5
7 :6
8 :9
9 :10
10 :8
11 :11
12 :12
13 :13ğ¸dep
no
de
1:[1,7,3]
2
:[2,5,9]
3
:[4]
4
:[6]
5
:[10,8,11,13]
6
:[]
7:[12]
8
:[]ğ¸arr
dep
1 : 1
2 : 1
3 : 3
4 : 1
5 : 2
6 : 1
7 : 2
8 : 2
9 : 3
10 : 1
11 : 3
12 : 1
13 : 4
Figur e1:Anexample ofatemp oral graph, wher eğ‘›=8,ğ‘€=13,ğ‘‡=11.The lowerpart ofthelabelofeach temp oral edge
indicates itsavailability timeğœanditstraversal timeğœ†(hence ,thearrival time ofthetemp oral edgeisğœ+ğœ†).The(overline d)
upperpart ofthelabelofeach temp oral edgeindicates itsposition intheğ¸arrlist.Theğ¸dep,ğ¸dep
node,ğ¸arr
deplists also refer tothe
(overline d)indexesofğ¸arr.Theunderline dindices, instead, indicate theposition ofthecorresponding edgeinğ¸arrinto thethe
listğ¸dep
nodeof its tail.
ğ‘£1ğ‘£2ğ‘£3ğ‘£4ğ‘£5 ğ‘£6 ğ‘£7 ğ‘£8
ğ‘£1{âŸ¨1âŸ©,âŸ¨3âŸ©}{âŸ¨1,2âŸ©}{âŸ¨1,2,4âŸ©}{âŸ¨7âŸ©}{âŸ¨3,9,11âŸ©}{âŸ¨7,8âŸ©}{âŸ¨7,8,12âŸ©,âŸ¨3,9,13âŸ©}
ğ‘£2âˆ…{âŸ¨2âŸ©}{âŸ¨2,4âŸ©}{âŸ¨5âŸ©,âŸ¨9âŸ©}{âŸ¨5,10âŸ©,âŸ¨9,11âŸ©}{âŸ¨5,8âŸ©}{âŸ¨9,13âŸ©}
ğ‘£3âˆ…{âŸ¨4,6âŸ©}{âŸ¨4âŸ©}{âŸ¨4,6,9âŸ©}{âŸ¨4,6,9,11âŸ©}âˆ…{âŸ¨4,6,9,13âŸ©}
ğ‘£4âˆ…{âŸ¨6âŸ©}âˆ… {âŸ¨6,9âŸ©}{âŸ¨6,9,11âŸ©}âˆ…{âŸ¨6,9,13âŸ©}
ğ‘£5âˆ…âˆ…âˆ…âˆ… {âŸ¨10âŸ©,âŸ¨11âŸ©}{âŸ¨8âŸ©}{âŸ¨13âŸ©}
ğ‘£6âˆ…âˆ…âˆ…âˆ…âˆ… âˆ…âˆ…
ğ‘£7âˆ…âˆ…âˆ…âˆ…âˆ…âˆ… {âŸ¨12âŸ©}
ğ‘£8âˆ…âˆ…âˆ…âˆ…âˆ…âˆ…âˆ…
Table 1: The set of shortest ğ‘ ğ‘¡-walks in the graph of Figure 1, for any pair of nodes ğ‘ andğ‘¡
3.1 An example of temp oral graph
Letusconsider thetemporalgraph intheleftpart ofFigur e1.The
first listinthefigur eshowsğ¸arr(that is,thelistoftemp oraledges
sorte dbynon-de creasing arrival time), while thesecond listin
thefigur eshowsğ¸dep(that is,thelistoftemp oraledges sorte dby
non-de creasing departur etime), which isspecifiedbyidentifying
thetemp oraledges bytheir position inthelistğ¸arr(thethirdand
four lists areusedbyouralgorithms). Byassumingğ›½=1and
byidentifying thetemp oraledges bytheir (overline d)position in
thelistğ¸arr,wehavethatâŸ¨1,2,4,6,9âŸ©isağ‘£1ğ‘£5-walk which can
beextende dbyeither thetemp oraledge11orthetemp oraledge
13.Onthecontrar y,âŸ¨1,5âŸ©isnotağ‘£1ğ‘£5-walk sinceğœ2=4>3=
arr(ğ‘’1)+ğ›½.Wealso havethatâŸ¨7âŸ©istheonly shortestğ‘£1ğ‘£5-walk
(with 1temp oraledge) andtheonly (shortest) foremostğ‘£1ğ‘£5-walk
(with arrival time equal to7),andâŸ¨3,9âŸ©istheonly (shortest) latest
ğ‘£1ğ‘£5-walk (with departur etime equal to4and2temp oraledges).
Finally ,bothâŸ¨7âŸ©andâŸ¨3,9âŸ©arefastestğ‘£1ğ‘£5-walks (with duration
equal to5),andonlyâŸ¨7âŸ©isalso ashortest fastestğ‘£1ğ‘£5-walk. By
considering foremost walks, wehavethatğœâˆ—
ğ‘£1,9,ğ‘£6=2,since thethe
temp oraledge(ğ‘£2,ğ‘£5,6,3)(whose indexinğ¸arris9)iscontaine d
inthetwoforemostğ‘£1ğ‘£6-walksâŸ¨3,9,11âŸ©andâŸ¨1,2,4,6,9,11âŸ©.Bysettingğ›½=0andbyconsidering latest walks, instead, wehavethat
ğœâˆ—ğ‘£1,ğ‘£2=ğœâˆ—
ğ‘£1,1,ğ‘£2+ğœâˆ—
ğ‘£1,3,ğ‘£2+ğœâˆ—
ğ‘£1,6,ğ‘£2=1+0+1=2:aswecansee,
thelatestğ‘£1ğ‘£2-walkâŸ¨1,2,4,6âŸ©iscounte dwith multiplicity 2since
itpasses twice throughğ‘£2,once viathetemp oraledge(ğ‘£1,ğ‘£2,1,1)
(whose indexinğ¸arris1)andonce viathetemp oraledge(ğ‘£4,ğ‘£2,5,1)
(whose indexinğ¸arris6).Theshortest walk fromğ‘£1toğ‘£6varies
inlength depending onthevalue ofğ›½:withğ›½=0itis6(which
isthelength ofâŸ¨1,2,4,6,9,11âŸ©),withğ›½=1itis3(which isthe
length ofâŸ¨3,9,11âŸ©),andwithğ›½â‰¥2itis2(which isthelength
ofâŸ¨7,11âŸ©).Bysettingğ›½=2andbyconsidering shortest walks,
letuscompute theğ‘£1-temp oralbetweenness ofthetemp oraledge
(ğ‘£4,ğ‘£2,5,1)(whose indexinğ¸arris6).Sinceğœâˆ—
ğ‘£1,6,ğ‘£=0forany
ğ‘£â‰ ğ‘£1,wehavethatğ‘ğ‘£1,6=0.However,ifwesetğ›½=0,then
wehavethatğœâˆ—
ğ‘£1,6,ğ‘£6=1(since thetemp oraledgeiscontaine din
theunique shortestğ‘£1ğ‘£6-walkâŸ¨1,2,4,6,9,11âŸ©),whileğœâˆ—
ğ‘£1,6,ğ‘£=0
foranyğ‘£âˆ‰{ğ‘£1,ğ‘£6}:hence ,inthiscase,ğ‘ğ‘£1,6=1.Ifğ›½=1,we
havethat thetemp oralbetweenness vectors arepairwise distinct
depending onthechosen measur e,asshowninTable 2.Letus,for
example ,compute thetemp oralbetweenness ofnodeğ‘£2inthecase
ofshortest walks. Table 1shows,foranypairofnodesğ‘ andğ‘¡,the
 
166Making Temporal Betweenness Computation Faster and Restless KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
ğ‘£1ğ‘£2ğ‘£3ğ‘£4ğ‘£5ğ‘£6ğ‘£7ğ‘£8
Shortest 0.0 9.5 2.0 4.0 10.0 0.0 0.5 0.0
Foremost 0.0 9.5 2.5 4.5 10.0 0.0 3.0 0.0
Latest 0.0 13.5 6.0 8.0 10.0 0.0 0.0 0.0
Fastest 0.0 10.5 2.0 4.0 10.0 0.0 0.0 0.0
Shortest foremost 0.0 9.0 2.0 4.0 10.0 0.0 3.0 0.0
Shortest latest 0.0 12.0 3.0 5.0 10.0 0.0 0.0 0.0
Shortest fastest 0.0 10.0 2.0 4.0 10.0 0.0 0.0 0.0
Table 2: The temporal betweenness vectors with different
types of optimal walks for the temporal graph of Figure 1.
set of shortest ğ‘ ğ‘¡-walks. Node ğ‘£2is contained as an inner node in
the following walks: the ğ‘£1ğ‘£3-walkâŸ¨1,2âŸ©, theğ‘£1ğ‘£4-walkâŸ¨1,2,4âŸ©, the
ğ‘£1ğ‘£6-walkâŸ¨3,9,11âŸ©, theğ‘£1ğ‘£8-walkâŸ¨3,9,13âŸ©, theğ‘£3ğ‘£5-walkâŸ¨4,6,9âŸ©,
theğ‘£3ğ‘£6-walkâŸ¨4,6,9,11âŸ©, theğ‘£3ğ‘£8-walkâŸ¨4,6,9,13âŸ©, theğ‘£4ğ‘£5-walk
âŸ¨6,9âŸ©, theğ‘£4ğ‘£6-walkâŸ¨6,9,11âŸ©, and theğ‘£4ğ‘£8-walkâŸ¨6,9,13âŸ©. All these
10walks are the only shortest paths from their corresponding
sources to their corresponding destinations, apart from the ğ‘£1ğ‘£8-
walkâŸ¨3,9,13âŸ©(there is also the ğ‘£1ğ‘£8-walkâŸ¨7,8,12âŸ©). Hence, each of
them contribute 1to the temporal betweenness of ğ‘£2apart from
theğ‘£1ğ‘£8-walk which contributes 0.5. In conclusion, the temporal
betweenness of ğ‘£2is9.5(as shown in the Table 2).
4 COMPUTING THE SFOBETWEENNESS
In this section we describe an algorithm to compute the ğ‘ -SFo
betweenness ğ‘ğ‘ ,ğ‘’of all temporal edges ğ‘’, for a given source node ğ‘ ,
which runs in time linear in ğ‘€, that is, the number of temporal edges.
By repeating the computation for each source and by using the
fact that the SFobetweenness of any vertex can be computed from
theğ‘ -SFobetweenness of the temporal edges, it is then possible to
aggregate these ğ‘ -SFobetweennesses to obtain the SFobetweenness
of all nodes in time ğ‘‚(ğ‘›ğ‘€). The algorithm consists of three phases,
a forward, an intermediate, and a backward one. The goal of the
forward phase is to count, for each temporal edge ğ‘’, the number
ofShğ‘ ğ‘’-walks and, at the same time, to identify the set of its
successors, that is, the set of edges ğ‘“that can follow ğ‘’in aShğ‘ ğ‘¡-
walk, for some target node ğ‘¡. During the intermediate phase we
compute, for each node ğ‘£, the number of SFoğ‘ ğ‘£-walks and their cost
(that is, the pair including the arrival time and the number of edges
in the walk). Finally, the goal of the backward phase is to report the ğ‘ -
SFobetweenness of the edges following the successor dependencies.
In the following, given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), we assume
thatğºis represented through its ğ¸arrandğ¸deplists (recall that the
temporal edges in ğ¸depare identified by their position in the list
ğ¸arr). We also assume that, by using these two lists, the following
two other lists have been pre-computed, where, once again, each
temporal edge is identified by its position in ğ¸arr(see also the
example in Figure 1): ğ¸dep
node, which, for every ğ‘£âˆˆğ‘‰, contains the list
ğ¸dep
node[ğ‘£]of temporal edges whose tail is ğ‘£, sorted in non-decreasing
order with respect to their departure time, and ğ¸arr
dep, which, for
everyğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸, contains the position of ğ‘’inğ¸dep
node[ğ‘¢]
(more precisely, if ğ‘’is theğ‘–-th temporal edge in ğ¸arrand theğ‘—-th
temporal edge in ğ¸dep
node[ğ‘¢], thenğ¸arr
dep[ğ‘–]=ğ‘—). Note that both ğ¸dep
node
andğ¸arr
depcan easily be computed in linear-time starting from ğ¸arr
andğ¸dep.4.1 The non-restless case
We first introduce the algorithm for computing the SFobetweenness
in the caseğ›½=âˆ, that is, without waiting constraints ornon-restless
(see Algorithm 1), whose forward phase is built upon the algorithm
of [9] for computing single-source minimum-cost walks.
Algorithm 1: Compute non-restless SFoğ‘ğ‘ ,ğ‘’, for allğ‘’âˆˆğ¸
input :ğº=(ğ‘‰,ğ¸,âˆ)(represented by ğ¸depandğ¸arr) andğ‘ âˆˆğ‘‰
output :ğ‘ -SFo betweenness ğ‘ğ‘ ,ğ‘’, for allğ‘’âˆˆğ¸
1Compute the lists ğ¸dep
nodeandğ¸arr
dep;
2foreachğ‘£âˆˆğ‘‰doğ‘™[ğ‘£]:=1;ğ‘[ğ‘£]:=âˆ;ğœ[ğ‘£]:=0;
3foreachğ‘’âˆˆğ¸doğ¿[ğ‘’]:=0;ğ¶[ğ‘’]:=âˆ;Î£[ğ‘’]:=0;
4foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸arrdo
5ifğ¸arr
dep[ğ‘’]â‰¥ğ‘™[ğ‘¢]then Finalize(ğ‘¢,ğ¸arr
dep[ğ‘’]);
6ifğ‘¢=ğ‘ thenğ¶[ğ‘’]:=1;Î£[ğ‘’]:=1;
7ifğ¶[ğ‘’]â‰ âˆthen
8 ifğ¶[ğ‘’]â‰¤ğ‘[ğ‘£]then
9ğ‘=ğ‘™[ğ‘£];ğ·:=ğ¸dep
node[ğ‘£];
10 whileğ‘â‰¤|ğ·|âˆ§dep(ğ¸arr[ğ·[ğ‘]])<ğœ+ğœ†doğ‘:=ğ‘+1;
11 Finalize(ğ‘£,ğ‘âˆ’1);
12 ifğ¶[ğ‘’]<ğ‘[ğ‘£]thenğ‘[ğ‘£]:=ğ¶[ğ‘’];ğœ[ğ‘£]:=0;
13ğœ[ğ‘£]:=ğœ[ğ‘£]+Î£[ğ‘’];ğ¿[ğ‘’]:=ğ‘;
14foreachğ‘£âˆˆğ‘‰doğ‘âˆ—[ğ‘£]:=[âˆ,âˆ];ğœâˆ—[ğ‘£]:=0;ğ›¿[ğ‘£]:=0;
15foreachğ‘’âˆˆğ¸doÎ£âˆ—[ğ‘’]:=0;ğ‘[ğ‘’]:=0;
16foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸arrdo
17 ifğ¶[ğ‘’]<âˆâˆ§[ arr(ğ‘’),ğ¶[ğ‘’]]â—ğ‘âˆ—[ğ‘£]then
18ğ‘âˆ—[ğ‘£]:=[arr(ğ‘’),ğ¶[ğ‘’]];
19foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸arrdo
20 if[arr(ğ‘’),ğ¶[ğ‘’]]=ğ‘âˆ—[ğ‘£]then
21 Î£âˆ—[ğ‘’]:=Î£[ğ‘’];ğœâˆ—[ğ‘£]:=ğœâˆ—[ğ‘£]+Î£[ğ‘’];
22foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆreverse(ğ¸arr):ğ¿[ğ‘’]>0do
23 ifğ‘âˆ—[ğ‘£]â—[arr(ğ‘’),ğ¶[ğ‘’]]then
24ğ›¿[ğ‘£]:=0;ğ‘âˆ—[ğ‘£]:=[arr(ğ‘’),ğ¶[ğ‘’]];
25 forğ‘“âˆˆğ¸dep
node[ğ‘£][ğ¿[ğ‘’]:ğ‘™[ğ‘£]âˆ’1]do
ğ›¿[ğ‘£]:=ğ›¿[ğ‘£]+ğ‘[ğ‘“]/Î£[ğ‘“];
26ğ‘™[ğ‘£]:=ğ¿[ğ‘’];ğ‘[ğ‘’]:=Î£[ğ‘’]ğ›¿[ğ‘£];
27 ifÎ£âˆ—[ğ‘’]>0thenğ‘[ğ‘’]:=ğ‘[ğ‘’]+Î£âˆ—[ğ‘’]/ğœâˆ—[ğ‘£];
28returnğ‘
29Finalize(ğ‘¢,ğ‘—):
30 ifğ‘[ğ‘¢]â‰ âˆthen
31 foreachğ‘“âˆˆğ¸dep
node[ğ‘™[ğ‘¢],ğ‘—]do
ğ¶[ğ‘“]:=ğ‘[ğ‘¢]+1;Î£[ğ‘“]:=ğœ[ğ‘¢];
32ğ‘™[ğ‘¢]:=ğ‘—+1;
Forward phase (lines 4-13). Letğºğ‘˜=(ğ‘‰,ğ¸ğ‘˜,âˆ)be the temporal
graph containing only the first ğ‘˜temporal edges in ğ¸arr. The algo-
rithm scans the edges in ğ¸arrone after the other and after scanning
ğ‘˜edges, for each node ğ‘£âˆˆğ‘‰, it updates the following three values:
the lengthğ‘[ğ‘£]of any Shğ‘ ğ‘£-walk inğºğ‘˜, the number ğœ[ğ‘£]of these
walks inğºğ‘˜, and the position ğ‘™[ğ‘£]inğ¸dep
node[ğ‘£]such that all temporal
edges inğ¸dep
node[ğ‘£]starting from this position can extend a Shğ‘ ğ‘£-
walk inğºğ‘˜. Note thatğ‘[ğ‘£]can only decrease as ğ‘˜increases, while
ğ‘™[ğ‘£]can only increase. At the beginning, for each node ğ‘£,ğ‘[ğ‘£]=âˆ,
ğœ[ğ‘£]=0, andğ‘™[ğ‘£]=1. Suppose that the first ğ‘˜âˆ’1temporal edges
have been scanned, and that the edge ğ‘’ğ‘˜=(ğ‘¢,ğ‘£,ğœ,ğœ†)has now to be
 
167KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
analysed. Let us first analyse ğ‘’ğ‘˜from the point of view of its tail,
that is,ğ‘¢. Clearly,ğ‘’ğ‘˜is included in ğ¸dep
node[ğ‘¢]: suppose that it appears
in positionğ‘–. Ifğ‘–â‰¥ğ‘™[ğ‘¢], then all temporal edges between position
ğ‘™[ğ‘¢]andğ‘–, which have a departure time not greater than dep(ğ‘’ğ‘˜),
cannot extend any ğ‘ ğ‘¢-walk ending with a temporal edge following
ğ‘’ğ‘˜inğ¸arr, since such a temporal edge has arrival time greater than
dep(ğ‘’ğ‘˜). Each such edge ğ‘“can then be â€œfinalisedâ€ (lines 30-32), that
is, the length ğ¶[ğ‘“]of any Shğ‘ ğ‘“-walk (inğºğ‘˜) can be set equal to
ğ‘[ğ‘¢]+1and the number Î£[ğ‘“]of these walks (in ğºğ‘˜) can be set
equal toğœ[ğ‘¢]. We use the term â€œfinaliseâ€ to emphasise that ğ¶[ğ‘“]
will be the same in ğºğ‘˜â€²forğ‘˜â€²â‰¥ğ‘˜. We can also set ğ‘™[ğ‘¢]=ğ‘–+1, since
all temporal edges in ğ¸dep
node[ğ‘¢]starting from position ğ‘–+1can still
extend a Shğ‘ ğ‘¢-walk inğºğ‘˜â€²forğ‘˜â€²â‰¥ğ‘˜. Moreover, if ğ‘¢=ğ‘ , then we
can setğ¶[ğ‘’ğ‘˜]equal to 1(since we are considering Shwalks from
ğ‘ ) and the number of Shwalks ending with ğ‘’ğ‘˜is equal to 1(since
there is only one such walk, that is, âŸ¨ğ‘’ğ‘˜âŸ©). Let us now analyse the
temporal edge ğ‘’ğ‘˜from the point of view of its head, that is, ğ‘£, by
assuming that there exists at least one Shwalk ending with ğ‘’ğ‘˜in
ğºğ‘˜. Ifğ¶[ğ‘’ğ‘˜]is not greater than ğ‘[ğ‘£](that is,ğ‘’ğ‘˜ends a Shğ‘ ğ‘£-walk),
we first compute the first position ğ‘inğ¸dep
node[ğ‘£]of a temporal edge
whose departure time is at least equal to ğœ+ğœ†(that is, a temporal
edge which can extend an ğ‘ ğ‘’-walk inğºğ‘˜). All the temporal edges in
ğ¸dep
node[ğ‘£]between the position ğ‘™[ğ‘£]and the position ğ‘âˆ’1can now be
finalised, since they cannot be the successor of any temporal edge
ofğ¸arrfollowingğ‘’ğ‘˜. We then set ğ‘™[ğ‘£]=ğ‘, since all temporal edges
inğ¸dep
node[ğ‘£]starting from position ğ‘can still extend a Shğ‘ ğ‘£-walk in
ğºğ‘˜â€²forğ‘˜â€²â‰¥ğ‘˜(in particular, they extend Shğ‘ ğ‘’-walks). Moreover, if
adding the temporal edge ğ‘’ğ‘˜toğºğ‘˜âˆ’1reduces the length ğ‘[ğ‘£]of the
Shğ‘ ğ‘£-walks (that is, ğ¶[ğ‘’ğ‘˜]<ğ‘[ğ‘£]), then we have to update ğ‘[ğ‘£],
by setting it equal to ğ¶[ğ‘’ğ‘˜](that is, the length of the Shğ‘ ğ‘’ğ‘˜-walks),
andğœ[ğ‘£]by setting it equal to the number Î£[ğ‘’ğ‘˜]ofShğ‘ ğ‘’ğ‘˜-walk in
ğºğ‘˜. Otherwise (that is, ğ¶[ğ‘’ğ‘˜]=ğ‘[ğ‘£]and adding the temporal edge
ğ‘’ğ‘˜toğºğ‘˜âˆ’1does not change the length ğ‘[ğ‘£]of the Shğ‘ ğ‘£-walks), the
number Î£[ğ‘’ğ‘˜]ofShğ‘ ğ‘’ğ‘˜-walk inğºğ‘˜has to be added to ğœ[ğ‘£](since
allShğ‘ ğ‘’ğ‘˜-walks are also Shğ‘ ğ‘£-walks). Finally, we store in ğ¿[ğ‘’ğ‘˜]the
positionğ‘inğ¸dep
node[ğ‘£], which is the first position of the successors
ofğ‘’(to be used in the backward phase).
Intermediate phase (lines 16-21). Once we have computed, for
eachğ‘’âˆˆğ¸, the length ğ¶[ğ‘’]of any Shğ‘ ğ‘’-walk and the number
Î£[ğ‘’]of these walks, it is easy to compute, for each ğ‘£âˆˆğ‘‰,ğ‘âˆ—[ğ‘£],
whereğ‘âˆ—[ğ‘£]specifies both the arrival time ğ‘âˆ—[ğ‘£][1]and the length
ğ‘âˆ—[ğ‘£][2]of any SFoğ‘ ğ‘£-walk. Indeed, it suffices to scan the temporal
edges inğ¸arrand, for each edge ğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†), to verify whether
(arr(ğ‘’),ğ¶[ğ‘’])â—ğ‘âˆ—[ğ‘£]in which case ğ‘âˆ—[ğ‘£]has to be set equal to
(arr(ğ‘’),ğ¶[ğ‘’])(lines 16-18). Once ğ‘âˆ—[ğ‘£]has been computed for each
ğ‘£âˆˆğ‘‰, the number ğœâˆ—[ğ‘£]ofSFoğ‘ ğ‘£-walks can also be computed.
Indeed, it suffices to scan again the temporal edges in ğ¸arrand, for
each edgeğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†), to verify whether(arr(ğ‘’),ğ¶[ğ‘’])=ğ‘âˆ—[ğ‘£]in
which caseğœâˆ—[ğ‘£]has to be increased by the value Î£[ğ‘’](lines 19-21).
Note that, at the same time, we can also compute the number Î£âˆ—[ğ‘’]
ofSFoğ‘ ğ‘’-walks.
Backward phase (lines 22-27). The backward phase simply ap-
plies Lemma 1 in a â€œreverseâ€ way, by scanning the temporal edges
inğ¸arrfrom the last to the first one and, for each scanned edge
ğ‘’, by accumulating on its head ğ‘£the contribution to ğ‘ğ‘ ,ğ‘’of eachsuccessor of ğ‘’. More precisely, we store in ğ›¿[ğ‘£]the partial sumÃ
ğ‘“âˆˆğ¸dep
node[ğ‘£][ğ‘™[ğ‘£]:ğ‘§]ğ‘[ğ‘“]
Î£[ğ‘“]whereğ‘§denotes the last index when the
sum was zeroed. It can be updated in constant time per edge
ğ‘“âˆˆğ¸dep
node[ğ‘£]each time we encounter an edge ğ‘’with headğ‘£. Note
that each such edge ğ‘’has successors ğ¸dep
node[ğ‘£][ğ¿[ğ‘’]:ğ‘Ÿ], whereğ‘Ÿis
the position of the last edge ğ‘“inğ¸dep
nodesuch thatğ¶[ğ‘“]=ğ¶[ğ‘’]+1
and the index ğ¿[ğ‘’]of the first successor can only decrease as we
scan edgesğ‘’with lower arrival times.4As we scan the ğ‘˜th edgeğ‘’
inğ¸arr, we also maintain in ğ‘âˆ—[ğ‘£]the arrival time and the length of
anySFoğ‘ ğ‘£-walk inğºğ‘˜. Wheneverğ‘âˆ—[ğ‘£]â—(arr(ğ‘’),ğ¶[ğ‘’]), the index
ğ‘Ÿforğ‘’is indeedğ‘™[ğ‘£]âˆ’1and the quantity accumulated on ğ‘£has to
be zeroed while ğ‘âˆ—[ğ‘£]has to be updated to (arr(ğ‘’),ğ¶[ğ‘’]).
Theorem 2. For any temporal graph ğº=(ğ‘‰,ğ¸,âˆ)and for any
ğ‘ âˆˆğ‘‰, Algorithm 1 correctly computes the ğ‘ -SFo betweenness ğ‘ğ‘ ,ğ‘’in
timeğ‘‚(ğ‘€).
4.2 The restless case
We now briefly describe how Algorithm 1 has to be modified in
order to deal with the general case (that is, ğ›½â‰¤âˆ): the new algo-
rithm manages the increased complexity of the restless constraint
through appropriate lists of interval quintuples which correspond
to windows of time with temporal edges from a node that extend
the same optimal walks. Once again, we execute a forward phase
(in order to compute, for each temporal edge ğ‘’, the length ğ¶[ğ‘’]
of any Shğ‘ ğ‘’-walk and the number Î£[ğ‘’]of these walks), followed
by the same intermediate phase and a backward phase in which
Lemma 1 is applied. Note that in Algorithm 1, during the forward
phase, in order to correctly apply the lemma in the backward phase,
it sufficed to memorize, for each temporal edge ğ‘’, the position ğ¿[ğ‘’]
in the listğ¸dep
node[ğ‘£]of the first temporal edge which could extend
aShğ‘ ğ‘’-walk. This was due to the fact that, in the non-restless
case, if an en edge ğ‘“inğ¸dep
node[ğ‘£]extends ağ‘ ğ‘’-walk, then all edges
followingğ‘“inğ¸dep
node[ğ‘£]also extend the walk. In the general case,
this is not true anymore (because of the waiting constraints) and
the forward phase of the algorithm has to maintain additional infor-
mation to be used during the backward phase. In particular, given
a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), for each node ğ‘£âˆˆğ‘‰, the general
algorithm maintains a list Iğ‘£ofinterval quintuples ğ‘„=(ğ‘™,ğ‘Ÿ,ğ‘,ğ‘ƒ,ğœ‚)
where 1â‰¤ğ‘™,ğ‘Ÿâ‰¤ğ¸dep
node[ğ‘£],ğ‘âˆˆN,ğœ‚âˆˆN, andğ‘ƒâŠ†ğ¸is a list of
predecessor edges. The semantic of an interval quintuple ğ‘„is the
following.
â€¢ğ‘™andğ‘Ÿare the left and right extremes of an interval ğ‘„.ğ¼of
edges inğ¸dep
node[ğ‘£](that is,ğ‘„.ğ¼=ğ¸dep
node[ğ‘£][ğ‘™:ğ‘Ÿ]).
â€¢ğ‘is the length of any Shwalk from the source ğ‘ (in the
temporal graph induced by the edges scanned so far), such
that edges in ğ‘„.ğ¼extend it.
â€¢The edges ending these walks are predecessors of edges in
ğ‘„.ğ¼and are stored in the ordered list ğ‘ƒ(sorted by arrival
times). More precisely, for any edge ğ‘“=ğ‘„.ğ¼[ğ‘–], with 1â‰¤
4As it is common in several programming languages, given a sequence ğ´and two
positive integers ğ‘™andğ‘Ÿboth not greater than the length of ğ´and such that ğ‘™â‰¤ğ‘Ÿ, we
denote byğ´[ğ‘™:ğ‘Ÿ]the sub-sequence of ğ´from position ğ‘™to positionğ‘Ÿ, both included.
Moreover,ğ´[ğ‘™:]=ğ´[ğ‘™:|ğ´|].
 
168Making Temporal Betweenness Computation Faster and Restless KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
ğ‘–â‰¤ğ‘Ÿâˆ’ğ‘™+1, the set of edges ğ‘ƒğ‘–, that precede ğ‘“in the
above mentioned Shwalks, is a subset of ğ‘ƒ. We rely on the
fact that edges with the same predecessors partition ğ‘„.ğ¼
into consecutive intervals. Indeed, ğ‘ƒğ‘–+1is included in ğ‘ƒğ‘–if
ğ‘–â‰¤ğ‘Ÿâˆ’ğ‘™. The ordering of ğ‘ƒrespect the inclusion ordering
ğ‘ƒ1âŠ‡ğ‘ƒ2âŠ‡Â·Â·Â· so that each ğ‘ƒğ‘–is a suffix of ğ‘ƒ.
â€¢ğœ‚is the total number of Shwalks that end with an edge in ğ‘ƒ
(they all have length ğ‘).
Note that the forward and backward phases of the algorithm for
the restless case as well as the finalisation of an edge are more
complicated than in the case of the non-restless case, in order to
deal with the list of interval quintuples (the pseudo-code of this
algorithm is very similar to the one referred to in the next section).
5 COMPUTING OTHER BETWEENNESSES
In Appendix A we introduce a general cost framework, we show
how it can encompass the fastest ( Fa), foremost ( Fo),Sh, and short-
est fastest ( SFa) optimality criteria, and we briefly describe the
algorithm for computing the (restless) betweenness centrality for
any criteria that fits in the framework (see Algorithm 2).
6 THE EXPERIMENTS
In this section we perform several experimental analysis in order
to compare the performance of our algorithms with respect to the
ones previously proposed in the literature, and in order to apply
the algorithms themselves to a specific case study in the field of
public transport networks. Our experimental study includes the
following three algorithms.
â€¢bmnr : this is the algorithm proposed in [ 11] to compute the
exact values of the ShandSFobetweenness of all nodes.
â€¢Onbra : this is the approximation algorithm proposed in [ 39],
which is based on a sampling technique for obtaining an
absolute approximation of the Shbetweenness values (both
in the non restless and in the restless case).
â€¢Fast : this is the algorithm described in the previous sections,
for computing the exact values of the SFo(restless) between-
ness, and in Appendix A for computing the exact values of
the other (restless) betweenness measures.
To analyse the correlation between different centrality rankings,
we used different metrics: the Kendallâ€™s ğœcorrelation coefficient [ 25],
a weighted version of this coefficient [ 48], and the intersection of
the top-1000 ranked nodes (note that the latter metric is directly
translatable into the Jaccard similarity of the top ranked nodes).
For the weighted Kendallâ€™s ğœcoefficient, we used the hyperbolic
weighting scheme, that gives weights to the positions in the rank-
ing which decay harmonically with the ranks, i.e., the weight of
rankğ‘Ÿis1/(ğ‘Ÿ+1). Both the Kendallâ€™s ğœcorrelation coefficient and
its weighted version has been computed by using the Java code
available at the Laboratory for Web Algorithmics [ 5]. For the sake
of brevity, we here discuss the weighted Kendall ğœresults only.
6.1 Comparing algorithms execution times
First, we compare the running time of bmnr , ofOnbra , and of Fast .
We present here the results concerning only the computation of
theShbetweenness: however, the results are similar in the case ofNetw
ork n M T URL tBMNR tFasttBMNR
tFast
Infectious 10972
831824 76944 [14] 3111.19 1603.53 1.94
DiggReply 30360 86203 82641 [36] 1190.41 506.53 2.35
FacebookWall 35817 198028 194904 [36] 3410.98 1317.76 2.59
SMS 44090 544607 467838 [36] 12476.04 4721.05 2.64
SlashdotReply 51083 139789 89862 [36] 4489.14 1643.77 2.73
WikiElections 7115 106985 101012 [29] 521.11 113.68 4.58
CollegeMsg 1899 59798 58911 [29] 242.81 23.20 10.47
Topology 16564 198038 32823 [27] 8704.15 792.82 10.98
Hypertext09 113 41636 5246 [14] 83.63 0.80 104.37
HighSchool11 126 57078 5609 [14] 132.33 1.18 111.86
HighSchool12 180 90094 11273 [14] 394.70 2.93 134.89
PrimarySchool 242 251546 3100 [14] 1895.45 12.92 146.67
EmailEU 986 327336 207880 [29] 11942.84 72.24 165.32
HighSchool13 327 377016 7375 [14] 7131.86 29.63 240.67
HospitalWard 75 64848 9453 [14] 204.43 0.83 247.49
Table 3: The temporal graphs used in our first experiment,
whereğ‘›denotes the number of nodes, ğ‘€the number of tem-
poral edges, ğ‘‡the number of unique time steps, and tBMNR
and tFastthe execution time of BMNR andFast, respectively.
theSFobetweenness. We used the Julia implementation of bmnr
associated to [ 2] and available at [ 3].5We also implemented Fast
in Julia: our code is available at https://github.com/piluc/TWBC.
Finally, we made use of the results reported in [ 39] which, in turn,
made use of the C implementation of Onbra available at [ 40]. We
executed the experiments on a server running Ubuntu 20.04.5 LTS
112 with processors Intel(R) Xeon(R) Gold 6238R CPU @ 2.20GHz
and 112GB RAM.
Dataset. In this first experiment, we execute the algorithms on
the set of temporal graphs used in [ 2], which includes almost all
the networks of [ 11] and of [ 39]. As stated in [ 2], this set does not
include one temporal graph used in [ 11], because it does not appear
to be available anymore, and it replaces one temporal graph used
in [39] by a bigger one from a different domain to make the set of
analyzed temporal graphs more diverse. The properties of these
networks are summarized in the first five columns of Table 3.
Results. The execution times of bmnr and of Fast are shown in
the 6th and 7th columns of Table 3. As it can be seen, Fast is
between approximately two and almost 250 times faster than bmnr
(see the eighth column). It is worth observing that the execution
time of our Julia implementation of Fast is significantly lower than
the execution time (reported in [ 39]) of the C implementation of
Onbra , which was executed on an architecture not very different
from ours. Indeed, on the four temporal graphs of our dataset that
have also been used in the experimental analysis of [ 39] (that is,
College msg ,Email EU ,Facebook wall , and SMS), the execution
time of Onbra is approximately 6, 25, 2, and 3 times slower than
our algorithm (note that Onbra computed the estimates of the Sh
betweenness values, by using a sample of node pairs whose size
was less than 1%of the number of all node pairs).
6.2 Analysing three larger temporal graphs
In [39], the authors consider three other temporal graphs, whose
properties are summarised in the first five columns of Table 4. Ac-
cording to the authors, on these temporal graphs the algorithm
bmnr was not able to conclude the computation on their machine
5As stated in [ 2], the original C implementations of bmnr caused overflow (indicated
by negative centralities) and out of memory errors.
 
169KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
T
emporal graph n M T Source tbmnr tFasttbmnr
tFasttOnbra Sample
size Weighted ğœ
MathOverflow 24759
390414 389952 [29] 46594 2117 22.01 36983 30650 0 .88
AskUbuntu 157222 726639 724715 [29] 421781 32280 13.07 35585 14831 0 .86
SuperUser 192409 1108716 1105102 [29] 972104 63553 15.30 41856 11106 0 .86
Table 4: The temporal graphs used in our second experiment, where ğ‘¡bmnr denotes the execution time of BMNR, tFastthe
execution time of Fast, andğ‘¡Onbrathe execution time of Onbra reported in [ 39]. The last two columns show the sample size
used by Onbra and the weighted Kendall ğœcoefficient of the ranking produced by Onbra with this sample size, respectively.
since it required too much memory, while Onbra could provide
estimates of the Shbetweenness centrality values in the time in-
dicated in the eighth column of the table. The memory problems
ofbmnr have been already solved in the Julia implementation of
bmnr , by using dictionaries instead of matrices. Hence, we have
been able to execute the algorithm bmnr with input these three
temporal graphs. By using Fast , the computation of the exact Sh
betweenness values requires approximately 0.6, 9, and 17.7 hours,
thus significantly improving over bmnr (very similar results hold
in the case of the SFobetweenness). Moreover, the execution time
of our Julia implementation of Fast on the three networks is sig-
nificantly less than, comparable with, and approximately 1.5 bigger
than the reported execution time of the C implementation of Onbra
(recall that Onbra computes estimates of the betweenness values).
The second to last column of Table 4 shows the sample size used
byOnbra , which is the one reported in [ 39], while the last column
shows the weighted Kendall ğœcoefficient between the ranking pro-
duced by Fast and the one produced by Onbra with this sample
size. As it can be seen, in order to be competitive in terms of ex-
ecution time, Onbra produces centrality values which are quite
imprecise in terms of rankings. Once we have computed the Shand
SFobetweenness exact values, we analysed the correlation between
these measures. These correlations are very high, especially if we
consider the weighted Kendallâ€™s ğœcoefficient or the intersection of
the top-1000 ranked nodes, whose values are 0.97,0.98, and 0.98,
and949, 960, and 962, respectively. Hence, if we look for the top
nodes in the rankings, then there is not so much difference between
using the Shand the SFobetweenness measure.
6.3 Analysing ranking correlations
Our third experiment consists of comparing the rankings of the
nodes of a temporal graph when sorted according to their between-
ness values, computed with different waiting constraints and for
different walk optimality criteria. In particular, we considered the
following values of ğ›½:300, 600, 1200, 2400, andâˆ. Moreover, we
computed the Fa,Fo,Sh,SFa, and SFobetweenness values (by
using the general Fast algorithm, that is, Algorithm 2 in the appen-
dix). However, we did not compute the Foand the Fabetweenness
values in the case ğ›½=âˆ, due to the huge number of optimal walks:
this involves using Julia number data structures which causes our
algorithm to take an excessive amount of time needed to calcu-
late the exact betweenness values. For the very same reason (for
different values of ğ›½), we excluded the Topology network from
the dataset used in this experiment, which otherwise is the same
as the one used in the first experiment. We observe that all the
betweenness measures are highly correlated, with the Shand the
Figure 2: The quartiles of the weighted Kendall ğœover 14
networks, for each pair of betweenness measures ( ğ›½=2400).
SFabetweenness being the two more correlated (see the box plot
of Figure 2, which show the quartiles of the correlation values for
ğ›½=2400). In particular, in half of the networks in the dataset the
weighted Kendall ğœfor this pair of betweenness measures with
ğ›½=2400 is at least 0.97and the minimum weighted Kendall ğœ
is0.84. This minimum value is reached in correspondence of the
Primary school network, for which the weighted Kendall ğœis the
minimum one for all the pairs of betweenness measures. Another
interesting observation is that the weighted Kendall ğœvalues seem
to depend on the waiting constraints. Indeed, we can observe that
these values tend to decrease as ğ›½increases, as shown in the left
Figure 3: The average weighted Kendall ğœover 14 networks,
for all pairs of betweenness measures, as a function of ğ›½.
 
170Making Temporal Betweenness Computation Faster and Restless KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
City n
M m M/m t Fast tB
Berlin 4601
1048209 12359 85 35555 8 .03
Bordeaux 3435 236595 4040 59 2336 2 .95
Kuopio 549 32117 979 33 126 0 .07
Paris 11950 1823871 16704 109 121157 33 .51
Rome 7869 1051211 10143 104 70236 18 .77
Venice 1874 118480 3464 34 439 0 .67
Table 5: The 6 cities analysed in our case study: ğ‘šdenotes the
number of edges in the underlying graph, while ğ‘¡Bdenotes
the execution time of the Brandesâ€™ algorithm on this graph.
Figure 4: The weighted Kendall ğœbetween the SFaand the
SFobetweenness rankings (solid) and between the SFobe-
tweenness and the betweenness rankings (dashed), for each
public transport network and for ğ›½=300,600,1200,2400,âˆ.
part of Figure 3 where the average weighted Kendall ğœvalues over
the fourteen networks is shown as a function of the value of ğ›½. This
behaviour can be justified by the fact that when ğ›½increases the set
of optimal walks with respect to different betweenness measures
may be quite different: that is, the more stringent are the waiting
constraints the more similar are the sets of optimal walks.
6.4 Analysing public transport networks
In all the networks analysed so far the traversal time of all temporal
edges is equal to 1. In this last experiment, instead, we use a subset
of the dataset published in [ 26] and used [ 15]. This dataset includes
25 citiesâ€™ public transport networks: the list of the cities that we
used in our experiment is summarized in Table 5. In this experiment,
we focus on the SFaand the SFobetweenness values, because of
two main reasons. First, each temporal edge of the temporal graph
relates to the connection between two stations of a transport trip:
hence, counting the number of temporal edges in a walk does not
indicate the number of transfers (which instead should be more
interesting to analyse in the case of a public transport network).
For this reason, we have not analysed the Shbetweenness mea-
sure. Secondly, focusing on walks which are the shortest among the
fastest and the foremost ones allows us to analyse walks which are
the closest to being paths in the case of waiting constraints (which
are both desirable properties in the case of public transport trips).
Given a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), the underlying graph ofğºis
the graph whose set of nodes is ğ‘‰and whose set of edges containsall pairs(ğ‘¢,ğ‘£)such that(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸, for someğœandğœ†. The main
goal of this experiment is to verify how much the SFaand the SFo
betweenness measures of a temporal graph are correlated to the
(classical) betweenness measure of the corresponding underlying
graph. In the second to last column of the table we show the average
execution time of the Fast algorithm computing the SFaand the
SFobetweenness with ğ›½=300,600,1200,2400,âˆ, while the last
column shows the execution time for computing the betweenness
values of the underlying graph by using the Brandesâ€™ algorithm [ 7]
(as implemented in the Julia Graphs package [ 18]). As it can be seen,
this latter algorithm is significantly faster than the Fast algorithm.
Actually, we might expect an additional multiplicative factor close
to the ratio ğ‘€/ğ‘š, whereğ‘šdenotes the number of edges in the
underlying graph. In practice, this factor is between 20 and 50 times
bigger because of two main reasons: on the one hand, our code for
the general case is not as optimised as the code for the non-restless
case thus leading to a code around ten times slower, on the other
hand we are forced to use big data structures in order to deal with
the huge number of optimal walks (which is not the case with the
underlying graphs). Since computing the betweenness of the un-
derlying graph is significantly faster than our algorithm, it is worth
determining the correlation between this betweenness and the SFa
and the SFobetweenness. As it is shown in Figure 4, the weighted
Kendallğœbetween the SFaand the SFobetweenness rankings is
very high for all values of ğ›½. On the contrary, the weighted Kendall
ğœbetween the SFobetweenness and the betweenness rankings is
significantly lower, especially when ğ›½=300orğ›½=600, which
correspond to five and ten minutes of waiting time, respectively
(similar results hold for the SFabetweenness). These results thus
suggest that the betweenness of the underlying graph cannot be
used as a proxy of the SFaand the SFobetweenness, whenever
waiting constraints have to be satisfied. This contrasts with what
has been shown in [ 2], where the authors found high correlations
between the Shbetweenness with ğ›½=âˆ(that is, when no waiting
constraint are used) and the betweenness of the underlying graph.
7 FURTHER RESEARCH
As we follow the framework of [ 9], our algorithm can support more
general waiting constraints and edge weights/costs with appro-
priate cost and target-cost structures. From a theoretical point of
view, it would be interesting to look for conditional lower bound
on the computation of the betweenness in the restless case. From
an experimental point of view, instead, it would be worth enriching
the temporal graph model and appropriately modify our algorithms
in order to take into account the number of transfers in public
transport networks, and, thus, focusing on the betweenness values
based on the walks with the minimum number of transfers. Finally,
we think it would worth comparing our algorithm with more recent
papers that propose exact [ 50] and approximate [ 17] algorithms for
computing the temporal betweenness in the non-restless case.
ACKNOWLEDGMENTS
This work is partially supported by PNRR MIUR project GAMING
â€œGraph Algorithms and MinINg for Green agentsâ€ (PE0000013, CUP
D13C24000430001) and by ANR project TEMPOGRAL (ANR-22-
CE48-0001).
 
171KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
REFERENCES
[1]Alex Bavelas. 1950. Communication patterns in task-oriented groups. The journal
of the acoustical society of America 22, 6 (1950), 725â€“730.
[2]Ruben Becker, Pierluigi Crescenzi, Antonio Cruciani, and Bojana Kodric. 2023.
Proxying Betweenness Centrality Rankings in Temporal Networks. In 21st Inter-
national Symposium on Experimental Algorithms (LIPIcs, Vol. 265). 6:1â€“6:22.
[3]Ruben Becker, Pierluigi Crescenzi, Antonio Cruciani, and Bojana Kodric. last
checked on October 13, 2023. TSBProxy. https://github.com/piluc/TSBProxy.
[4]Ferenc BÃ©res, RÃ³bert PÃ¡lovics, Anna OlÃ¡h, and AndrÃ¡s A BenczÃºr. 2018. Temporal
walk based centrality metric for graph streams. Applied network science 3, 1 (2018),
32:1â€“32:26.
[5]Paolo Boldi, Massimo Santini, and Sebastiano Vigna. last checked on December
31, 2023. Crawdad. https://law.di.unimi.it.
[6]Michele Borassi and Emanuele Natale. 2019. KADABRA is an ADaptive Algorithm
for Betweenness via Random Approximation. ACM J. Exp. Algorithmics 24, 1
(2019), 1.2:1â€“1.2:35.
[7]Ulrik Brandes. 2001. A faster algorithm for betweenness centrality. Journal of
mathematical sociology 25, 2 (2001), 163â€“177.
[8]Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot. 2021. On computing
Pareto optimal paths in weighted time-dependent networks. Inf. Process. Lett.
168 (2021), 106086.
[9]Filippo Brunelli and Laurent Viennot. 2022. Minimum-Cost Temporal Walks
under Waiting-Time Constraints in Linear Time. CoRR abs/2211.12136 (2022).
https://doi.org/10.48550/arXiv.2211.12136 arXiv:2211.12136
[10] Binh-Minh Bui-Xuan, Afonso Ferreira, and Aubin Jarry. 2003. Computing Short-
est, Fastest, and Foremost Journeys in Dynamic Networks. Int. J. Found. Comput.
Sci.14, 2 (2003), 267â€“285.
[11] Sebastian BuÃŸ, Hendrik Molter, Rolf Niedermeier, and Maciej Rymar. 2020. Algo-
rithmic Aspects of Temporal Betweenness. In KDD â€™20: The 26th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining, Virtual Event, CA, USA,
August 23-27, 2020, Rajesh Gupta, Yan Liu, Jiliang Tang, and B. Aditya Prakash
(Eds.). ACM, 2084â€“2092. https://doi.org/10.1145/3394486.3403259
[12] Arnaud Casteigts, Paola Flocchini, Walter Quattrociocchi, and Nicola Santoro.
2012. Time-varying graphs and dynamic networks. IJPEDS 27, 5 (2012), 387â€“408.
[13] Arnaud Casteigts, Anne-Sophie Himmel, Hendrik Molter, and Philipp Zschoche.
2021. Finding Temporal Paths Under Waiting Time Constraints. Algorithmica 83,
9 (2021), 2754â€“2802.
[14] Ciro Cattuto and Alain Barrat. last checked on October 4, 2022. SocioPatterns.
https://www.sociopatterns.org/.
[15] Pierluigi Crescenzi, ClÃ©mence Magnien, and Andrea Marino. 2019. Approximat-
ing the Temporal Neighbourhood Function of Large Temporal Graphs. Algorithms
12, 10 (2019), 211.
[16] Pierluigi Crescenzi, ClÃ©mence Magnien, and Andrea Marino. 2020. Finding Top- ğ‘˜
Nodes for Temporal Closeness in Large Temporal Graphs. Algorithms 13, 9 (2020),
211.
[17] Antonio Cruciani. 2024. MANTRA: Temporal Betweenness Centrality Approxi-
mation through Sampling. arXiv:2304.08356 [cs.DS]
[18] James Fairbanks, Mathieu BesanÃ§on, SchÃ¶lly Simon, JÃºlio Hoffiman, Nick Eubank,
and Stefan Karpinski. last checked on February 4, 2024. JuliaGraphs/Graphs.jl:
an optimized graphs package for the Julia programming language. https://github.
com/JuliaGraphs/Graphs.jl.
[19] Lucia Falzon, Eric Quintane, John Dunn, and Garry Robins. 2018. Embedding
time in positions: Temporal measures of centrality for social network analysis.
Social Networks 54 (2018), 168â€“178.
[20] Afonso Ferreira. 2004. Building a reference combinatorial model for MANETs.
IEEE Netw. 18, 5 (2004), 24â€“29.
[21] Luca Foschini, John Hershberger, and Subhash Suri. 2014. On the Complexity of
Time-Dependent Shortest Paths. Algorithmica 68, 4 (2014), 1075â€“1097.
[22] Linton C. Freeman. 1977. A Set of Measures of Centrality Based on Betweenness.
Sociometry 40, 1 (March 1977), 35â€“41. https://doi.org/10.2307/3033543
[23] Marwan Ghanem, Florent Coriat, and Lionel Tabourier. 2017. Ego-betweenness
centrality in link streams. In Proceedings of the 2017 IEEE/ACM International
Conference on Advances in Social Networks Analysis and Mining 2017, Sydney,
Australia, July 31 - August 03, 2017. ACM, 667â€“674.
[24] Petter Holme. 2015. Modern temporal network theory: a colloquium. The
European Physical Journal B 88 (2015), 234.
[25] Maurice G Kendall. 1938. A new measure of rank correlation. Biometrika 30, 1/2
(1938), 81â€“93.
[26] R. Kujala, C. WeckstrÃ¶m, R. Darst, M. MadlenociÄ‡, and J. SaramÃ¤ki. 2018. A
collection of public transport network data sets for 25 cities. Sci. Data 5 (2018),
article number: 180089.
[27] J. Kunegis. last checked on October 4, 2022. The KONECT Project. http://konect.
cc.
[28] Matthieu Latapy, Tiphaine Viard, and ClÃ©mence Magnien. 2018. Stream graphs
and link streams for the modeling of interactions over time. Soc. Netw. Anal. Min.
8, 1 (2018), 61:1â€“61:29.[29] Jure Leskovec and Andrej Krevl. last checked on October 4, 2022. SNAP Datasets:
Stanford Large Network Dataset Collection. http://snap.stanford.edu/data.
[30] Laishui Lv, Kun Zhang, Ting Zhang, Dalal Bardou, Jiahui Zhang, and Ying Cai.
2019. PageRank centrality for temporal networks. Physics Letters A 383, 12 (2019),
1215â€“1222.
[31] O. Michail. 2016. An Introduction to Temporal Graphs: An Algorithmic Perspec-
tive. Internet Mathematics 12, 4 (2016), 239â€“280.
[32] Jacob Moreno. 1934. Who Shall Survive? A new approach to the problem of human
interrelations. Nervous and Mental Disease Publishing Co.
[33] Lutz Oettershagen and Petra Mutzel. 2020. Efficient top-k temporal closeness
calculation in temporal networks. In 2020 IEEE International Conference on Data
Mining (ICDM). IEEE, 402â€“411.
[34] Lutz Oettershagen, Petra Mutzel, and Nils M. Kriege. 2022. Temporal Walk
Centrality: Ranking Nodes in Evolving Networks. In WWW â€™22: The ACM Web
Conference 2022, Virtual Event, Lyon, France, April 25 - 29, 2022. ACM, 1640â€“1650.
[35] Matteo Riondato and Eli Upfal. 2018. ABRA: Approximating Betweenness Cen-
trality in Static and Dynamic Graphs with Rademacher Averages. ACM Trans.
Knowl. Discov. Data 12, 5 (2018), 61:1â€“61:38. https://doi.org/10.1145/3208351
[36] Ryan A. Rossi and Nesreen K. Ahmed. last checked on October 4, 2022. Network
Repository. https://networkrepository.com.
[37] Polina Rozenshtein and Aristides Gionis. 2016. Temporal pagerank. In Joint
European Conference on Machine Learning and Knowledge Discovery in Databases.
Springer, 674â€“689.
[38] Maciej Rymar, Hendrik Molter, AndrÃ© Nichterlein, and Rolf Niedermeier. 2023.
Towards Classifying the Polynomial-Time Solvability of Temporal Betweenness
Centrality. J. Graph Algorithms Appl. 27, 3 (2023), 173â€“194.
[39] Diego Santoro and Ilie Sarpe. 2022. ONBRA: Rigorous Estimation of the Temporal
Betweenness Centrality in Temporal Networks. In WWW â€™22: The ACM Web
Conference 2022, Virtual Event, Lyon, France, April 25 - 29, 2022. ACM, 1579â€“1588.
[40] Diego Santoro and Ilie Sarpe. last checked on January 22, 2024. ONBRA: Rigorous
Estimation of the Temporal Betweenness Centrality in Temporal Networks. https:
//github.com/iliesarpe/onbra.
[41] Nicola Santoro, Walter Quattrociocchi, Paola Flocchini, Arnaud Casteigts, and
FrÃ©dÃ©ric Amblard. 2011. Time-Varying Graphs and Social Network Analysis:
Temporal Indicators and Metrics. CoRR abs/1102.0629 (2011).
[42] David Schoch. last checked on February 5, 2024. Periodic Table of Network
Centrality. http://schochastics.net/sna/periodic.html.
[43] David Schoch, Thomas W. Valente, and Ulrik Brandes. 2017. Correlations among
centrality indices and a class of uniquely ranked graphs. Soc. Networks 50 (2017),
46â€“54.
[44] FrÃ©dÃ©ric Simard, ClÃ©mence Magnien, and Matthieu Latapy. 2023. Computing
Betweenness Centrality in Link Streams. J. Graph Algorithms Appl. 27, 3 (2023),
195â€“217.
[45] JoÃ£o L. Sobrinho. 2005. An algebraic theory of dynamic network routing.
IEEE/ACM Trans. Netw. 13, 5 (2005), 1160â€“1173.
[46] JoÃ£o L. Sobrinho and Timothy G. Griffin. 2010. Routing in Equilibrium. In 19th
International Symposium on Mathematical Theory of Networks and System . 941â€“
947.
[47] Ioanna Tsalouchidou, Ricardo Baeza-Yates, Francesco Bonchi, Kewen Liao, and
Timos Sellis. 2020. Temporal betweenness centrality in dynamic graphs. Int. J.
Data Sci. Anal. 9, 3 (2020), 257â€“272.
[48] Sebastiano Vigna. 2015. A Weighted Correlation Index for Rankings with Ties. In
Proceedings of the 24th International Conference on World Wide Web, WWW 2015,
Florence, Italy, May 18-22, 2015, Aldo Gangemi, Stefano Leonardi, and Alessandro
Panconesi (Eds.). ACM, 1166â€“1176. https://doi.org/10.1145/2736277.2741088
[49] Huanhuan Wu, James Cheng, Yiping Ke, Silu Huang, Yuzhen Huang, and Hejun
Wu. 2016. Efficient Algorithms for Temporal Path Computation. IEEE Trans.
Knowl. Data Eng. 28, 11 (2016), 2927â€“2942.
[50] Tianming Zhang, Yunjun Gao, Jie Zhao, Lu Chen, Lu Jin, Zhengyi Yang, Bin Cao,
and Jing Fan. 2024. Efficient Exact and Approximate Betweenness Centrality
Computation for Temporal Graphs. In Proceedings of the ACM on Web Conference
2024. 2395â€“2406.
A THE GENERAL ALGORITHM
In this section we show how the algorithm for the restless SFo
can be generalised in order to deal with Fa,Fo,ShandSFawalks.
To this aim, we first introduce the notion of cost and target cost
structures and we extend the results of Section 3 to these structures
(all the definitions concerning the Shand the SFobetweenness can
be appropriately adapted to the any other optimality criterion case
and all the results proved for the SFobetweenness can be proved
also for the corresponding betweenness).
 
172Making Temporal Betweenness Computation Faster and Restless KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Cğ›¾(ğ‘’) ğ‘1âŠ•ğ‘2 ğ‘1âª¯ğ‘2
All {0} 0 0 true
Shortest N 1 ğ‘1+ğ‘2 ğ‘1â‰¤ğ‘2
Latest Zâˆ’dep(ğ‘’) ğ‘1 ğ‘1â‰¤ğ‘2
Shortest latest ZÃ—N(âˆ’dep(ğ‘’),1)(ğ‘1[1],ğ‘1[2]+ğ‘2[2])ğ‘1[1]<ğ‘2[1]or(ğ‘1[1]=ğ‘2[1]andğ‘1[2]â‰¤ğ‘2[2])
Table 6: The 4 cost structures used in this paper
Cğ¹ğ‘1âª¯ğ¹ğ‘2
Natural Z ğ‘1â‰¤ğ‘2
Lexicographic ZÃ—Nğ‘1[1]<ğ‘2[1]or(ğ‘1[1]=ğ‘2[1]andğ‘1[2]â‰¤ğ‘2[2])
Table 7: The 2 target cost structures along with the TCfunctions used in this paper
Walk cost and target cost structures. We integrate a temporal
graphğº=(ğ‘‰,ğ¸,ğ›½)with an algebraic cost structure(C,ğ›¾,âŠ•,âª¯),
whereCis the set of possible cost values,ğ›¾is acost function ğ›¾:ğ¸â†’
C,âŠ•is acost combination function âŠ•:CÃ—Câ†’C , andâª¯is acost
total order withâª¯âŠ† CÃ—C . For any two elements ğ‘1andğ‘2ofC, we
say thatğ‘1=ğ‘2ifğ‘1âª¯ğ‘2andğ‘2âª¯ğ‘1both hold. We also define the
relationâ‰ºbetween the elements of Casğ‘1â‰ºğ‘2if and only if ğ‘1âª¯ğ‘2
andğ‘1â‰ ğ‘2. For any walk ğ‘Š=âŸ¨ğ‘’1,...,ğ‘’ğ‘˜âŸ©, the cost function ofğ‘Š
is recursively defined as follows: ğ›¾(ğ‘Š)=ğ›¾(âŸ¨ğ‘’1,...,ğ‘’ğ‘˜âˆ’1âŸ©)âŠ•ğ›¾(ğ‘’ğ‘˜),
withğ›¾(âŸ¨ğ‘’1âŸ©)=ğ›¾(ğ‘’1)(in other words, the costs combine along
the walk according to the cost combination function). The cost
structure is supposed to satisfy the following strict right-isotonicity
property [8,45,46] (isotonicity for short): for any ğ‘1,ğ‘2,ğ‘âˆˆCsuch
thatğ‘1â‰ºğ‘2, we haveğ‘1âŠ•ğ‘â‰ºğ‘2âŠ•ğ‘. This property implies the
following walk extension property: for any two walks ğ‘Šandğ‘‹
such thatğ›¾(ğ‘Š)â‰ºğ›¾(ğ‘‹)and for any temporal edge ğ‘’which can
extend both ğ‘Šandğ‘‹, we haveğ›¾(ğ‘Š.ğ‘’)â‰ºğ›¾(ğ‘‹.ğ‘’)(that is, if several
walks are extended by a given temporal edge ğ‘’, then the best cost
is obtained only by extending a walk with minimum cost). The
isotonicity property also implies a prefix property, which is similar
to the prefix-optimality property introduced in [38].
Fact 3. Letğº=(ğ‘‰,ğ¸,ğ›½)be a temporal graph and (C,ğ›¾,âŠ•,âª¯)be
a cost structure satisfying the isotonicity property. For any node ğ‘ âˆˆğ‘‰,
if a walkğ‘Šwith last temporal edge ğ‘“âˆˆğ¸has minimum cost among
theğ‘ ğ‘“-walks, and ğ‘’âˆˆğ¸is a temporal edge of ğ‘Š, then the prefix of
ğ‘Šup to the temporal edge ğ‘’has minimum cost among the ğ‘ ğ‘’-walks.
In this paper, we will consider the four cost structures shown in
Table 6. It is easy to verify that all of them satisfy the isotonicity
property. For example, let us prove that the shortest latest cost
structure satisfies the isotonicity property. Suppose that ğ‘1,ğ‘2âˆˆ
ZÃ—Nsatisfyğ‘1â‰ºğ‘2: this implies that either ğ‘1[1]>ğ‘2[1]orğ‘1[1]=
ğ‘2[1]âˆ§ğ‘1[2]<ğ‘2[2]. For anyğ‘âˆˆZÃ—N,ğ‘1âŠ•ğ‘=(ğ‘1[1],ğ‘1[2]+ğ‘[2])
andğ‘2âŠ•ğ‘=(ğ‘2[1],ğ‘2[2]+ğ‘[2]). Ifğ‘1[1]>ğ‘2[1], thenğ‘1âŠ•ğ‘â‰ºğ‘2âŠ•ğ‘.
Otherwise (that is, ğ‘1[1]=ğ‘2[1]andğ‘1[2]<ğ‘2[2]),ğ‘1[2]+ğ‘[2]<
ğ‘2[2]+ğ‘[2]and, thus,ğ‘1âŠ•ğ‘â‰ºğ‘2âŠ•ğ‘.
Similar to the algorithms introduced in Section 4, the general
algorithm consists of three phases. Given a temporal graph ğº=
(ğ‘‰,ğ¸,ğ›½)and a cost structure (C,ğ›¾,âŠ•,âª¯)among the ones in Table 6,
in the first phase (that is, the forward phase), the algorithm counts,
for any source node ğ‘ and for any temporal edge ğ‘’, the number ofğ‘ ğ‘’-walks which are optimal with respect to the walk cost function ğ›¾.
In the other two phases (that is, the intermediate and the backward
phase), the algorithm makes use of a target (orfinal )cost structure
(Cğ¹,âª¯ğ¹), whereCğ¹is the set of possible target cost values andâª¯ğ¹
is atarget cost total order withâª¯ğ¹âŠ† Cğ¹Ã—Cğ¹. For any two elements
ğ‘1andğ‘2ofCğ¹, we say that ğ‘1=ğ¹ğ‘2ifğ‘1âª¯ğ¹ğ‘2andğ‘2âª¯ğ¹ğ‘1both
hold. We also define the relation â‰ºğ¹between the elements of Cğ¹
asğ‘1â‰ºğ¹ğ‘2if and only if ğ‘1âª¯ğ¹ğ‘2andğ‘1â‰ ğ¹ğ‘2.
Costs and target costs are related through a function TC:ğ¸Ã—Câ†’
Cğ¹that associates to a temporal edge and a cost, a corresponding
target cost. This function needs to satisfy the following increasing
property: for any ğ‘1,ğ‘2âˆˆC such thatğ‘1â‰ºğ‘2and for any ğ‘’âˆˆğ¸,
we have that TC(ğ‘’,ğ‘1)â‰ºğ¹TC(ğ‘’,ğ‘2). In this paper, we will consider
the two target cost structures shown in Table 7, which together
with a combination of one of the cost structures of Table 6 and an
appropriate TCfunction will allow us to deal all optimality criteria.
For example, Fawalks can be modeled by using the latest cost
structure of Table 6 that associates to a walk the opposite of its
departure time as a cost with later time being considered as lower
cost: for that, it suffices to define the cost of a temporal edge as the
opposite of its departure time and a combination function âŠ•that
returns its first argument. The duration of a walk ğ‘Šwith costğ‘
and ending with a temporal edge ğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)is then obtained
by using the natural target cost (see Table 7) and the target cost
Optimality
criterion Cost T
arget cost TC(ğ‘’
,ğ‘)
Shortest Shortest Natural ğ‘
For
emost All Natural arr(ğ‘’)
Latest Latest Natural ğ‘
Fastest Latest Natural arr(ğ‘’)
+ğ‘
Shortest foremost Shortest Le
xicographic (arr(ğ‘’),
ğ‘)
Shortest latest Shortest
latest Le
xicographic ğ‘
Shortest
fastest Shortest
latest Le
xicographic(arr(ğ‘’)
+ğ‘[1],ğ‘[2])
Table 8: Optimality criteria in terms of cost and target cost
structures. In the last column of the table, the semantic of
ğ‘is the following: number of hops for Shand for SFo, the
opposite of the departure time for latest and for Fathe array
whose first entry is the opposite of the departure time and
whose second entry is the number of hops for shortest latest
andSFa.
 
173KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Filippo Brunelli, Pierluigi Crescenzi, and Laurent Viennot
Algorithm 2: computeğ‘ğ‘ ,ğ‘’of all temporal edges
input : temporal graph ğº=(ğ‘‰,ğ¸,ğ›½)(represented by ğ¸depandğ¸arr),ğ‘ âˆˆğ‘‰, cost structure Î“=(C,ğ›¾,âŠ•,âª¯), target cost structure Î˜=(Cğ¹,âª¯ğ¹),
and target cost function TC
output :ğ‘ -temporal betweenness ğ‘ğ‘ ,ğ‘’of eachğ‘’âˆˆğ¸w.r.t.Î“,Î˜, and TC
1Compute the lists ğ¸dep
nodeandğ¸arr
dep;
2foreachğ‘£âˆˆğ‘‰doğ‘™[ğ‘£]:=1;ğ‘Ÿ[ğ‘£]:=0;I[ğ‘£]:=âˆ…;
3foreachğ‘’âˆˆğ¸doğ¿[ğ‘’]:=|ğ¸ğ‘ğ‘Ÿğ‘Ÿ|+1;ğ‘…[ğ‘’]:=0;ğ¶[ğ‘’]:=âˆÎ“;Î£[ğ‘’]:=0;
4foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸arrdo
5ifğ¸arr
dep[ğ‘’]â‰¥ğ‘™[ğ‘¢]then Finalize(ğ‘¢,ğ¸arr
dep[ğ‘’]);
6ifğ‘¢=ğ‘ then ifğ›¾(ğ‘’)â‰ºğ¶[ğ‘’]thenğ¶[ğ‘’]:=ğ›¾(ğ‘’);Î£[ğ‘’]:=1;else ifğ›¾(ğ‘’)=ğ¶[ğ‘’]then Î£[ğ‘’]:=Î£[ğ‘’]+1;
7ifğ¶[ğ‘’]â‰ âˆÎ“then
8ğ‘:=ğ‘™[ğ‘£];whileğ‘â‰¤|ğ¸dep
node[ğ‘£]|âˆ§dep(ğ¸arr[ğ¸dep
node[ğ‘£][ğ‘]])<ğœ+ğœ†doğ‘:=ğ‘+1;
9ğ‘:=ğ‘Ÿ[ğ‘£];whileğ‘<|ğ¸dep
node[ğ‘£]|âˆ§dep(ğ¸arr[ğ¸dep
node[ğ‘£][ğ‘+1]])â‰¤ğœ+ğœ†+ğ›½doğ‘:=ğ‘+1;
10 Finalize(ğ‘£,ğ‘âˆ’1);ğ‘™ğ‘:=max(ğ‘,ğ‘Ÿ[ğ‘£]+1);
11 while|I[ğ‘£]|>0âˆ§ğ¶[ğ‘’]â‰ºlast(I[ğ‘£]).ğ‘doğ‘„:=poplast(I[ğ‘£]);ğ‘™ğ‘:=ğ‘„.ğ‘™;foreachğ‘“âˆˆğ‘„.ğ‘ƒdoğ‘…[ğ‘“]:=ğ‘âˆ’1;
12 if|I[ğ‘£]|>0âˆ§last(I[ğ‘£]).ğ‘=ğ¶[ğ‘’]thenğ‘„:=last(I[ğ‘£]);ğ‘„.ğ‘Ÿ:=ğ‘;ğ‘„.ğœ‚ :=ğ‘„.ğœ‚+Î£[ğ‘’];ğ‘„.ğ‘ƒ :=ğ‘„.ğ‘ƒâˆª{ğ‘’};ğ¿[ğ‘’]:=ğ‘„.ğ‘™;
13 else ifğ‘™ğ‘â‰¤ğ‘thenğ¿[ğ‘’]:=ğ‘™ğ‘;pushlast(I[ğ‘£],(ğ‘™ğ‘,ğ‘,ğ¶[ğ‘’],{ğ‘’},Î£[ğ‘’]));
14ğ‘…[ğ‘’]:=ğ‘;ğ‘Ÿ[ğ‘£]:=ğ‘;
15foreachğ‘£âˆˆğ‘‰doğ‘âˆ—[ğ‘£]=âˆÎ˜;ğœâˆ—[ğ‘£]=0;ğ›¿[ğ‘£]:=0;
16ğ‘âˆ—[ğ‘ ]:=0Î˜;ğœâˆ—[ğ‘ ]:=1;foreachğ‘’âˆˆğ¸doÎ£âˆ—[ğ‘’]:=0;ğ‘[ğ‘’]:=0;
17foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸arrdo if(ğ¶[ğ‘’]<âˆâˆ§ TC(ğ‘’,ğ¶[ğ‘’])â‰ºğ¹ğ‘âˆ—[ğ‘£])thenğ‘âˆ—[ğ‘£]:=TC(ğ‘’,ğ¶[ğ‘’]);
18foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆğ¸arrdo if TC(ğ‘’,ğ¶[ğ‘’])=ğ¹ğ‘âˆ—[ğ‘£]then Î£âˆ—[ğ‘’]:=Î£[ğ‘’];ğœâˆ—[ğ‘£]:=ğœâˆ—[ğ‘£]+Î£[ğ‘’];
19foreachğ‘’=(ğ‘¢,ğ‘£,ğœ,ğœ†)âˆˆreverse(ğ¸arr)do
20 if0<ğ¿[ğ‘’]â‰¤ğ‘…[ğ‘’]then
21 foreachğ‘“âˆˆğ¸dep
node[ğ‘£][max(ğ‘™[ğ‘£],ğ‘…[ğ‘’]+1):ğ‘Ÿ[ğ‘£]]do ifğ‘£â‰ ğ‘ âˆ¨ğ¶[ğ‘“]=ğ¶[ğ‘’]âŠ•ğ›¾(ğ‘“)thenğ›¿[ğ‘£]:=ğ›¿[ğ‘£]âˆ’ğ‘[ğ‘“]/Î£[ğ‘“];
22ğ‘Ÿ[ğ‘£]:=ğ‘…[ğ‘’];foreachğ‘“âˆˆğ¸dep
node[ğ‘£][ğ¿[ğ‘’]: min(ğ‘…[ğ‘’],ğ‘™[ğ‘£]âˆ’1)]do ifğ‘£â‰ ğ‘ âˆ¨ğ¶[ğ‘“]=ğ¶[ğ‘’]âŠ•ğ›¾(ğ‘“)thenğ›¿[ğ‘£]:=ğ›¿[ğ‘£]+ğ‘[ğ‘“]/Î£[ğ‘“];
23ğ‘™[ğ‘£]:=ğ¿[ğ‘’];ğ‘[ğ‘’]:=Î£[ğ‘’]ğ›¿[ğ‘£];
24 ifÎ£âˆ—[ğ‘’]>0thenğ‘[ğ‘’]:=ğ‘[ğ‘’]+Î£âˆ—[ğ‘’]/ğœâˆ—[ğ‘£];
25returnğ‘
26Finalize(ğ‘£,ğ‘—):
27 while|I[ğ‘£]|>0âˆ§first(I[ğ‘£]).ğ‘™â‰¤ğ‘—do
28ğ‘„:=first(I[ğ‘£]);ğ‘ğ‘™:=ğ‘„.ğ‘™;ğ‘ğœ‚:=ğ‘„.ğœ‚;
29 while|ğ‘„.ğ‘ƒ|>0âˆ§ğ‘…[first(ğ‘„.ğ‘ƒ)]â‰¤ğ‘—do
30ğ‘’:=popfirst(ğ‘„.ğ‘ƒ);foreachğ‘“âˆˆğ¸dep
node[ğ‘£][ğ‘ğ‘™:ğ‘…[ğ‘’]]doğ¶[ğ‘“]:=ğ‘„.ğ‘âŠ•ğ›¾(ğ‘“);Î£[ğ‘“]:=ğ‘ğœ‚;
31ğ‘ğœ‚:=ğ‘„.ğœ‚âˆ’Î£[ğ‘’];ğ‘ğ‘™:=ğ‘…[ğ‘’]+1;foreachğ‘“âˆˆğ¸dep
node[ğ‘£][ğ‘ğ‘™: min(ğ‘—,ğ‘„.ğ‘Ÿ)]doğ¶[ğ‘“]:=ğ‘„.ğ‘âŠ•ğ›¾(ğ‘“);Î£[ğ‘“]:=ğ‘ğœ‚;
32 ifğ‘—â‰¥ğ‘„.ğ‘Ÿthen popfirst(I[ğ‘£]);elseğ‘„.ğ‘™:=ğ‘—+1;ğ‘„.ğœ‚ :=ğ‘ğœ‚;break;
33ğ‘™[ğ‘£]:=ğ‘—+1;
function TC(ğ‘’,ğ‘)=arr(ğ‘’)+ğ‘, since arr(ğ‘’)=ğœ+ğœ†equals arr(ğ‘Š)
andğ‘=âˆ’dep(ğ‘Š). As shown in Table 8, any of the walk optimality
criteria defined in Section 3 can be modelled by an appropriate
combination of the introduced cost structures, target cost structures,
and target functions.
Given a cost structure Î“=(C,ğ›¾,âŠ•,âª¯)and a target cost structure
Î˜=(Cğ¹,âª¯ğ¹)along with a target cost function TC, we say that a
temporalğ‘ ğ‘¡-walkğ‘ŠisÎ˜-optimal if, for anyğ‘ ğ‘¡-walkğ‘‹, we have
TC(ğ‘’,ğ›¾(ğ‘Š))âª¯ğ¹TC(ğ‘“,ğ›¾(ğ‘‹)), whereğ‘’andğ‘“are the last temporal
edge ofğ‘Šandğ‘‹, respectively. We also say that a temporal ğ‘ ğ‘’-walk
ğ‘ŠisÎ“-optimal if, for any ğ‘ ğ‘’-walkğ‘‹, we haveğ›¾(ğ‘Š)âª¯ğ›¾(ğ‘‹). Note
that a Î“-optimalğ‘ ğ‘’-walkğ‘‹not necessarily is a Î˜-optimalğ‘ ğ‘¡-walk
whereğ‘¡is the head of ğ‘’. The opposite, instead, is true. Indeed, given
a temporal graph ğº=(ğ‘‰,ğ¸,ğ›½), a cost structure(C,ğ›¾,âŠ•,âª¯), a targetcost structure(Cğ¹,âª¯ğ¹), and a TCfunction, ifğ‘Šis aÎ˜-optimalğ‘ ğ‘¡-
walk (for some ğ‘ ,ğ‘¡âˆˆğ‘‰) andğ‘’is the last temporal edge of ğ‘Š, then
ğ‘Šis aÎ“-optimalğ‘ ğ‘’-walk.
The general algorithm. The pseudo-code of the general algorithm
for any of optimality criteria which fits in our framework is shown
in Algorithm 2. The pseudo-code uses the symbol âˆÎ“andâˆÎ˜
to denote the natural infinite value of a cost structure Î“and a
target cost structure Î˜. It also uses the symbol 0Î˜to denote the
natural minimum value of a target cost structure Î˜. Moreover, it
has to be observed that the actual code includes, in the backward
phase, a control structure which allows us to deal with numerical
approximation problems. This structure is not needed if big integer
and big rational data structures are used, which, on the other hand,
may slower the execution of the algorithm by a factor between two
and four.
 
174