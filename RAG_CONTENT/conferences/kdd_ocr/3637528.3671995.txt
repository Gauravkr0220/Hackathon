Quantifying and Estimating the Predictability Upper Bound of
Univariate Numeric Time Series
Jamal Mohammed
Universiy of Zurich
Zurich, Switzerland
mjamal@ifi.uzh.chMichael H.BÃ¶hlen
Universiy of Zurich
Zurich, Switzerland
boehlen@ifi.uzh.chSven Helmer
Universiy of Zurich
Zurich, Switzerland
helmer@ifi.uzh.ch
ABSTRACT
The intrinsic predictability of a given time series indicates how well
an (ideal) algorithm could potentially predict it when trained on the
time series data. Being able to compute the intrinsic predictability
helps the developers of prediction algorithms immensely in decid-
ing whether there is further optimization potential, as it tells them
how close they are to what is (theoretically) achievable. We call
the intrinsic predictability the predictability upper bound Î ğ‘šğ‘ğ‘¥
and propose a novel method for quantifying and estimating it for
univariate numeric time series. So far, this has only been done for
symbolic time series, even though most real-world time series are
numeric by nature. We base our technique on the close relationship
between entropy and predictability, utilizing the entropy rate of a
time series to compute Î ğ‘šğ‘ğ‘¥. Since existing entropy rate estima-
tors, such as those based on the Lempel-Ziv compression algorithm,
only work for symbolic data, we develop new estimators using
tolerance thresholds for matching numeric values. We demonstrate
thatÎ ğ‘šğ‘ğ‘¥is an effective upper bound that characterizes the in-
trinsic predictability of a time series. We give formal proofs and
we validate our arguments experimentally by comparing Î ğ‘šğ‘ğ‘¥
with the prediction accuracy of different state-of-the-art models on
various real-world datasets from different domains.
CCS CONCEPTS
â€¢Mathematics of computing â†’Time series analysis ;Infor-
mation theory.
KEYWORDS
Prediction, Information Theory, Time series
ACM Reference Format:
Jamal Mohammed, Michael H.BÃ¶hlen, and Sven Helmer. 2024. Quantifying
and Estimating the Predictability Upper Bound of Univariate Numeric Time
Series. In Proceedings of the 30th ACM SIGKDD Conference on Knowledge
Discovery and Data Mining (KDD â€™24), August 25â€“29, 2024, Barcelona, Spain.
ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3637528.3671995
1 INTRODUCTION
Predicting (or forecasting) future events from the past plays an
important role in many application fields, e.g. sales and weather
forecasts, portfolio management, and prediction of (human) mobil-
ity. Our goal is to quantify the limits of predictability of a given time
This work is licensed under a Creative Commons Attribution
International 4.0 License.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s).
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671995series, i.e., providing an upper bound for the ratio of potentially
achievable correct predictions to all predictions for a particular
dataset. When computing this upper bound, we only rely on the
intrinsic properties of the data without utilizing any additional
information. That is why this upper bound is also called intrinsic
predictability [19], in contrast to realized predictability, which only
tells us about the performance of specific prediction algorithms.
Intrinsic predictability is a powerful tool when it comes to judging
whether we have poor realized predictability due to a suboptimal
prediction algorithm/model or because the time series is generally
hard to predict [ 24]. For instance, a small gap between the upper
bound and the currently used prediction algorithm indicates that
there is little room for improvement and that it is unlikely that we
can find a better algorithm. Additionally, intrinsic predictability can
be utilized to benchmark prediction algorithms against an absolute
measure rather than relatively against each other.
We base our technique on the entropy rate, which has been
shown to be suitable for measuring how difficult it is to predict
the next value in a time series [ 7]. The notion that entropy and
predictability are related (i.e., the higher the entropy, the lower
the predictability and vice versa) has been around for a long time.
While many different variants of entropy have been proposed for
measuring the complexity of data, e.g. approximate entropy [ 25],
sample entropy [ 26], or permutation entropy [ 3], none of these
methods have been used to quantify the predictability. Most of
the studies investigating these entropies show various rates of
correlation between entropy and predictability or metrics such as
the mean squared error [ 5,6]. To the best of our knowledge, Song
et al. [ 31] were the first to propose a method to compute a concrete
number: the maximum predictability Î max, which serves as an
upper bound for the predictability. However, their approach only
works for symbolic time series; they map location information to a
fixed alphabet. Many real-world time series are numeric, though.
We show that discretizing numeric values in a straightforward way
(as, for instance, done by Smith et al. [ 30]) does not work well, up to
the point of Î maxceasing to be an upper bound for predictability.
We propose a new way to compute Î max, avoiding discretization
by introducing a tolerance ğœ–. Two values ğ‘¥andğ‘¦are considered
equal if their distance is within the tolerance ğœ–:|ğ‘¥âˆ’ğ‘¦|â‰¤ğœ–. This
preserves proximity relations between numeric values much better
than the original discretization approach and leads to more accurate
values for Î max. Note that a tolerance also affects the implementa-
tion of the algorithm to compute Î max. We show how to calculate
Î maxusing a novel numeric Lempel-Ziv algorithm. In summary,
our main contributions are
 
2236
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Jamal Mohammed, Michael H.BÃ¶hlen, and Sven Helmer
â€¢We propose a new upper bound for the predictability of
numeric time series given its entropy rate and a tolerance ğœ–,
and prove the correctness of our approach.
â€¢We implement a novel algorithm for estimating the entropy
rate of a numeric time series.
â€¢In an experimental evaluation we demonstrate the effective-
ness of our technique.
2 RELATED WORK
The related work section is divided into two parts. First, we have
a look at entropy-based approaches for computing or estimating
the predictability of time series. In the second part, we review
techniques for implementing approaches to estimate entropy rates.
Entropy is a well-known concept applied to estimating pre-
dictability [ 7]. Song et al. propose an approach based on the entropy
rate of a (human mobility) time series to compute an upper bound
of predictability [ 31]. Although criticized by Smith et al. [ 30] and
Xu et al. [ 34] for using a coarse spatial granularity resulting in a
loose upper bound, in principle the approach by Song et al. works.
However, it can only be applied to symbolic time series data. This
is one of the reasons why a relatively coarse granularity was used:
mapping spatial areas to symbols loses the spatial relationships be-
tween the different areas. Generalizing an entropy-based approach
from a discrete domain to a continuous domain is far from trivial.
As we will show later, the naive discretization applied by Smith et
al. causes problems in terms of the accuracy. The straightforward
approach of replacing the sum in the formula for entropy with
an integral (as originally suggested by Shannon [ 27]) leads to the
so-called differential entropy [4,7], which has several issues, such as
easily becoming infinite for continuous probability distributions [ 2]
and not being invariant under coordinate transformations [4].
Since the seminal work of Shannon [ 27,28], many different
notions of entropy, such as approximate entropy[ 25], fuzzy en-
tropy [ 5], sample entropy[ 26], and permutation entropy[ 3], have
been proposed. An advantage of these entropy types is that they can
be applied to continuous domains. For instance, Chen et al. [ 5] have
estimated the predictability of numerical time series with fuzzy
entropy, approximate entropy, and sample entropy, while Garland
et al [ 10] have done so with permutation entropy. Garland et al.
demonstrate empirically that their weighted permutation entropy
(WPE) is correlated to the mean absolute scaled error (MASE). The
method is limited to correlation, though, as WPE and MASE are two
completely different measures and there is no direct connection
between the two. This lack of being directly comparable with en-
tropy is a general issue with measures for forecast accuracy, such as
MASE (even though MASE is widely considered to be the preferred
measure [ 15]). We are not aware of any method to compute an
upper bound of the best achievable forecast accuracy for a given
numerical time series. Summarizing the entropy-based state-of-the-
art methods, we can say that on the one hand, there are techniques
that compute an upper bound for the intrinsic predictability of a
time series but only work for discrete time series [ 31]. On the other
hand, there are approaches that can be applied to numeric time
series, but which only establish a correlation between forecasting
accuracy and entropy and do not provide an upper bound for theintrinsic predictability. With our method, we can compute an upper
bound for the intrinsic predictability for numeric time series.
We now turn to the second part of the related work section,
implementing the entropy rate computation of a time series. First
of all, we point out that calculating the exact value of the entropy
rate is usually not possible, as the exact probability distribution
of the underlying generating process is not known (we assume
that we are only given the observed values). Even if we had ac-
cess to the concrete probabilities, it would still be infeasible to
compute the exact entropy rate, since this has high runtime costs.
Consequently, the entropy rate of a time series is usually estimated
rather than computed exactly. For an overview and a discussion,
see [ 9], in which Feutrill distinguishes between parametric estima-
tors, which assume that the data generation follows a certain model,
such as a Gaussian process [ 7] or a Markov process [ 7], and non-
parametric ones, which do not make this assumption. We disregard
parametric estimators, as we do not make any assumptions about
the underlying model. For non-parametric estimators, such as the
Lempel-Ziv-based algorithm [ 35], the close relationship between
entropy and data compression algorithms is exploited. Intuitively,
the entropy rate measures how many bits of novel information are
introduced by each new sample emitted from a source. When using
a compression algorithm on these samples, the compression rate
will be higher if less novel information is encountered and vice
versa. The Lempel-Ziv (LZ) algorithm is of particular interest, as it
is auniversal source code for ergodic, stationary sources. A code for
a sourceğ‘‹(e.g. a random variable) is a mapping from the domain
ofğ‘‹to a set of symbols. For a universal source code, the limit of the
expected code length (for the number of samples going to infinity)
reaches the entropy rate and the mapping is independent of the
particular source [ 1]. The original LZ algorithm is only suitable for
symbolic data, though. We implement an entropy estimator based
on the Lempel-Ziv algorithm for numeric time series.
3 PRELIMINARIES
Before we begin describing our approach, we introduce some basic
definitions of time series and entropy-related concepts.
Definition 1. Atime series T is a time-ordered sequence ğ‘‡=
(ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘›), whereğ‘¥ğ‘¡is the value at time point ğ‘¡and n is the
length of time series ğ‘‡.
Definition 2. Atime series data generating process is de-
fined via a stochastic process ğ‘‹, which consists of a sequence of ran-
dom variables ğ‘‹1,ğ‘‹2,...,ğ‘‹ğ‘›. The index refers to the point in time,
i.e.,ğ‘‹ğ‘¡is the random variable for time point ğ‘¡.
For the moment, we make the following assumption on the time
seriesğ‘‡and the stochastic process ğ‘‹:
â€¢Discrete, equi-spaced intervals of time: for ğ‘¡âˆˆ{1,2,...,ğ‘›}
the delta between any consecutive observations ğ‘¥ğ‘¡andğ‘¥ğ‘¡+1
is constant; so, ğ‘‹is a discrete time stochastic process.
â€¢Boundedness of values in ğ‘‡:ğ‘¥ğ‘¡âˆˆ[ğ‘šğ‘–ğ‘›(ğ‘‡),ğ‘šğ‘ğ‘¥(ğ‘‡)].
â€¢Stationarity of ğ‘‹: the statistical properties of ğ‘‡do not change
over time. More formally, the probabilistic behavior of a
sequence(ğ‘¥ğ‘–,ğ‘¥ğ‘–+1,...,ğ‘¥ğ‘–+ğ‘˜)is the same as that of a shifted
sequence(ğ‘¥ğ‘–+â„,ğ‘¥ğ‘–+â„+1,...,ğ‘¥ğ‘–+â„+ğ‘˜)[29].
 
2237Quantifying and Estimating the Predictability Upper Bound of Univariate Numeric Time Series KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
â€¢Ergodicity of ğ‘‹: the average over ensembles and time are
the same (ensembles are essentially a collection of possible
states). For our case, this means that the average over po-
tential subsequences (for a time period) is the same as the
average over a single very long time period [23].
As we cover numeric time series, the random variables ğ‘‹ğ‘¡can
be interpreted as continuous random variables. The definitions
of entropy below assume discrete random variables, though. We
resolve this seeming contradiction in Sections 5.1 and 5.2.
Definition 3. Entropy measures the information content, quan-
tifying the uncertainty of a random variable. For random variable ğ‘Œ
over domain ğœ™, the entropy is defined as:
ğ»(ğ‘Œ)=âˆ’Ã•
ğ‘¦âˆˆğœ™ğ‘(ğ‘¦)log2(ğ‘(ğ‘¦)) (1)
ğ‘(ğ‘¦)is the probability that ğ‘Œtakes valueğ‘¦âˆˆğœ™. Entropy is usually
measured in bits, thus we use the logarithm to the base 2.
Entropy is always greater or equal to 0 (assuming that 0log2(0)=
0) and is maximized for a uniformly distributed random variable.
Additionally, entropy always refers to a single random variable.
As a time series is defined by a stochastic process made up of a
sequence of random variables ğ‘‹1,ğ‘‹2,...,ğ‘‹ğ‘›, we need to modify
how to measure the uncertainty of the process. Instead of using
entropy, we use the entropy rate, which intuitively measures the
average uncertainty per symbol in the generated time series.
Definition 4. Theentropy rateHof a stochastic process ğ‘‹
consisting of the random variables ğ‘‹1,ğ‘‹2,...,ğ‘‹ğ‘›is computed with
the help of conditional entropy and the limit as ğ‘›tends to infinity:
H(ğ‘‹)=limğ‘›â†’âˆ1
ğ‘›ğ‘›Ã•
ğ‘¡=1ğ»(ğ‘‹ğ‘¡|ğ‘‹ğ‘¡âˆ’1...ğ‘‹1) (2)
We should mention that the limit may not exist if the generating
processğ‘‹is non-stationary or non-ergodic. Moreover, for t=1 the
above equation is reduced to ğ»(ğ‘‹1)[7].
Definition 5. Theconditional entropy measures the amount
of information provided by the outcome of a random variable ğ‘Œgiven
the value of another random variable ğ‘.
ğ»(ğ‘Œ|ğ‘)=Ã•
ğ‘§âˆˆğœğ‘(ğ‘§)ğ»(ğ‘Œ|ğ‘=ğ‘§)
=âˆ’Ã•
ğ‘§âˆˆğœÃ•
ğ‘¦âˆˆğœ™ğ‘(ğ‘¦,ğ‘§)log2ğ‘(ğ‘¦|ğ‘§)(3)
In our proofs, we use the following theorems on conditional
entropy. The proofs of these theorems can be found in [ 7], along
with more details about information theory and entropy.
Theorem 1. Chain rule for joint and conditional entropies:
ğ»(ğ‘‹,ğ‘Œ)=ğ»(ğ‘‹)+ğ»(ğ‘Œ|ğ‘‹) (4)
Corollary 2. A corollary of this rule is
ğ»(ğ‘‹,ğ‘Œ|ğ‘)=ğ»(ğ‘‹|ğ‘)+ğ»(ğ‘Œ|ğ‘‹,ğ‘) (5)
Theorem 3. Conditionality reduces entropy:
ğ»(ğ‘‹|ğ‘Œ)â‰¤ğ»(ğ‘‹) (6)4 CURRENT CHALLENGES
While Song et al. managed to connect predictability directly to en-
tropy, they sidestepped the whole issue of symbolic versus numeric
data by assuming that the data is already discretized [ 31]. Smith et
al. continued where Song et al. had left off and explicitly discretized
the geolocation data by placing a grid on top of maps [ 30]. The
numerical value domain was essentially divided into bins and all
values contained in a bin were assigned the same symbol.
Figure 1: Binning time series values
Although binning makes it easy to determine whether a predic-
tion is considered acceptable or not (two values sharing the same
symbol match), there are still problems regarding proximity. For
example, given a value of 6 and two predictions 5 and 8, intuitively
5 is a better prediction, since it is closer. However, binning rarely
captures the proximity correctly. In Figure 1, we have a bin width of
2.4, but for this bin configuration, 8 would be considered a matching
prediction, while 5 would not be. Assuming that two values are
considered close enough when they are within distance 1.2 of each
other, we have a total of 78 potentially matching pairs in Figure 1,
25 of which are within range of each other. However, using the bin-
ning depicted in the figure with dashed lines, we have 24 matching
pairs, 7 of which are false positives, while missing 8 false negatives.
Figure 2: Proximity Issues due to binning
This is not only counterintuitive, but also leads to scenarios in
which Î ğ‘šğ‘ğ‘¥ceases to be an upper bound. We generated a synthetic
series of integers using a first order Markov model with a total of 50
unique values and trained a model on this data. Then we computed
Î ğ‘šğ‘ğ‘¥for the time series, discretizing the values using different bin
widths. Figure 2 shows the results. Not only does the model (labeled
Pimarkov) have predictability better than the upper bound (labeled
Pimax), the upper bound does not grow monotonically with the
bin width (we would expect higher predictability for wider bins,
due to a decrease in entropy), but it fluctuates depending on where
the bounds of the bins are located. This observation highlights the
failure of numeric value discretization as a method for computing
the predictability upper bound of numeric sequences.
 
2238KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Jamal Mohammed, Michael H.BÃ¶hlen, and Sven Helmer
5 OUR APPROACH
Our goal is to develop a method considering the proximity of values,
allowing us to compute the intrinsic predictability of a time series
directly from its entropy rate. We utilize a similarity measure, i.e.,
we compare the time series consisting of the predicted values to
the actually measured time series by determining their similarity.
5.1 Defining Predictability
First, we need to determine whether a predicted value matches
the actually measured one. (We assume a forecast horizon of one,
i.e., given the measured values so far, we predict the next value.)
After predicting a value, we get access to the next true value, which
can then be used for the following prediction. We first define pre-
dictability formally and come back to its implementation later.
Definition 6. Given the stochastic process ğ‘‹=(ğ‘‹1,ğ‘‹2,...,ğ‘‹ğ‘›)
generating the time series ğ‘‡, let Ë†ğ‘‹=(Ë†ğ‘‹1,Ë†ğ‘‹2,..., Ë†ğ‘‹ğ‘›)be the process
generating the predictions. Given a predefined threshold ğœ–, we say that
there is a (prediction) error , defined by the discrete random variable
ğ¸ğ‘¡, at timestamp ğ‘¡, if
ğ¸ğ‘¡=(
1|ğ‘¥ğ‘¡âˆ’Ë†ğ‘¥ğ‘¡|>ğœ–
0ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’(7)
In the following, when we state that ğ‘‹ğ‘¡â‰ˆğœ–Ë†ğ‘‹ğ‘¡, we mean that|ğ‘¥ğ‘¡âˆ’
Ë†ğ‘¥ğ‘¡|â‰¤ğœ–(thus,ğ‘‹ğ‘¡Ì¸â‰ˆğœ–Ë†ğ‘‹ğ‘¡means|ğ‘¥ğ‘¡âˆ’Ë†ğ‘¥ğ‘¡|>ğœ–). Applyingâ‰ˆğœ–to a se-
quence of values means that ğ‘‹ğ‘–,ğ‘‹ğ‘–+1,...,ğ‘‹ğ‘–+ğ‘™â‰ˆğœ–Ë†ğ‘‹ğ‘–,Ë†ğ‘‹ğ‘–+1,..., Ë†ğ‘‹ğ‘–+ğ‘™
is true, iffÃ“ğ‘™
ğ‘—=0(ğ‘‹ğ‘–+ğ‘—â‰ˆğœ–Ë†ğ‘‹ğ‘–+ğ‘—)is true.
Compared to binning, this is a subtle but crucial difference. Us-
ing a tolerance threshold for the distance between values avoids
misclassifications: all pairs within distance ğœ–will be matched, while
those that are further apart will not. We use the definition of a pre-
diction error to define the predictability of a given model (described
by its stochastic process Ë†ğ‘‹) for a particular time series.
Definition 7. We distinguish different levels of predictability.
â€¢The predictability Î Ë†ğ‘‹
ğ‘¡ofË†ğ‘‹for a single step ğ‘¡is equal to
Î Ë†ğ‘‹
ğ‘¡=ğ‘(ğ¸ğ‘¡=0)=1âˆ’ğ‘(ğ¸ğ‘¡=1) (8)
â€¢Calculating the average predictability for the process up to
timestampğ‘›boils down to
Î Ë†ğ‘‹(ğ‘›)=1
ğ‘›ğ‘›Ã•
ğ‘¡=1Î Ë†ğ‘‹
ğ‘¡ (9)
â€¢The overall predictability of Ë†ğ‘‹is the limit of Equation (10)
withğ‘›tending to infinity:
Î Ë†ğ‘‹=limğ‘›â†’âˆ1
ğ‘›ğ‘›Ã•
ğ‘¡=1Î Ë†ğ‘‹
ğ‘¡ (10)
An open question remains when it comes to applying Equa-
tion(7)to determine whether two values match or not: what value
should we set ğœ–to? When using it in the context of a similarity
measure, the time series are normalized to obtain consistent mea-
surements [ 11]. Morse and Patel recommend using one quarter
of the standard deviation of the normalized time series for ğœ–[22].
While we could do this as well, we think a user should set thevalue ofğœ–. This makes a lot of sense for numerical time series, as
there may be requirements from the application side concerning
an acceptable margin of error of predictions, i.e., which distance of
a prediction to the actual value can still be tolerated. Essentially,
our approach determines the intrinsic predictability of a time series
for a given margin of error and allows a user to investigate the
tradeoffs between predictability and different margins of error.
5.2 Upper Bound for Predictability
First, we look at the uncertainty introduced by predicting time
series values. More precisely, given the prediction Ë†ğ‘‹ğ‘¡for timestamp
ğ‘¡, how much information do we need to determine the actual value
ğ‘‹ğ‘¡? In fact, we also have to figure out if Ë†ğ‘‹ğ‘¡is a correct value or
if we have made a prediction error. More formally, we have to
determine the conditional entropy ğ»(ğ¸ğ‘¡,ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡). Applying the chain
rule (Equation (5)), we get
ğ»(ğ¸ğ‘¡,ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡)=ğ»(ğ¸ğ‘¡|Ë†ğ‘‹ğ‘¡)+ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡) (11)
Intuitively, ğ»(ğ¸ğ‘¡|Ë†ğ‘‹ğ‘¡)represents the information needed to com-
municate that an error was made, while ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡)stands for
the information needed to determine ğ‘‹ğ‘¡given the prediction Ë†ğ‘‹ğ‘¡
and the knowledge that an error occurred at time ğ‘¡. In its current
form, Equation (11)is difficult, if not impossible, to compute. We
would need access to a (large) number of joint and conditional
probabilities and, more importantly, the random variables ğ‘‹ğ‘¡and
Ë†ğ‘‹ğ‘¡are, strictly speaking, continuous. Nevertheless, we can provide
an upper bound, essentially treating ğ‘‹ğ‘¡and Ë†ğ‘‹ğ‘¡as discrete random
variables covering a range of values in the continuous domain.
First, we look at ğ»(ğ¸ğ‘¡|Ë†ğ‘‹ğ‘¡). Since conditionality reduces entropy
(Equation (6)), we know that
ğ»(ğ¸ğ‘¡|Ë†ğ‘‹ğ‘¡) â‰¤ğ»(ğ¸ğ‘¡) (12)
=âˆ’ğ‘(ğ¸ğ‘¡=0)log2ğ‘(ğ¸ğ‘¡=0)âˆ’ğ‘(ğ¸ğ‘¡=1)log2ğ‘(ğ¸ğ‘¡=1)
ğ¸ğ‘¡is a discrete random variable, so we are able to apply Equation (1).
We distinguish two cases for the right-most part of Equation (11):
ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡)=ğ‘(ğ¸ğ‘¡=0)ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡=0)+
ğ‘(ğ¸ğ‘¡=1)ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡=1)
=ğ‘(ğ¸ğ‘¡=1)ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡=1) (13)
The first part for ğ‘(ğ¸ğ‘¡=0)drops out, because if we make a
correct prediction, then ğ‘‹ğ‘¡â‰ˆğœ–Ë†ğ‘‹ğ‘¡and we do not need any ad-
ditional information to determine the correct value, which means
ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡=0)is equal toğ»(ğ‘‹ğ‘¡|ğ‘‹ğ‘¡)=ğ»(Ë†ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡), which is equal
to zero.
That leaves us with the second part ğ‘(ğ¸ğ‘¡=1)ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡=1).
We know that we made an error, so ğ‘‹ğ‘¡Ì¸â‰ˆğœ–Ë†ğ‘‹ğ‘¡, which, according to
Definition 6, means that the difference between the predicted value
Ë†ğ‘¥ğ‘¡and the correct value ğ‘¥ğ‘¡is greater than ğœ–. We divide the range
of all possible values into sub-intervals of width ğœ–starting from Ë†ğ‘¥ğ‘¡.
Figure 3 illustrates this: the correct value ğ‘¥ğ‘¡will not be found in
the gray sub-intervals (otherwise, ğ‘¥ğ‘¡â‰ˆğœ–Ë†ğ‘¥ğ‘¡would be true), but in
one of the other intervals.
We now have to determine the number of sub-intervals. Assume
that we know the smallest and largest theoretically possible value
of the domain of ğ‘‹ğ‘¡, denoted by ğ‘¥minandğ‘¥max, respectively. If we
handle predictions Ë†ğ‘‹ğ‘¡falling outside of the range as being equal to
 
2239Quantifying and Estimating the Predictability Upper Bound of Univariate Numeric Time Series KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
... ...Ë†ğ‘¥ğ‘¡
| 
  {z   }|   {z   }
ğœ–ğœ–| 
  {z   } |   {z   }
ğœ– ğœ–| 
  {z   } |   {z   }
ğœ– ğœ–
Figur
e 3: Making an incorrect prediction
ğ‘¥minorğ‘¥max, then we also guarantee that Ë†ğ‘‹ğ‘¡has the same domain
asğ‘‹ğ‘¡. An upper bound for the maximum number ğ‘of distinct
intervals of width ğœ–(in the range[ğ‘¥min,ğ‘¥max]) is
ğ‘=ğ‘¥max+ğœ–âˆ’(ğ‘¥minâˆ’ğœ–)
ğœ–(14)
Consequently, knowing that we have ğ‘intervals and that the
twoğœ–-intervals neighboring Ë†ğ‘¥ğ‘¡are blocked, ğ‘‹ğ‘¡has to fall into one of
the other (of at most) ğ‘âˆ’2ranges. The entropy becomes maximal
for a uniform distribution, so we can determine an upper bound:
ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡,ğ¸ğ‘¡=1)â‰¤ğ‘âˆ’2Ã•
ğ‘–=11
ğ‘âˆ’2log21
ğ‘âˆ’2=log2(ğ‘âˆ’2) (15)
Finally, we connect the entropy ğ»(ğ¸ğ‘¡,ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡)to the entropy rate
H(ğ‘‹)of the time series. Since the prediction model uses the past
observations to make a prediction, i.e., Ë†ğ‘‹ğ‘¡=ğ‘“(ğ‘‹1,ğ‘‹2,...,ğ‘‹ğ‘¡âˆ’1),
ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡)=ğ»(ğ‘‹ğ‘¡|ğ‘‹ğ‘¡âˆ’1,...,ğ‘‹ 1). Applying the chain rule differ-
ently toğ»(ğ¸ğ‘¡,ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡), we obtain
ğ»(ğ¸ğ‘¡,ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡)=ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡)+ğ»(ğ¸ğ‘¡|ğ‘‹ğ‘¡,Ë†ğ‘‹ğ‘¡) (16)
However, the entropy ğ»(ğ¸ğ‘¡|ğ‘‹ğ‘¡,Ë†ğ‘‹ğ‘¡)is equal to zero, since know-
ingğ‘‹ğ‘¡and Ë†ğ‘‹ğ‘¡, we can directly deduce ğ¸ğ‘¡without any additional
information, so
ğ»(ğ¸ğ‘¡,ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡)=ğ»(ğ‘‹ğ‘¡|Ë†ğ‘‹ğ‘¡)=ğ»(ğ‘‹ğ‘¡|ğ‘‹ğ‘¡âˆ’1,...,ğ‘‹ 1) (17)
Computing the average entropy ğ»(ğ‘‹|Ë†ğ‘‹)of predicting the whole
time series then boils down to
ğ»(ğ‘‹|Ë†ğ‘‹)=1
ğ‘›ğ‘›Ã•
ğ‘¡=1ğ»(ğ‘‹ğ‘¡|ğ‘‹ğ‘¡âˆ’1,...,ğ‘‹ 1) (18)
This expression is equivalent to the one found in the entropy rate
(cf. Definition 4). Combining all the previous results (Equations (11),
(12), (13), (15), and (18)) yields:
H(ğ‘‹)â‰¤âˆ’Î Ë†ğ‘‹log2Î Ë†ğ‘‹âˆ’(1âˆ’Î Ë†ğ‘‹)
log2(1âˆ’Î Ë†ğ‘‹)âˆ’log2(ğ‘âˆ’2)
(19)
This means, we have now connected the entropy rate of a time
series directly with its predictability. The inequality in Equation (19)
holds for an arbitrary prediction model Ë†ğ‘‹ğ‘¡. We are interested in an
upper bound for the predictability, which means finding the largest
possible value for Ë†ğ‘‹ğ‘¡satisfying (19). We denote this upper bound
byÎ maxand compute its value by determining the entropy rate
H(ğ‘‹)of the time series and then (numerically) solving the equation
H(ğ‘‹)=âˆ’Î maxlog2Î maxâˆ’(1âˆ’Î max)(log2(1âˆ’Î max)+log2(ğ‘âˆ’
2))forÎ max. Any other value for Î Ë†ğ‘‹will result in a higher entropy
and therefore a lower predictability. How to determine the entropy
rate of a time series is the topic of the following section.6 ENTROPY RATE ESTIMATION
Equation (19)makes it clear that being able to accurately estimate
the entropy rate is crucial for our approach. As already indicated,
there are numerous different ways to estimate the entropy rate of a
time series. Many of these methods converge to the true entropy
rate when the length ğ‘›of the time series goes to infinity. In this
case, the differences between those estimators do not play a role, as
their limit is always the true entropy rate. However, when applying
different entropy rate estimators to finite time series, the differences
do matter. Surprisingly, work on entropy rate estimation for finite
time series is few and far between. The most detailed (empirical)
study we found was by Lesne et al. [ 17]. The authors investigate
two block entropy and two Lempel-Ziv variants. However, as it is
not possible to generalize block entropy estimators to numerical
data, we focus on Lempel-Ziv (LZ) estimators.
Approaches based on Lempel-Ziv use the compressibility of a
time series to estimate the entropy rate. This is done by parsing
the time series and partitioning it into a set of distinct words. For
the computation of the entropy rate, we are particularly interested
in the number of words created by the parsing: the higher/lower
the number of partitions, the higher/lower the entropy. Two dif-
ferent parsing approaches have been proposed, which, for sake of
simplicity, we call LZ1 and LZ2.
6.1 Numeric Lempel-Ziv 1 (NLZ1)
LZ1 is based on the 1978 paper by Lempel and Ziv [ 36]. Cover and
Thomas call this a tree-structured Lempel-Ziv algorithm, as it can
be viewed as building a (tree-structured) dictionary [ 7]. Essentially,
the parsing searches for the shortest prefix of the part of the time
series not parsed yet that is not in the dictionary. For symbolic
data, matching values during the parsing is straightforward: we can
compare the values directly. For numeric data, we have to use our
comparison operator â‰ˆğœ–. Algorithm 1 shows pseudocode for the
numeric LZ1 estimator (NLZ1), returning the number of partitions;
ğ‘¤[ğ‘–,ğ‘—]denotes the subsequence ğ‘¥ğ‘–,ğ‘¥ğ‘–+1,...,ğ‘¥ğ‘—of time series ğ‘‡(if
ğ‘–>ğ‘—, thenğ‘¤[ğ‘–,ğ‘—]is the empty word).
Algorithm 1: NLZ1(ğ‘‡=(ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘›))
1ğ‘–â†1,ğ·â†âˆ…;
2whileğ‘–â‰¤ğ‘›do
3 find the smallest ğ‘—â‰¥ğ‘–such that there is a word
ğ‘¤[ğ‘,ğ‘]âˆˆğ·withğ‘¤[ğ‘–,ğ‘—âˆ’1]â‰ˆğœ–ğ‘¤[ğ‘,ğ‘]and no word
ğ‘¤[ğ‘,ğ‘]âˆˆğ·withğ‘¤[ğ‘–,ğ‘—]â‰ˆğœ–ğ‘¤[ğ‘,ğ‘];
4ğ·â†ğ·âˆª{ğ‘¤[ğ‘–,ğ‘—]};
5ğ‘–â†ğ‘—+1;
6end
7return|ğ·|
We now have to convert the number of words, ğ‘(ğ‘›)=|ğ·|, returned
by the algorithm above for time series ğ‘‡with length ğ‘›into an
entropy rate. Cover and Thomas [7] show that
Hğ¶(ğ‘‡)=ğ‘(ğ‘›)(log2(ğ‘(ğ‘›))+1)
ğ‘›â†’H(ğ‘‹) (20)
forğ‘›â†’âˆ for a stationary ergodic sequence (their proof is based
on a proof by Wyner and Ziv [33]).
 
2240KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Jamal Mohammed, Michael H.BÃ¶hlen, and Sven Helmer
When implementing NLZ1, the most expensive part is finding
a matching word in the dictionary. For symbolic data, this is just
a lookup in a hash table. However, due to using the more com-
plicated comparison operator â‰ˆğœ–, we cannot just do a hash table
lookup. Clearly, we do not want to iterate through all the keys in
the dictionary one by one. Consequently, we divide the dictionary
into sub-dictionaries: one for each length, i.e., we have one sub-
dictionary for words of length one, one for sequences of length
two, and so on. In this way, we only have to look at a subset of
the words stored in the dictionary. We provide details about the
implementation and complexity in the appendix.
6.2 Numeric Lempel-Ziv 2 (NLZ2)
LZ2 appears in a paper by Wyner and Ziv[ 32] and looks for the
shortest prefix of the part of the time series not parsed yet that has
not been encountered anywhere in the parsed subsequence. Since
we use the estimator by Kontoyiannis et al. [ 16], we compute the
lengths of all words for every starting position within ğ‘‡. Again,
we have to make changes to be able to deal with numerical data,
utilizing the operator â‰ˆğœ–. Algorithm 2 shows pseudocode for NLZ2.
Algorithm 2: NLZ2(ğ‘‡=(ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘›))
1ğ‘–â†1, allocate list Î›â†(ğœ†1,ğœ†2,...,ğœ†ğ‘›);
2whileğ‘–â‰¤ğ‘›do
3 find the smallest ğ‘—â‰¥ğ‘–such that there is a word
ğ‘¤[ğ‘,ğ‘]âˆˆ(ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘–âˆ’1)withğ‘¤[ğ‘–,ğ‘—âˆ’1]â‰ˆğœ–ğ‘¤[ğ‘,ğ‘]
and no word ğ‘¤[ğ‘,ğ‘]âˆˆ(ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘–âˆ’1)with
ğ‘¤[ğ‘–,ğ‘—]â‰ˆğœ–ğ‘¤[ğ‘,ğ‘];
4ğœ†ğ‘–â†ğ‘—âˆ’ğ‘–+1;
5ğ‘–++;
6end
7return Î›
Again, we have to turn the returned value into an entropy rate.
Kontoyiannis et al. use the following formula for doing so:
Hğ¾(ğ‘‡)=log2(ğ‘›)
1
ğ‘›Ãğ‘›
ğ‘–=1ğœ†ğ‘–(21)
They show that for ğ‘›â†’âˆ ,Hğ¾(ğ‘‡)converges toH(ğ‘‹)for station-
ary ergodic processes. The motivation for computing ğœ†ğ‘–for every
position from 1 to ğ‘›and averaging the values is to decrease the
variance.
In NLZ2, we have to find a matching word in the part of the
time series we already parsed, which means doing threshold-based
comparisons again. In a first step, we build an inverted index for
faster lookup of matching values. For this purpose, we traverse the
time seriesğ‘‡and for each distinct value we find, we create a list of
positions where this value is found in ğ‘‡and store the information
in a dictionary. In a final step, we create a sorted array of all the
keys in the dictionary that acts as a directory for the inverted index.
After building the index, we traverse the time series value by
value and look up all previously parsed positions that match the cur-
rent value. For each of these positions, we find the longest matching
subsequence (up to the current position). The maximum length of
all these subsequences plus one (because we are looking for theshortest unseen subsequence) becomes the value of the current ğœ†.
Once we have determined the values of all ğœ†ğ‘–inÎ›, we can estimate
the entropy rate by using Equation (21).
Finally, we describe how lookups in the index work. In a first step,
we have to find all values in the directory of the index that match
the current value in the time series. Since the entries in the directory
are sorted, we use binary search to find the first matching value
(and then traverse back and forth from there). For every matching
value, we look up the positions in the dictionary and return those
that have already been parsed. Further details are provided in the
appendix.
7 EXPERIMENTAL EVALUATION
We run several experiments to evaluate our approach empirically.1
The first experiments are conducted in an ideal setting, i.e., first, the
time series satisfy all the assumptions made in Section 5 (covering
the theoretical results) and, second, we can determine the exact
entropy rate of the time series. We demonstrate that Î ğ‘šğ‘ğ‘¥is indeed
an upper bound for the predictability of numeric univariate time
series and that the entropy rate can also be estimated accurately
in an ideal scenario. Then, we move on to experiments using real-
world data, showing that our approach is also applicable if the
underlying assumptions do not hold.
7.1 Experimental setup and Datasets
We use the first 80% of each time series (ğ‘¥1,ğ‘¥2, ...,ğ‘¥ğ‘Ÿ)to train
different prediction models and to estimate Î ğ‘šğ‘ğ‘¥. The remaining
20% of the time series (ğ‘¥ğ‘Ÿ+1,ğ‘¥ğ‘Ÿ+2,...,ğ‘¥ğ‘›)is used to evaluate the
accuracy Î ğ‘šğ‘œğ‘‘ğ‘’ğ‘™of the models. Î ğ‘šğ‘œğ‘‘ğ‘’ğ‘™is computed as shown in
Formula (10), i.e., the proportion of correct predictions among all
predictions. We use a one-step ahead forecasting method [ 15], i.e.,
the next value is predicted based on past observations up to this
point. Letğ‘¥ğ‘¡be the actual value and Ë†ğ‘¥ğ‘¡=ğ‘“(ğ‘¥1,ğ‘¥2,...,ğ‘¥ğ‘¡âˆ’1)be
the prediction of a model for time step ğ‘¡, respectively. Similar to
Formula (7), the correctness of a prediction of a model using an
error is
ğ¸ğ‘šğ‘œğ‘‘ğ‘’ğ‘™ =(
1|ğ‘¥ğ‘¡âˆ’Ë†ğ‘¥ğ‘¡|>ğœ–
0ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’(22)
Thus, the prediction accuracy of a model boils down to
Î ğ‘šğ‘œğ‘‘ğ‘’ğ‘™=1âˆ’Ãğ‘›
ğ‘¡=ğ‘Ÿ+1ğ¸ğ‘šğ‘œğ‘‘ğ‘’ğ‘™
ğ‘›âˆ’ğ‘Ÿ(23)
We use the following datasets for the experiments:
â€¢Synthetic Datasets are based on First Order Markov Mod-
els. In the experiments, we label the datasets using the fol-
lowing schema: ğ‘ğ‘¥ğ·ğ‘¦ , whereğ‘¥represents the number of
states in the model, meaning the number of distinct values
that are generated, and ğ‘¦specifies the distribution of the
transition probabilities. We use the following distributions:
(1)ğ‘¦=ğ‘¢, uniform distribution, (2) ğ‘¦=ğ‘ , skewed distribu-
tion, i.e., Zipf distribution with ğ›¼=2, and (3)ğ‘¦=ğ‘–, where
ğ‘–âˆˆ{0,1,2,...,ğ‘˜}. The parameter ğ‘–determines the transi-
tion probabilities in the following way: ğ‘âˆ’1transitions,
called weak transitions, have probability ğ‘ğ‘–ğ‘¤=1
10ğ‘–ğ‘, and
the remaining transition, called dominant transition, has the
1The code and data can be accessed on: https://github.com/JamalSZ/QEPUBUNTS
 
2241Quantifying and Estimating the Predictability Upper Bound of Univariate Numeric Time Series KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
probabilityğ‘ğ‘–
ğ‘‘=1âˆ’(ğ‘âˆ’1)ğ‘ğ‘–ğ‘¤. Forğ‘–=0, we have a uniform
distribution; for larger ğ‘–, we have more skew.
â€¢TheS&P 5002open price dataset provides a collection of
daily opening prices for individual stocks. The python pan-
das_datareader package with parameters symbol=â€™GSPCâ€™,
start date=04-01-1990, end date= 31-10-2021 and data_source
= â€™yahooâ€™ was used to load the data from Yahoo! Finance.
â€¢TheTemperature3dataset provides hourly temperature
values of the city of Zurich Switzerland.
â€¢ETTh1 (Electricity Transformer Temperature hourly) is a
dataset about the long-term deployment of electric power,
consisting of two-year hourly oil temperatures of electric
household power generators. [18].
â€¢ThePrecipitation4dataset (CPC-CONUS) contains daily
rain measurements. For the experiments, we use historical
records of location (39â—¦N, 109â—¦W) from 1948 until 2024.
We use the real-world datasets to show that our approach also
works when assumptions such as stationarity do not hold and the
time series show a trend or seasonality. We ran the Augmented
Dickey-Fuller5(ADF) stationarity test [ 20,21], indicating how much
each dataset deviates from stationarity (ADF critical values are:
âˆ’3.431for 1%,âˆ’2.862for 5%, andâˆ’2.567for 10%). Based on the
p-values and the ADF statistic (see Table 1 for an overview of ADF
results and trend/seasonality for all datasets), the ETTh1 dataset
can be considered marginally stationary at a 1% significance level
and stationary at the 5% level and shows seasonality, but no trend.
The S&P 500 dataset does not meet any of the ADF criteria and
is therefore clearly non-stationary, showing only a trend. For the
Temperature dataset, the p-value and the ADF statistics are lower
than the 1% critical value, indicating stationarity. It shows seasonal-
ity, but no trend. Finally, the Precipitation dataset has a p-value and
an ADF statistic far below the critical values, strongly indicating
stationarity.
ADF Statistic p-value trend seasonality
ETTh1 -3.416 0.010 âœ“
S&P 500 0.856 0.992 âœ“
Temperature -3.732 0.004 âœ“
Precipitation -114.624 0.000 âœ“ âœ“
Table 1: Stationarity Test
We implemented our algorithms from scratch in Python and
conducted the experiments on a machine with an Intel Xeon Silver
4214 CPU with 48 cores at 1.000GHz, running Debian GNU/Linux
10 (buster)ğ‘¥86_64as operating system. Solving Equation (19)for
Î maxis done using the numerical solver scipy.optimize.fsolve().6
2https://finance.yahoo.com/quote/%5EGSPC/history/
3https://data.stadt-zuerich.ch/dataset/ugz_meteodaten_stundenmittelwerte (Accessed
on 20-11-2021)
4Copernicus Climate Change Service, Climate Data Store, (2021): Temperature and
precipitation gridded data for global and regional domains derived from in-situ and
satellite observations. Copernicus Climate Change Service (C3S) Climate Data Store
(CDS). DOI: 10.24381/cds.11dedf0c (Accessed on 11-06-2024)
5https://www.statsmodels.org/dev/generated/statsmodels.tsa.stattools.adfuller.html
6https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html7.2 Ideal Scenario
For the ideal scenarios, we use synthetic datasets and set the tol-
erance level ğœ–to 0 for the moment to ensure that all theoretical
assumptions are met and that we can compute the exact entropy
rate.
7.2.1 Î ğ‘šğ‘ğ‘¥is an Upper Bound. We generated 20 synthetic datasets
NxDy varying the number of states ğ‘¥and the probability distribu-
tionsğ‘¦for the transitions: ğ‘¥âˆˆ{5,10,15,..., 50}andğ‘¦âˆˆ{ğ‘¢,ğ‘ }. The
case forğ‘¦=ğ‘ is highly predictable, because every state has one very
likely transition, while the case for ğ‘¦=ğ‘¢is unpredictable, since
every transition probability is the same. We trained two models
on the generated time series: ARIMA of order 1 (AR(1)) and a first-
order Markov model (FOMM). We cannot do better than FOMM, as
it follows the underlying generating process perfectly.
(a) Uniform Î ğ‘šğ‘ğ‘¥,ğ‘‡vsÎ ğ‘šğ‘œğ‘‘ğ‘’ğ‘™
(b) Skewed Î ğ‘šğ‘ğ‘¥,ğ‘‡vsÎ ğ‘šğ‘œğ‘‘ğ‘’ğ‘™
Figure 4: First-Order-Markov-Model Synthetic
Figure 4 compares the predictabilities of the models and Î ğ‘šğ‘ğ‘¥
with each other. On the x-axis, we vary the number of different
states of the Markov model and the y-axis measures the predictabil-
ity (as defined in Equation 23). We make the following observations.
First,Î ğ‘šğ‘ğ‘¥is indeed an upper bound for these datasets, its curve
is always above the ones for AR(1) and FOMM. Additionally, the
general shape of the curves for FOMM and Î ğ‘šğ‘ğ‘¥is very similar (in
particular for the more predictable dataset with ğ‘¦=ğ‘ ), indicating
thatÎ ğ‘šğ‘ğ‘¥captures the potential predictability of the time series
well. This is remarkable, because Î ğ‘šğ‘ğ‘¥does not make any assump-
tions about the probability distribution underlying the generating
process. Finally, as expected, the upper bound Î ğ‘šğ‘ğ‘¥is also smaller
for the less predictable datasets ( ğ‘¦=ğ‘¢) and higher for the more
predictable ones ( ğ‘¦=ğ‘ ).
7.2.2 Entropy Rate Estimation. As already mentioned before, the
accurate estimation of entropy rates is crucial for us. While most
proposed estimators converge to the true value for time series of
infinite lengths, for finite time series the situation is more complex.
For this experiment, we generated eight datasets ğ‘ğ‘¥ğ·ğ‘– with
ğ‘¥=10,ğ‘–=0,1,2,..., 7for figure 5a and 13 datasets ğ‘ğ‘¥ğ·ğ‘¦ with
ğ‘¥=2,3,4,5,10,15,..., 50andğ‘¦=ğ‘¢for figure 5b. In Figure 5, we
compare the quality of NLZ1 and NLZ2 with the exact entropy rate
for the generated datasets. On the x-axis, we vary ğ‘–, depicting the
weak transition probability ğ‘ğ‘–ğ‘¤(Figure 5a) and the number of states
(Figure 5b). On the y-axis we show the entropy rate. We actually
display the plot twice in Figure 5a: the upper half uses a linear scale,
while the lower half uses a logarithmic one. Let us first look at
 
2242KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Jamal Mohammed, Michael H.BÃ¶hlen, and Sven Helmer
(a)ğ»ğ‘’ğ‘¥ğ‘ğ‘ğ‘¡ /ğ»ğ‘ ğ¿ğ‘ 1/ğ»ğ‘ ğ¿ğ‘ 2
 (b)ğ»ğ‘’ğ‘¥ğ‘ğ‘ğ‘¡ /ğ»ğ‘ ğ¿ğ‘ 1/ğ»ğ‘ ğ¿ğ‘ 2
Figure 5: Entropy Estimation for different entropy levels
the NLZ1 estimator: in Figure 5a it overestimates the true entropy
rate, but gets closer for large values of ğ‘ğ‘–ğ‘¤(high level of entropy);
in Figure 5b it starts out by overestimating the true rate for small
values ofğ‘¥(i.e., lower level of entropy) and then gradually shifts
to underestimating the rate for large values of ğ‘¥(i.e., higher level
of entropy). This confirms empirical results by Lesne et al. in [17],
who demonstrated that the accuracy of entropy rate estimators
depends on the entropy level of the dataset. The classic Lempel-Ziv
estimator, called LZ76 in [ 17], overestimated the entropy rate for
low entropy levels and underestimated it for high entropy levels.
We now turn to the NLZ2 estimator. When Kontoyiannis et al.
developed their estimator [ 16], they assumed that standard Lempel-
Ziv estimators tend to overestimate the true entropy rate based on
experiments conducted on a dataset consisting of four Jane Austen
novels. While this assumption holds for English text, which has a
relatively low entropy rate of 1.6 bits per character, Kontoyiannis
et al. did not consider other datasets with higher levels of entropy,
missing the fact that Lempel-Ziv estimators do not always over-
estimate the true entropy. Their goal was to create an estimator
that, while converging to the true entropy for time series of infinite
lengths, produces estimates that are lower than those of NLZ1 for
finite ones. We confirm this in Figures 5a and 5b: NLZ2 generally
underestimates the true entropy rate, except for datasets with very
low levels of entropy (see lower left corners of figures). For our
purposes, the NLZ2 estimator is usually the better estimator, as
an underestimation of the true entropy rate will guarantee that
Î ğ‘šğ‘ğ‘¥is an upper bound. We come back to the discussion of the
entropy level of datasets when investigating real-world data sets in
Section 7.3. We also studied the convergence rate of the estimators:
there is no substantial difference between NLZ1 and NLZ2 (the
results can be found in the appendix).
7.3 Real-World Time Series
We now investigate the four real-world datasets ETTh1, S&P 500,
Temperature, and Precipitation. Figures 6a, 6b, 6c, and 6d show
Î ğ‘šğ‘ğ‘¥, computed with NLZ1 and NLZ2, and different models trained
on the data: SciNet[ 18], ARIMA[ 14], LSTM[ 13], and CNNLSTM[ 8].
On the x-axis we vary the tolerance threshold ğœ–(low values of ğœ–
mean a high level of entropy and vice versa) and on the y-axis we
display the predictability.
For the experiments, we varied the threshold level from ğœ–ğ‘šğ‘ğ‘¥=
ğ‘šğ‘ğ‘¥(ğ‘‡)âˆ’ğ‘šğ‘–ğ‘›(ğ‘‡)
2, where all values match each other, i.e., we havean entropy of 0, down to ğœ–ğ‘šğ‘–ğ‘›=ğ‘šğ‘–ğ‘›(ğ‘¥ğ‘–âˆ’ğ‘¥ğ‘—)
2,âˆ€ğ‘¥ğ‘–,ğ‘¥ğ‘—âˆˆğœ’(withğœ’
being the set of unique values in T), where non-identical values
never match, i.e., we have the highest possible entropy rate. For
practical purposes, a user would have to choose a value that reflects
the margin of error that is still acceptable for an application.
We observe that the models perform differently for the various
datasets, but the most important question is: is Î ğ‘šğ‘ğ‘¥still an upper
bound for predictability for real-world datasets when many of
the assumptions made for the proofs do not hold anymore (see
Section 7.1). If we use the NLZ1 estimator, the answer seems to
be no, as for high values of ğœ–, the predictability of many models
surpasses Î ğ‘šğ‘ğ‘¥. It is actually more intricate, as the differences
between NLZ1 and NLZ2 heavily depend on the entropy level.
Large values of ğœ–mean that we are more lenient when it comes
to matching values and this has a direct impact on the entropy
rate: the larger ğœ–, the lower the entropy rate, which can be seen in
Figures 6e, 6f,6g, and 6h for the different datasets. For low levels
of entropy (i.e., large values of ğœ–), as we have seen in Section 7.2.2,
the NLZ1 estimator overestimates the true entropy rate and, conse-
quently, we end up with an underestimation for Î ğ‘šğ‘ğ‘¥. Significantly
overestimating the true entropy rate leads to a situation in which
Î ğ‘šğ‘ğ‘¥ceases to be an upper bound, while underestimating the true
entropy rate leads to a looser bound for Î ğ‘šğ‘ğ‘¥(however, Î ğ‘šğ‘ğ‘¥is
still an upper bound). The NLZ2 estimator was specifically built to
provide lower estimates than NLZ1, converging to the true value
from below, and, therefore, is better suited for low levels of entropy.
For high levels of entropy (i.e., small values of ğœ–), we are faced with
a different situation: at some point (e.g., in Figure 5b this was for an
entropy rate between 3 and 4), NLZ1 switches from overestimating
to underestimating the true entropy rate. Around this breakeven
point, NLZ1 provides a very accurate estimation of the entropy
rate and if we move to higher levels of entropy, NLZ1 gives us
better results than NLZ2, which underestimates the true entropy
rate more and more (resulting in a looser upper bound for Î ğ‘šğ‘ğ‘¥).
Consequently, for low levels of entropy, NLZ2 should be used, while
for high levels of entropy, NLZ1 is the better estimator.
For very low levels of entropy, NLZ2 starts to overestimate the
true entropy rate as well. This the case for very large values of ğœ–for
real-world datasets, where Î ğ‘šğ‘ğ‘¥may cease to be an upper bound.
Nevertheless, we argue that for practical purposes, these cases are
irrelevant, since the predictability reaches values close to one, which
means that we know that these scenarios are highly predictable.
Additionally, very large values for the tolerance threshold ğœ–are
useless from the application point of view: for instance, assuming a
stock price with a value of $200, making predictions within a range
of +$100/-$100 of the true value is not useful.
8 CONCLUSION AND FUTURE WORK
We developed a technique for quantifying an upper bound for the
predictability of univariate numeric time series and implemented
an algorithm to estimate this upper bound. Unlike conventional
approaches for adapting discrete algorithms to numeric data by
discretizing the data, we introduce a tolerance threshold ğœ–, which
allows us to avoid the proximity issues caused by discretization.
In an empirical study, we validate the effectiveness of our ap-
proach and demonstrate that it can also be applied in real-world
 
2243Quantifying and Estimating the Predictability Upper Bound of Univariate Numeric Time Series KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
(a) ETTh1
 (b) S&P 500 Open Price
 (c) City of ZÃ¼rich Temperature
 (d) Precipitation
(e) ETTh1
 (f) S&P 500 Open Price
 (g) City of ZÃ¼rich Temperature
 (h) Precipitation
Figure 6: (a), (b), (c), (d) Î ğ‘šğ‘ğ‘¥vsÎ ğ‘šğ‘œğ‘‘ğ‘’ğ‘™and (e), (f), (g), (h) ğ»ğ‘ğ¿ğ‘ 1vsğ»ğ‘ğ¿ğ‘ 1(real-world datasets)
settings, which do not always adhere to the conditions assumed by
the theoretical framework we use. We showcase the utility of our
method across a range of scenarios and datasets.
While the computation of the upper bound Î ğ‘šğ‘ğ‘¥itself is robust
and stable, it relies on sufficiently accurate estimations of the en-
tropy rate of a given time series. While the theoretical properties
of entropy rate estimators are largely understood, especially in
scenarios modeling infinite time series, investigations into finite
time series (for real-world applications) are few and far between.
We plan to analyze the behavior and properties of entropy rate
estimators for various finite time series with the goal of developing
more robust estimators that consider the overall entropy level of a
dataset, allowing us to unlock the full potential of our approach.
REFERENCES
[1]Peter Andreasen. 2001. Universal Source Coding. Masterâ€™s thesis. University of
Copenhagen, Copenhagen, Denmark.
[2]Valentina Baccetti and Matt Visser. 2012. Infinite Shannon entropy. Journal of
Statistical Mechanics: Theory and Experiment 2013 (12 2012). https://doi.org/10.
1088/1742-5468/2013/04/P04010
[3]Christoph Bandt and Bernd Pompe. 2002. Permutation Entropy: A Natural
Complexity Measure for Time Series. Phys. Rev. Lett. 88 (Apr 2002), 174102. Issue
17. https://doi.org/10.1103/PhysRevLett.88.174102
[4]Richard E. Blahut. 2002. 25 - Information Theory and Coding. In Reference Data for
Engineers (Ninth Edition) (ninth edition ed.), Wendy M. Middleton and Mac E. Van
Valkenburg (Eds.). Newnes, Woburn, 25â€“1â€“25â€“31. https://doi.org/10.1016/B978-
075067291-7/50027-3
[5]Weiting Chen, Jun Zhuang, Wangxin Yu, and Zhizhong Wang. 2009. Measuring
complexity using FuzzyEn, ApEn, and SampEn. Medical Engineering & Physics
31, 1 (2009), 61â€“68. https://doi.org/10.1016/j.medengphy.2008.04.005
[6]Zhe Chen, Yaâ€™an Li, Hongtao Liang, and Jing Yu. 2019. Improved Permutation
Entropy for Measuring Complexity of Time Series under Noisy Condition. Com-
plexity 2019 (2019), 1403829:1â€“1403829:12. https://doi.org/10.1155/2019/1403829
[7]Thomas M. Cover and Joy A. Thomas. 2006. Elements of Information Theory (2nd
edition ed.). John Wiley & Sons, Inc.
[8]Jeff Donahue, Lisa Anne Hendricks, Sergio Guadarrama, Marcus Rohrbach, Sub-
hashini Venugopalan, Trevor Darrell, and Kate Saenko. 2015. Long-term recurrent
convolutional networks for visual recognition and description. In IEEE Conference
on Computer Vision and Pattern Recognition, CVPR 2015, Boston, MA, USA, June
7-12, 2015. IEEE Computer Society, 2625â€“2634. https://doi.org/10.1109/CVPR.
2015.7298878[9] Andrew Feutrill. 2023. Characterisation and Estimation of Entropy Rate for Long
Range Dependent Processes. Ph. D. Dissertation. University of Adelaide, Adelaide,
Australia.
[10] Joshua Garland, Ryan James, and Elizabeth Bradley. 2014. Model-free quantifi-
cation of time-series predictability. Phys. Rev. E 90 (Nov 2014), 052910. Issue 5.
https://doi.org/10.1103/PhysRevE.90.052910
[11] Dina Q. Goldin and Paris C. Kanellakis. 1995. On Similarity Queries for Time-
Series Data: Constraint Specification and Implementation. In 1st Int. Conf. on
Principles and Practice of Constraint Programming (CPâ€™95). Cassis, France, 137â€“153.
https://doi.org/10.1007/3-540-60299-2_9
[12] Yanjun Han, Jiantao Jiao, Chuan-Zheng Lee, Tsachy Weissman, Yihong Wu, and
Tiancheng Yu. 2018. Entropy Rate Estimation for Markov Chains with Large
State Space. arXiv:1802.07889 [cs.LG]
[13] Sepp Hochreiter and JÃ¼rgen Schmidhuber. 1997. Long Short-Term Memory.
Neural Computation 9, 8 (11 1997), 1735â€“1780. https://doi.org/10.1162/neco.1997.
9.8.1735
[14] R.J. Hyndman and G. Athanasopoulos. 2021. Forecasting: principles and practice
(3rd edition ed.). OTexts: Melbourne, Australia. OTexts.com/fpp3.
[15] Rob J. Hyndman and Anne B. Koehler. 2006. Another look at measures of
forecast accuracy. International Journal of Forecasting 22, 4 (2006), 679â€“688.
https://doi.org/10.1016/j.ijforecast.2006.03.001
[16] Kontoyiannis I., Algoet P. H., Suhov Yu. M., and Wyner A. J. 1998. Nonpara-
metric Entropy Estimation for Stationary Processes and Random Fields, with
Applications to English Text. IEEE Transactions on Information Theory 44 (1998),
1319â€“1327.
[17] Annick Lesne, Jean-Luc Blanc, and Laurent Pezard. 2009. Entropy estimation
of very short symbolic sequences. Phys. Rev. E 79 (Apr 2009), 046208. Issue 4.
https://doi.org/10.1103/PhysRevE.79.046208
[18] Minhao Liu, Ailing Zeng, Muxi Chen, Zhijian Xu, Qiuxia Lai, Lingna Ma, and
Qiang Xu. 2022. SCINet: Time Series Modeling and Forecasting with Sample
Convolution and Interaction. arXiv:2106.09305 [cs.LG]
[19] E.N. Lorenz. 1995. Predictability: a problem partly solved. In Seminar on Pre-
dictability. ECMWF, Reading, United Kingdom, 1â€“18.
[20] James G MacKinnon. 1994. Approximate asymptotic distribution functions for
unit-root and cointegration tests. Journal of Business & Economic Statistics 12, 2
(1994), 167â€“176.
[21] James G MacKinnon. 2010. Critical values for cointegration tests. Technical Report.
Queenâ€™s Economics Department Working Paper.
[22] Michael D. Morse and Jignesh M. Patel. 2007. An efficient and accurate method
for evaluating time series similarity. In Proc. of the ACM SIGMOD Int. Conf. on
Management of Data. ACM, Beijing, China, 569â€“580. https://doi.org/10.1145/
1247480.1247544
[23] Athanasios Papoulis and S. Unnikrishna Pillai. 2002. Probability, Random Variables,
and Stochastic Processes (4th ed.). McGraw Hill, Boston.
[24] Frank Pennekamp, Alison C. Iles, Joshua Garland, Georgina Brennan, Ulrich Brose,
Ursula Gaedke, Ute Jacob, Pavel Kratina, Blake Matthews, Stephan Munch, Mark
Novak, Gian Marco Palamara, BjÃ¶rn C. Rall, Benjamin Rosenbaum, Andrea Tabi,
 
2244KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Jamal Mohammed, Michael H.BÃ¶hlen, and Sven Helmer
Colette Ward, Richard Williams, Hao Ye, and Owen L. Petchey. 2019. The intrinsic
predictability of ecological time series and its potential to guide forecasting.
Ecological Monographs 89, 2 (2019), e01359. https://doi.org/10.1002/ecm.1359
[25] Steven M. Pincus. 1991. Approximate entropy as a measure of system complexity.
Proc. Natl. Acad. Sci. 88, 6 (1991), 2297â€“2301. https://doi.org/10.1073/pnas.88.6.
2297
[26] Joshua S. Richman and J. Randall Moorman. 2000. Physiological time-series
analysis using approximate entropy and sample entropy. American Journal of
Physiology-Heart and Circulatory Physiology 278, 6 (2000), H2039â€“H2049. https:
//doi.org/10.1152/ajpheart.2000.278.6.H2039
[27] Claude E. Shannon. 1948. A mathematical theory of communication. Bell Syst.
Tech. J. 27, 4 (1948), 623â€“656. https://doi.org/10.1002/j.1538-7305.1948.tb00917.x
[28] Claude E. Shannon. 1948. A mathematical theory of communication. Bell Syst.
Tech. J. 27, 3 (1948), 379â€“423. https://doi.org/10.1002/j.1538-7305.1948.tb01338.x
[29] Robert H. Shumway and David S. Stoffer. 2017. Time Series Analysis and Its
Applications (4th edition ed.). Springer. https://doi.org/10.1007/978-3-319-52452-
8
[30] Gavin Smith, Romain Wieser, James Goulding, and Duncan Barrack. 2014. A
refined limit on the predictability of human mobility. 2014 IEEE International
Conference on Pervasive Computing and Communications, PerCom 2014, 88â€“94.
https://doi.org/10.1109/PerCom.2014.6813948
[31] Chaoming Song, Zehui Qu, Nicholas Blumm, and Albert-LÃ¡szlÃ³ BarabÃ¡si. 2010.
Limits of Predictability in Human Mobility. Science 327(5968) (February 2010),
1018â€“1021.
[32] Aaron D. Wyner and Jacob Ziv. 1989. Some asymptotic properties of the entropy
of a stationary ergodic data source with applications to data compression. IEEE
Trans. Inf. Theory 35, 6 (1989), 1250â€“1258. https://doi.org/10.1109/18.45281
[33] Aaron D. Wyner and Jacob Ziv. 1991. Fixed data base version of the Lempel-
Ziv data compression algorithm. IEEE Trans. Inf. Theory 37, 3 (1991), 878â€“880.
https://doi.org/10.1109/18.79955
[34] Paiheng Xu, Likang Yin, ZhongTao Yue, and Tao Zhou. 2019. On predictability
of time series. Physica A-statistical Mechanics and Its Applications 523 (2019),
345â€“351.
[35] Jacob Ziv and Abraham Lempel. 1977. A Universal Algorithm for Sequential
Data Compression. IEEE Transactions on Information Theory 23 (1977), 337â€“343.
[36] Jacob Ziv and Abraham Lempel. 1978. Compression of individual sequences
via variable-rate coding. IEEE Trans. Inf. Theory 24, 5 (1978), 530â€“536. https:
//doi.org/10.1109/TIT.1978.1055934
A PROPERTIES OF MARKOV CHAINS
Definition 8. A sequence of random variables ğ‘‹1,ğ‘‹2,...ğ‘‹ğ‘›are
said to form a (first order) Markov chain if the conditional distribution
of anyğ‘‹ğ‘–depends only on ğ‘‹ğ‘–âˆ’1and is conditionally independent of
ğ‘‹1..ğ‘‹ğ‘–âˆ’2. Specifically, ğ‘‹1,ğ‘‹2,...ğ‘‹ğ‘›form a Markov chain if the joint
probability mass function can be written as:
ğ‘(ğ‘¥1,ğ‘¥2,..ğ‘¥ğ‘›)=ğ‘(ğ‘¥1)Â·ğ‘(ğ‘¥2|ğ‘¥1)Â·Â·Â·Â·Â·ğ‘(ğ‘¥ğ‘›|ğ‘¥ğ‘›âˆ’1) (24)
Theorem 4. Letğ‘‹={ğ‘‹ğ‘–}be a stationary Markov chain with ğ‘
unique states, stationary distribution ğœ‡ğ‘and transition probability
matrixğ‘ƒğ‘. Letğ‘‹1âˆ¼ğœ‡ğ‘. Then the exact entropy rate is:
Hğ‘’ğ‘¥ğ‘ğ‘ğ‘¡(ğ‘‹)=âˆ’Ã•
ğ‘–ğ‘—ğœ‡ğ‘–Â·ğ‘ƒğ‘–ğ‘—ğ‘™ğ‘œğ‘”ğ‘ƒğ‘–ğ‘—. (25)
where the stationary distribution is the solution of the following equa-
tion
ğœ‡ğ‘=ğœ‡ğ‘Â·ğ‘ƒğ‘ (26)
Example 1. Here we show how we compute the exact entropy rate
of a Markov chain. Let T = {0,1,0,1,0,1,0,1} with transition probability
matrix
ğ‘ƒ=0.5 0.5
0.5 0.5
In the general case, to compute ğœ‡ğ‘, we first initialize ğœ‡0with
arbitrary probabilities (summing up to one), e.g. ğœ‡0=[0.01,0.99]. We
then iteratively compute ğœ‡ğ‘–using Equation (26)(ğœ‡ğ‘–=ğœ‡ğ‘–âˆ’1Â·ğ‘ƒ) until
ğœ‡ğ‘–â‰ƒğœ‡ğ‘–âˆ’1. Since T is a uniformly distributed time series, the steady
stationary distribution of T is ğœ‡ğ‘={0.5,0.5}. Finally, we calculatethe entropy rate using Equation (25), obtaining
Hğ‘’ğ‘¥ğ‘ğ‘ğ‘¡(ğ‘‡)=âˆ’Ã2
ğ‘–=1Ã2
ğ‘—=1ğœ‡ğ‘–Â·ğ‘ƒğ‘–ğ‘—ğ‘™ğ‘œğ‘”ğ‘ƒğ‘–ğ‘—=âˆ’4âˆ—0.5âˆ—0.5Â·ğ‘™ğ‘œğ‘”20.5=1
B IMPLEMENTATION AND PSEUDOCODE
Figure 7 shows the pipeline of operations needed to compute Î max.
Calculating the value for ğ‘is straightforward, we determine the
minimum and maximum value occurring in ğ‘‡and then apply Equa-
tion(14). Solving Equation (19)forÎ maxis done using a numerical
solver scipy.optimize.fsolve()7function which finds the roots of
a nonlinear equation. As the most challenging part is estimating
the entropy rate, we provide more details on the implementation
of NLZ1 and NLZ2 here.
Input:
ğ‘‡andğœ–
Estimating
Entropy RateComputeğ‘
Solve
forÎ maxOutput: Î max
Figure 7: Framework Pipeline
B.1 Implementing NLZ1 and NLZ2
Algorithm 3 shows pseudocode for our implementation of the NLZ1
estimator and Algorithm 4 provides details about the lookup func-
tion we use.
In the NLZ2 algorithm, we first build an inverted index for faster
lookup of matching values, see Algorithm 5 for pseudocode. Algo-
rithm 6 shows pseudocode for the implementation of the actual
NLZ2 estimator. Finally, we describe how lookups in the index work.
We have to find all values in the directory of the index that match
the current value in the time series. Since the entries in the directory
are sorted, we use binary search to find the first matching value
(and then traverse back and forth from there). For every matching
value, we look up the positions in the dictionary and return those
that have already been parsed. Algorithm 7 shows pseudocode for
the lookup code.
B.2 Run Time Complexity
The run time of the algorithms presented in the previous sections
depends heavily on the distribution of the values within a time
series, which makes it difficult to analyze their complexity. Con-
sequently, we look at the extreme cases, i.e., the most expensive
and the least expensive one, all the other run times fall between
these two extremes. We focus on the complexity of Algorithm 6, as
it is more complicated than Algorithm 3. For two arbitrary values
ğ‘‡ğ‘–,ğ‘‡ğ‘—âˆˆğ‘‡,0â‰¤ğ‘–â‰ ğ‘—<ğ‘›, the extreme cases are:
â€¢Case 1:âˆ€ğ‘–,ğ‘—(ğ‘–â‰ ğ‘—):ğ‘‡ğ‘–Ì¸â‰ˆğœ–ğ‘‡ğ‘—, i.e.,ğ‘‡ğ‘–andğ‘‡ğ‘—never overlap
â€¢Case 2:âˆ€ğ‘–,ğ‘—(ğ‘–â‰ ğ‘—):ğ‘‡ğ‘–â‰ˆğœ–ğ‘‡ğ‘—, i.e.,ğ‘‡ğ‘–andğ‘‡ğ‘—always overlap
7https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html
 
2245Quantifying and Estimating the Predictability Upper Bound of Univariate Numeric Time Series KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Algorithm 3: NLZ1(ğ‘‡=(ğ‘‡1,ğ‘‡2,...,ğ‘‡ğ‘›),ğœ–)
1ğ‘–â†1,ğ·â†âˆ…;
2whileğ‘–â‰¤ğ‘›do
3 curSeqâ†ğ‘‡ğ‘–;
4 while LZ1lookup(curSeq, ğ·,ğœ–)do
5ğ‘–++;
6 ifğ‘–â‰¤ğ‘›then
7 appendğ‘‡ğ‘–to curSeq;
8 else
9 break;
10 end
11 ifnot len(curSeq) in ğ·then
12 ğ·[len(curSeq)][ curSeq]â† 1;
13 ğ‘–++;
14 end
15 end
16end
17forğ‘–â†1to len(ğ·)do
18ğ‘ğ‘›â†ğ‘ğ‘›+len(ğ·[ğ‘–]);
19end
20returnğ‘ğ‘›(log2(ğ‘ğ‘›)+1)
ğ‘›
Algorithm 4: NLZ1lookup(curSeq, D, ğœ–)
1foundâ†false;
2forseq inğ·[len(curSeq)] do
3ğ‘–â†1;
4 while(ğ‘–â‰¤len(curSeq))âˆ§( curSeq[ğ‘–]â‰ˆğœ–seq[ğ‘–])do
5ğ‘–++;
6 end
7 ifğ‘–>len(curSeq) then
8 foundâ†true;
9 break;
10 end
11end
12return found
Algorithm 5: NLZ2buildIdx( ğ‘‡)
1ğ·â†âˆ…;
2forğ‘–â†1to len(ğ‘‡)do
3ğ·[ğ‘‡[ğ‘–]].append(ğ‘–);
4end
5Dirâ†sorted array of keys in ğ·;
6return InvIdx(Dir,ğ·)
Case 1 .In this scenario, the loop in line 6 of Algorithm 6 will
never be executed, as the set stored in the variable matches will al-
ways be empty. The lookup in line 5 (see also Algorithm 7), although
yielding no matches (since ğ‘‡ğ‘–Ì¸â‰ˆğœ–ğ‘‡ğ‘—, has to search the dictionary.
As the size of the dictionary is at most ğ‘›and we use binary search,
the run time for one search is ğ‘‚(logğ‘›). In Algorithm 6, the lookupAlgorithm 6: NLZ2(ğ‘‡=(ğ‘‡1,ğ‘‡2,...,ğ‘‡ğ‘›),ğœ–)
1Î›â†{ğœ†1...ğœ†ğ‘›}; // initialize all ğœ†ğ‘–with 0
2Idxâ†LZ2buildIIdx( ğ‘‡) ;
3forcurâ†1 toğ‘›do
4ğœ†maxâ†0;
5 matchesâ†LZ2lookup(Idx, ğ‘‡, cur,ğœ–);
6 forğ‘–in matches do
7ğœ†â†0;
8 while(cur+ğœ†<ğ‘›)âˆ§(ğ‘–+ğœ†<cur)do
9 ifğ‘‡[ğ‘–+ğœ†]â‰ˆğœ–ğ‘‡[cur+ğœ†]then
10 ğœ†++;
11 end
12 end
13 ifcur+ğœ†=ğ‘›then
14 return Î›
15 end
16 ifğœ†>ğœ†maxthen
17 ğœ†maxâ†ğœ†;
18 end
19 end
20ğœ†ğ‘ğ‘¢ğ‘Ÿâ†ğœ†max+1;
21end
22return Î›
is invokedğ‘›times (see line 3), thus the overall run time complexity
of Case 1 is ğ‘‚(ğ‘›logğ‘›).
Case 2 .In this case, because the current value ğ‘‡ğ‘ğ‘¢ğ‘Ÿof the time
series matches all previously seen ones ğ‘‡1,ğ‘‡2,...,ğ‘‡ğ‘ğ‘¢ğ‘Ÿâˆ’1, the size
of the set returned by the lookup (and stored in matches ) is equal
toğ‘ğ‘¢ğ‘Ÿâˆ’1. Subsequently, the loop in line 6 of Algorithm 6 will be
invokedğ‘ğ‘¢ğ‘Ÿâˆ’1times. The number of comparisons performed in
the loop starting at line 8is inversely proportional to the value of
ğ‘–: the larger ğ‘–, the fewer comparisons we need to make ( ğ‘ğ‘¢ğ‘Ÿâˆ’1
comparisons for ğ‘–=1,ğ‘ğ‘¢ğ‘Ÿâˆ’2comparisons for ğ‘–=2, and so forth).
Thus, in total, we have to make
ğ‘ğ‘¢ğ‘Ÿâˆ’1Ã•
ğ‘–=1ğ‘ğ‘¢ğ‘Ÿâˆ’ğ‘–=ğ‘ğ‘¢ğ‘Ÿâˆ’1Ã•
ğ‘–=1ğ‘ğ‘¢ğ‘Ÿâˆ’ğ‘ğ‘¢ğ‘Ÿâˆ’1Ã•
ğ‘–=1ğ‘– (27)
=ğ‘ğ‘¢ğ‘Ÿ2âˆ’1
2(ğ‘ğ‘¢ğ‘Ÿâˆ’1)ğ‘ğ‘¢ğ‘Ÿ (28)
=1
2ğ‘ğ‘¢ğ‘Ÿ(ğ‘ğ‘¢ğ‘Ÿ+1) (29)
comparisons in the inner loops (line 6 and line 8), which are exe-
cuted for each iteration of the outermost loop in line 3. The out-
ermost loop stops at cur =ğ‘›
2, since we reach the end of the time
series when searching for the longest match (see condition in line
8). So, the overall number of iterations is
ğ‘›
2Ã•
ğ‘ğ‘¢ğ‘Ÿ=11
2ğ‘ğ‘¢ğ‘Ÿ(ğ‘ğ‘¢ğ‘Ÿ+1) (30)
 
2246KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Jamal Mohammed, Michael H.BÃ¶hlen, and Sven Helmer
Sinceğ‘‚(1
2ğ‘ğ‘¢ğ‘Ÿ(ğ‘ğ‘¢ğ‘Ÿ+1))=ğ‘‚(ğ‘ğ‘¢ğ‘Ÿ2)andğ‘‚(ğ‘›
2)=ğ‘‚(ğ‘›), we obtain
ğ‘›Ã•
ğ‘ğ‘¢ğ‘Ÿ=1ğ‘ğ‘¢ğ‘Ÿ2=ğ‘›(ğ‘›+1)(2ğ‘›+1)
6=ğ‘‚(ğ‘›3) (31)
via the square pyramidal number of ğ‘›.
Therefore, the worst-case complexity of Case 2 is ğ‘‚(ğ‘›3). Strictly
speaking, there is still the cost ğ‘‚(ğ‘›logğ‘›)of looking up the matches
in line 5, but this cost is dominated by ğ‘‚(ğ‘›3).
Algorithm 7: NLZ2lookup(Idx, ğ‘‡, cur,ğœ–)
1matchesâ†âˆ…;
2forallğ‘–such that Idx.Dir[ ğ‘–]â‰ˆğœ–ğ‘‡[ğ‘ğ‘¢ğ‘Ÿ]do
3 forpos in Idx.ğ·[Idx.Dir[ğ‘–]]do
4 ifpos<curthen
5 matchesâ†matchesâˆª{ pos };
6 end
7 end
8end
9return matches
C CONVERGENCE OF THE ENTROPY RATE
ESTIMATION
As we are estimating the entropy rate of finite time series, the rate
of convergence of the estimation becomes a crucial aspect in deter-
mining the stability of the value Î ğ‘šğ‘ğ‘¥for increasing time series
lengths. It is usually difficult for real-world datasets to determine
this convergence rate, as several factors influence it. Nevertheless,
it would be of great help to get an indication that the length of the
time series is sufficiently large to ensure a reliable value for Î ğ‘šğ‘ğ‘¥.
Han et al. claim that a length of ğ‘›â‰«ğ‘2, whereğ‘is the alphabet
size, is sufficient [ 12]. We found two issues with this approach. First
of all, what is the exact meaning of â€œ â‰«â€, i.e., when is ğ‘›much greater
thanğ‘2in terms of concrete values? Second, the inequality given
in [12] is too simplistic, as the convergence rate does not depend on
the alphabet size alone. It is possible to have different convergence
rates for the same value of ğ‘, but different levels of entropy [17].
We propose an approach based on measuring the differences of
the entropy rate taken from neighboring (equi-distant) points in
time. More formally, if we, for instance, estimate the entropy rate for
ğ‘›=1000,2000,3000,... (whereğ‘›denotes the length of the prefix of
a time series we use for the estimation), then Î”(ğ‘›1,ğ‘›2)=H2000âˆ’
H1000measures the first difference, Î”(ğ‘›2,ğ‘›3)=H3000âˆ’H 2000the
second one, and so on (for computing Hwe use Algorithm 1 or 2).
However, we found that using absolute values for the difference can
be misleading: depending on the level of entropy, the differences
vary. For high levels of entropy, the entropy rate starts out with
a large value and tends to drop steeply. In contrast, for low levels
of entropy, the values of the entropy rate start out smaller and
decrease more slowly. Hence, we measure the relative difference:
Î”ğ‘Ÿ(ğ‘›ğ‘–,ğ‘›ğ‘–+1)=Hğ‘›ğ‘–+1âˆ’Hğ‘›ğ‘–
max(Hğ‘›ğ‘–+1âˆ’Hğ‘›ğ‘–). (32)When the relative difference drops below a certain threshold, we
know that the obtained estimates are stable enough for a reliable
estimation of Î ğ‘šğ‘ğ‘¥.
(a) Convergence Threshold = 1% N=10
(b) Convergence Threshold = 1% N=50
Figure 8: Convergence of H with increasing n for different
values ofğœ–
We ran some experiments investigating the convergence by gen-
erating two datasets ğ‘ğ‘¥ğ·ğ‘¦ withğ‘¥={10,50}andğ‘¦=ğ‘¢looking
at the convergence rate of the entropy rate estimators (here we
show the results for the NLZ2 estimator, the ones for NLZ1 are
very similar). Like in the previous experiments, we also expected
the entropy level of the data to have an effect. Figures 8a and 8b
illustrate the results for ğ‘¥=10andğ‘¥=50, respectively. On the
x-axis, we vary ğ‘›, the length of the time series, and on the y-axis, we
varyğœ–, the tolerance threshold. The numbers in the heatmaps are
computed by subtracting the entropy for ğ‘›from the value for the
previousğ‘›according to Equation (32)(forğ‘›=1000, we subtract the
value from that for ğ‘›=500, which is not shown). Again, we observe
that the level of entropy of the time series has an impact. For high
levels of entropy, i.e., small values of ğœ–, the estimators converge
fairly quickly, while for low levels of entropy, i.e., large values of
ğœ–, the estimators take longer. This is an important observation, as
it means that it is not sufficient to just make sure that ğ‘›â‰«ğ‘2
as claimed by Han et al. in [ 12], but that we also need to consider
the level of entropy of the data. For very low levels of entropy, the
estimators can take quite some time to converge (bottom rows in
Figures 8a and 8b). However, for practical purposes, these cases are
not important; we also discuss this matter in Section 7.3.
 
2247