Dense Subgraph Discovery Meets Strong Triadic Closure
Chamalee Wickrama Arachchi
University of Helsinki
Helsinki, Finland
chamalee.wickramaarachch@helsinki.fiIiro Kumpulainen
University of Helsinki
Helsinki, Finland
iiro.kumpulainen@helsinki.fiNikolaj Tatti
HIIT, University of Helsinki
Helsinki, Finland
nikolaj.tatti@helsinki.fi
Abstract
Finding dense subgraphs is a core problem with numerous graph
mining applications such as community detection in social net-
works and anomaly detection. However, in many real-world net-
works connections are not equal. One way to label edges as either
strong or weak is to use strong triadic closure (STC). Here, if one
node connects strongly with two other nodes, then those two nodes
should be connected at least with a weak edge. STC-labelings are
not unique and finding the maximum number of strong edges is
NP-hard. In this paper, we apply STC to dense subgraph discovery.
More formally, our score for a given subgraph is the ratio between
the sum of the number of strong edges and weak edges, weighted
by a user parameter ğœ†, and the number of nodes of the subgraph.
Our goal is to find a subgraph and an STC-labeling maximizing the
score. We show that for ğœ†=1, our problem is equivalent to finding
the densest subgraph, while for ğœ†=0, our problem is equivalent to
finding the largest clique, making our problem NP-hard. We pro-
pose an exact algorithm based on integer linear programming and
four practical polynomial-time heuristics. We present an extensive
experimental study that shows that our algorithms can find the
ground truth in synthetic datasets and run efficiently in real-world
datasets.
CCS Concepts
â€¢Theory of computation â†’Graph algorithms analysis.
Keywords
dense subgraph, strong triadic closure, integer linear programming
ACM Reference Format:
Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti. 2024.
Dense Subgraph Discovery Meets Strong Triadic Closure. In Proceedings of
the 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining
(KDD â€™24), August 25â€“29, 2024, Barcelona, Spain. ACM, New York, NY, USA,
11 pages. https://doi.org/10.1145/3637528.3671697
1 Introduction
Many social networks naturally contain both strongly connected
andweakly connected interactions among the entities of the net-
work. A question of particular interest is that given a set of pairwise
user interactions, how to infer the strength of the social ties within
the network? In other words, how to label the edges of an undi-
rected graph as either strong or weak?
This work is licensed under a Creative Commons Attribution
International 4.0 License.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s).
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671697(a) (
b) (
c)
Figure 1: Strong (Red) and weak (Blue) edges of the Karate
club dataset maximizing the number of strong edges (a), ğœ†=0
(b), andğœ†=0.5(c) using our integer linear program based
algorithm (STC-ILP). We define our score as the sum of the
number of strong and weak edges weighted by a parameter
ğœ†, divided by the size of the subgraph. The scores are 2.0and
2.06for (b) and (c), respectively. We see that (b) is a clique of
size 5.
The problem of inferring the strength of social ties based on
strong triadic closure principle (STC) has drawn attention over the
past decade within the data mining community [ 1,14,16,17,21,24].
The STC property assumes that there exist two types of social ties in
the network: either strong orweak. Letğ´,ğµ, andğ¶be three entities
in the network. If the entities ğ´andğµare strongly connected
with the entity ğ¶, then there should be at least a weak connection
betweenğ´andğµ. In other words, if both ğ´andğµare strong friends
ofğ¶, then some kind of connection between ğ´andğµshould also
exist. Note that these labels are not known and the goal is to infer
the labels from the given unlabeled graph.
In this paper, we incorporate the STC property into the prob-
lem of dense subgraph discovery [ 9,24]. More formally, given a
subgraph and a weight parameter ğœ†, we define a score as the ratio
between the sum of the number of strong and weak edges weighted
byğœ†and the number of nodes within the subgraph. Our objective
is to find a subgraph anda labeling that maximize our score while
satisfying the STC property within the subgraph.
We will see that when ğœ†=0finding an optimal subgraph is equal
to finding a maximum clique. On the other hand, for ğœ†=1, finding
an optimal subgraph is equal to finding the densest subgraph, that is,
a subgraphğ‘ˆmaximizing the ratio of edges and nodes, |ğ¸(ğ‘ˆ)|/|ğ‘ˆ|.
Both of these problems are well-studied. Optimizing the score for
0<ğœ†<1, yields a problem that is between these two cases. We
expect that for small ğœ†s the returned subgraph resembles a clique
whereas large ğœ†s yield a subgraph similar to the densest subgraph.
Example: We illustrate the difference between our problem and
the original STC problem considered by Sintos and Tsaparas [24] in
Figure 1. The goal of this paper is to find a subgraph that maximizes
our score while satisfying the STC property. In contrast, Sintos and
3334
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
Tsaparas [24] aims to label allthe edges in the graph such that the
number of weak edges is minimized. Figure 1 shows the results
obtained with the Karate club dataset with our exact algorithm. We
should stress that the labeling of the discovered subgraph might
be different from the labeling that maximizes strong edges for the
whole graph. In Figure 1 (c), we see that 4weak edges have been
turned into strong while the labeling of the remaining edges is
unchanged.
We show that our problem is NP-hard when ğœ†<1, and even
inapproximable when ğœ†=0since our problem then reduces to
theMax-Cliqe problem. However, the ğœ†=1case is solvable in
polynomial time. To solve the problem, we first propose an exact
algorithm based on integer linear programming which runs in
exponential time. We consider four other heuristics that run in
polynomial time in the size of the input graph: We propose a linear
linear programming based heuristic in Section 5.2 and a greedy
algorithm in Section 5.4. We also propose two straightforward
algorithms that combine the existing algorithms for solving the
densest subgraph problem and finding STC-compliant labeling in
an entire graph.
The remainder of the paper is organized as follows. First, we
introduce preliminary notation and our problem in Section 2. Next,
we present the related work in Section 3. Next, we show that our
problem is NP-hard in Section 4 and then explain our algorithms
in Section 5. Finally, we present our experimental evaluation in
Section 6 and conclude the paper with a discussion in Section 7.
2 Preliminary notation and problem definition
We begin by providing preliminary notation and formally defining
our problem.
Our input is an unweighted graph ğº=(ğ‘‰,ğ¸), and we denote
the number of nodes and edges by ğ‘›=|ğ‘‰|andğ‘š=|ğ¸|. Given a
graphğº=(ğ‘‰,ğ¸)and a set of nodes ğ‘ˆâŠ†ğ‘‰, we defineğ¸(ğ‘ˆ)âŠ†ğ¸to
be the subset of edges having both endpoints in ğ‘ˆ. We denote the
degree of vertex ğ‘£asdeg(ğ‘£). We denote the set of adjacent edges
of vertexğ‘£asğ‘(ğ‘£).
We want to label the set of edges ğ¸as either strong orweak.
To perform the labeling, we use the strong triadic closure (STC)
property [ 24]. We say that the graph is STC satisfied if for any
given triplet of vertices, (ğ‘¥,ğ‘¦,ğ‘§)the following holds: if (ğ‘¥,ğ‘¦)and
(ğ‘¦,ğ‘§)are connected and are labeled as strongly connected, then the
edge(ğ‘¥,ğ‘§)always exists at least as a weak edge.
We call a triplet of vertices (ğ‘¥,ğ‘¦,ğ‘§)awedge, if(ğ‘¥,ğ‘¦)âˆˆğ¸,(ğ‘¦,ğ‘§)âˆˆ
ğ¸, and(ğ‘¥,ğ‘§)âˆ‰ğ¸. Awedge graph ğ‘(ğº)consists of the edges of the
graphğºthat contribute to at least one wedge as its vertices. If the
two edgesğ‘’1andğ‘’2ofğºform a wedge, we add an edge between
the two nodes in ğ‘(ğº)that corresponds to ğ‘’1andğ‘’2, that is, each
edge ofğ‘(ğº)corresponds to a wedge of ğº.
Given a graph ğº=(ğ‘‰,ğ¸)and a labeling ğ¿of the edges as strong
or weak, we write ğ¸ğ‘ (ğ‘ˆ,ğ¿)andğ¸ğ‘¤(ğ‘ˆ,ğ¿)to be the set of strong and
weak edges of the graph induced by a set of vertices ğ‘ˆ. We also
writeğ‘šğ‘ (ğ‘ˆ,ğ¿)=|ğ¸ğ‘ (ğ‘ˆ,ğ¿)|andğ‘šğ‘¤(ğ‘ˆ,ğ¿)=|ğ¸ğ‘¤(ğ‘ˆ,ğ¿)|. Finally, for
a vertexğ‘¢âˆˆğ‘ˆ, we define a strong and weak degree, degğ‘ (ğ‘¢,ğ‘ˆ,ğ¿)
anddegğ‘¤(ğ‘¢,ğ‘ˆ,ğ¿)to be the number of strong or weak edges in ğ‘ˆ
adjacent to ğ‘¢. We may omit ğ¿orğ‘ˆfrom the notation when it is
clear from the context.Given a weight parameter ğœ†whereğœ†âˆˆ[0,1]and a label assign-
mentğ¿, we define a score
q(ğ‘ˆ,ğ¿;ğœ†)=ğ‘šğ‘ (ğ‘ˆ,ğ¿)+ğœ†ğ‘šğ‘¤(ğ‘ˆ,ğ¿)
|ğ‘ˆ|.
We may omit ğ¿orğœ†when it is clear from the context.
We consider the following optimization problem.
Problem 1 (stc-den). Given a graph ğº=(ğ‘‰,ğ¸)and a weight
parameterğœ†, find a subset of vertices ğ‘ˆâŠ†ğ‘‰and a labeling ğ¿of the
edges as strong or weak such that the STC property is satisfied in
(ğ‘ˆ,ğ¸(ğ‘ˆ))andq(ğ‘ˆ,ğ¿;ğœ†)is maximized.
Note that when ğœ†=1then the labeling does not matter, and
stc-den reduces to dense subgraph discovery, that is, finding ğ‘ˆ
with the largest ratio |ğ¸(ğ‘ˆ)|/|ğ‘ˆ|. On the other hand, if ğœ†=0, then
we only take into account strong edges; we will show in Section 4
that in this case, stc-den is equal to finding a maximum clique.
Note also that the labeling depends on the underlying subgraph
ğ‘ˆ, that is, we need to find ğ‘ˆandğ¿simultaneously.
3 Related work
The strong triadic closure (STC) property: As an early work
in this line of research, Sintos and Tsaparas [24] considered the
problem of minimizing the number of weak edges (analogously
maximizing the number of strong edges) while labeling the edges
compliant with the STC property. We will refer to this optimization
problem as MinSTC.
Sintos and Tsaparas [24] showed that MinSTC is equivalent to
solving a minimum vertex cover, which we denote by Min-Vertex-
cover, in a wedge graph ğ‘(ğº). InMin-Vertex-cover, we search
for a minimum number of nodes such that at least one endpoint of
each edge is in the set.
Sintos and Tsaparas [24] proposed the following algorithm for
MinSTC, which we denote by Apr-MinSTC. Given a graph ğºthey
first construct the wedge graph ğ‘(ğº)and find its vertex cover. Next,
they label the set of edges of ğºthat corresponds to the set of vertices
in the vertex cover as weak, and the remaining edges as strong.
Since Min-Vertex-cover isNP-hard, they approximate it with a
maximal matching algorithm [ 6]. The algorithm picks an arbitrary
edge and adds both endpoints of the edge to the cover, and the
edges incident to both endpoints are deleted. It continues until no
edges are left. This algorithm outputs a maximal matching which
is known to yield a 2-approximation since at least one endpoint
should be in the cover.
The problem of finding a labeling of edges that maximizes the
number of strong edges while satisfying the STC property is NP-
hard for general graphs [ 24] and split graphs [ 15]. Nevertheless, it
becomes polynomial-time solvable for proper interval graphs [ 15],
cographs [ 14], and trivially perfect graphs [ 15]. Given communi-
ties, Rozenshtein et al . [21] considered the problem of inferring
strengths while minimizing STC violations with additional con-
nectivity constraints. Oettershagen et al . [17] extended the idea of
inferring tie strength for temporal networks. Matakos and Gionis
[16] considered the problem of strengthening edges to maximize
STC violations, which they consider as opportunities to build new
connections. Adriaens et al . [1] formulated both minimization and
maximization versions of STC problems as linear programs.
3335Dense Subgraph Discovery Meets Strong Triadic Closure KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
The dense subgraph discovery: Finding dense subgraphs is a
core problem in social network analysis. Given a graph, the densest
subgraph problem is defined as finding a subgraph with the high-
est average degree density (twice the number of edges divided by
the number of nodes). Finding the densest subgraph for a single
graph has been extensively studied [ 5,9,13]. Goldberg [9]pro-
posed an exact, polynomial time algorithm that solves a sequence
of min-cut instances. We will refer to this algorithm as Cut. Asahiro
et al. [3] provided a greedy algorithm and Charikar [5]proved that
their greedy algorithm gives a 1/2-approximation, showed how
to implement the algorithm using Fibonacci heaps, and devised a
linear-programming formulation of the problem. The idea of the
greedy algorithm is that at each iteration, a vertex with the mini-
mum degree is removed, and then the densest subgraph among all
the produced subgraphs is returned as the solution. We will refer to
this algorithm as Peel. It has also been extended for multiple graph
snapshots [ 2,11,23]. The problem has been studied in a streaming
setting [ 4]. To the best of our knowledge, this is the first attempt to
consider the notion of density together with the STC property.
In addition to degree density (a.k.a average degree), alternative
types of density measures have also been considered previously
such as triangle density and ğ‘˜-clique density [ 26]. Triangle density
is defined as the ratio between the number of triangles and the
number of vertices of the subgraph. The definition that will be used
in this paper is the ratio between the number of induced edges and
nodes. Adopting our problem to other density measures is left open
as future work.
4 Computational complexity
In this section, we analyze the computational complexity of the
stc-den problem by showing its NP-hardness when ğœ†<1and
its connection to the Max-Cliqe problem, when ğœ†=0. At the
other extreme, when ğœ†=1,stc-den is equivalent to the problem of
finding the densest subgraph, which can be solved in polynomial
time using the algorithm presented by Goldberg [9].
Proposition 4.1. Forğœ†=0,stc-den isNP-hard.
The proof (given in Appendix A.1) also shows that the maxi-
mum clique yields precisely the optimal score while satisfying the
STC property. As a consequence, combining this with the inapprox-
imability results for Max-Cliqe [28] gives the next result (see
Appendix A.1 for the proof).
Proposition 4.2. Forğœ†=0,stc-den does not have any poly-
nomial time approximation algorithm with an approximation ratio
better thanğ‘›1âˆ’ğœ–for any constant ğœ–>0, unless P=NP.
Note that when ğœ†>0, we can obtain a1
ğœ†-approximation by
finding the densest subgraph with nodes ğ‘ˆand using a labeling ğ¿
that labels each edge as weak. Compared to an optimal solution ğ‘ˆâˆ—
with labeling ğ¿âˆ—, we then obtain the score
ğ‘(ğ‘ˆ,ğ¿;ğœ†)=ğœ†|ğ¸(ğ‘ˆ)|
|ğ‘ˆ|â‰¥ğœ†|ğ¸(ğ‘ˆâˆ—)|
|ğ‘ˆâˆ—|=ğœ†ğ‘šğ‘ (ğ‘ˆâˆ—,ğ¿âˆ—)+ğ‘šğ‘¤(ğ‘ˆâˆ—,ğ¿âˆ—)
|ğ‘ˆâˆ—|
â‰¥ğœ†ğ‘šğ‘ (ğ‘ˆâˆ—,ğ¿âˆ—)+ğœ†ğ‘šğ‘¤(ğ‘ˆâˆ—,ğ¿âˆ—)
|ğ‘ˆâˆ—|=ğœ†ğ‘(ğ‘ˆâˆ—,ğ¿âˆ—;ğœ†).In summary, stc-den is inapproximable when ğœ†=0but solvable
in polynomial time when ğœ†=1. Finally, we state that stc-den is
alsoNP-hard for 0<ğœ†<1.
Proposition 4.3. stc-den isNP-hard for 0<ğœ†<1.
The proof of Proposition 4.3 is in Appendix A.1.
5 Algorithms
In this section, we present five algorithms to find a good subgraph
for our stc-den problem. First, we propose an algorithm based
on integer linear programming that finds a near-optimal or exact
solution for our problem in Section 5.1. Next, we state a polynomial
time algorithm that solves a linear program in Section 5.2 followed
by three heuristics presented in Sections 5.3 and 5.4.
5.1 Exact solution using integer programming
In this section, we present an integer linear programming (ILP)
based algorithm that can be used to find an exact solution for stc-
den. To solve stc-den we need the following auxiliary problem.
The proofs for this section are given in Appendix A.2.
Problem 2 ( stc-den(ğ›¼)).Given a graph ğº=(ğ‘‰,ğ¸), a weight
parameterğœ†, and a number ğ›¼, find a subset of vertices ğ‘ˆâŠ†ğ‘‰and
a labelingğ¿of the edges such that the STC property is satisfied in
(ğ‘ˆ,ğ¸(ğ‘ˆ))andğ‘šğ‘ (ğ‘ˆ,ğ¿)+ğœ†ğ‘šğ‘¤(ğ‘ˆ,ğ¿)âˆ’ğ›¼|ğ‘ˆ|is maximized.
The following proposition, which is an instance of fractional
programming [ 8], shows the relationship between stc-den(ğ›¼)and
stc-den.
Proposition 5.1. Letğ‘ˆ(ğ›¼)andğ¿(ğ›¼)be the subgraph and the
corresponding labeling solving stc-den(ğ›¼). Similarly, let ğ‘ˆâˆ—with
labelingğ¿âˆ—be the solution for stc-den. Write ğ›¼âˆ—=q(ğ‘ˆâˆ—,ğ¿âˆ—). Ifğ›¼>
ğ›¼âˆ—, thenğ‘ˆ(ğ›¼)=âˆ…. Ifğ›¼<ğ›¼âˆ—, thenğ‘ˆ(ğ›¼)â‰ âˆ…andq(ğ‘ˆ(ğ›¼),ğ¿(ğ›¼))>ğ›¼.
We can use the proposition to solve stc-den: we find the (almost)
largestğ›¼for which stc-den(ğ›¼)yields a nonempty solution. Then
stc-den(ğ›¼)for suchğ›¼yields an (almost) optimal solution.
We can solve stc-den(ğ›¼)with an integer linear program,
maximizeâˆ‘ï¸
ğ‘¥ğ‘–ğ‘—+ğœ†âˆ‘ï¸
ğ‘§ğ‘–ğ‘—âˆ’ğ›¼âˆ‘ï¸
ğ‘¦ğ‘– (1)
subject to ğ‘¥ğ‘–ğ‘—+ğ‘§ğ‘–ğ‘—â‰¤ğ‘¦ğ‘–ğ‘–ğ‘—âˆˆğ¸ (2)
ğ‘¥ğ‘–ğ‘—+ğ‘§ğ‘–ğ‘—â‰¤ğ‘¦ğ‘—ğ‘–ğ‘—âˆˆğ¸ (3)
ğ‘¥ğ‘–ğ‘—+ğ‘¥ğ‘—ğ‘˜â‰¤ğ‘¦ğ‘—(ğ‘–,ğ‘—,ğ‘˜)âˆˆğ‘ (4)
ğ‘¥ğ‘–ğ‘—,ğ‘§ğ‘–ğ‘—âˆˆ{0,1}ğ‘–ğ‘—âˆˆğ¸ (5)
ğ‘¦ğ‘–âˆˆ{0,1}ğ‘–âˆˆğ‘‰ . (6)
Here,ğº=(ğ‘‰,ğ¸)is the input graph and ğ‘is the set of all wedges
inğº.
To see why this program solves stc-den(ğ›¼), letğ‘†âŠ†ğ‘‰andğ¿
be a solution to our stc-den(ğ›¼). The indicator variable ğ‘¦ğ‘–denotes
whether the node ğ‘–âˆˆğ‘†or not. The indicator variables ğ‘¥ğ‘–ğ‘—andğ‘§ğ‘–ğ‘—
denote if the edge (ğ‘–,ğ‘—)is strong or not and (ğ‘–,ğ‘—)is weak or not,
respectively. Constraints 2-3 guarantee that each edge within ğ‘†is
labeled either as strong or weak. Constraint 4 ensures that the STC
constraint is satisfied.
Proposition 5.1 allows us to maximize ğ›¼with a binary search.
Here, we set the initial interval (ğ¿,ğ‘ˆ)toğ¿=0andğ‘ˆ=ğ‘›âˆ’1
2, and
3336KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
keep halving the interval until |ğ‘ˆâˆ’ğ¿|â‰¤ğœ–ğ¿, whereğœ–>0is an
input parameter, and return the solution to stc-den(ğ¿). We refer
to this algorithm as STC-ILP. Next, we state that STC-ILP yields an
approximation guarantee of 1/(1+ğœ–).
Proposition 5.2. Assume a graph ğº=(ğ‘‰,ğ¸),ğœ†âˆˆ[0,1], and
ğœ–>0. Letğ›¼be the score of the solution returned by STC-ILP and let
ğ›¼âˆ—be the optimal score of stc-den. Then ğ›¼â‰¥ğ›¼âˆ—/(1+ğœ–).
Next, we will show that if ğœ–is small enough, we are guaranteed
to find the exact solution.
Proposition 5.3. Assume a graph ğºwithğ‘›nodes. Assume that
the weight parameter ğœ†is a rational number ğœ†=ğ‘
ğ‘. Then, if we set
ğœ–=2
ğ‘ğ‘›3,STC-ILP returns an exact solution for the stc-den problem
inO(logğ‘›+logğ‘)number of iterations.
STC-ILP requiresO(logğ‘›âˆ’logğœ–)iterations, solving an integer
linear program in each round. Note that solving an ILP is NP-
hard [ 22], and the fastest known algorithm to solve an ILP exactly
runs in logâ„O(â„)time where â„is the number of variables [ 19].
In practice, we can solve stc-den(ğ›¼)for moderately sized graphs
but for larger graphs solving the ILP becomes computationally
infeasible.
This approach is related to two prior works. First, the algorithm
by Goldberg [9]for finding the densest subgraph problem uses a
similar approach, except without the variables ğ‘§ğ‘–ğ‘—. In such a case,
the program can be solved exactly with a minimum cut. Secondly,
Adriaens et al . [1] use a linear program with similar wedge con-
straints to approximate MinSTC.
5.2 Algorithm based on linear programming
In this section, we present an algorithm, named STC-LP, based on
a linear program obtained by relaxing the integrality requirements
of the integer linear program given in the previous section. More
specifically, we first find a fractional solution by solving a linear
program (LP) and then derive a good subgraph via a rounding algo-
rithm. Note that solving linear programs can be done in polynomial
time [ 12,27], and solvers are efficient in practice. The proofs for
this section are given in Appendix A.3.
Consider a relaxed version of the ILP, where we replace the
constraints in Eqs. 5â€“6 with ğ‘¥ğ‘–ğ‘—,ğ‘§ğ‘–ğ‘—âˆˆ[0,1]andğ‘¦ğ‘–âˆˆ[0,1]. We will
refer to this optimization problem as stc-relax(ğ›¼).
Note that we used stc-den(ğ›¼)combined with the binary search
to solve stc-den. We can define a relaxed version of stc-den which
then can be analogously solved with stc-relax(ğ›¼).
Problem 3 (stc-relax). Given a graph ğº=(ğ‘‰,ğ¸), a weight
parameterğœ†, find a nonnegative set of variables ğ‘¥ğ‘’,ğ‘¦ğ‘–,ğ‘§ğ‘’, where
ğ‘’âˆˆğ¸andğ‘–âˆˆğ‘‰maximizing
ğ‘Ÿ(ğ‘¥,ğ‘¦,ğ‘§)=Ãğ‘¥ğ‘’+ğœ†Ãğ‘§ğ‘’Ãğ‘¦ğ‘–such that Eqs. 2â€“4 hold .
stc-relax is a relaxed version of stc-den: if we were to re-
quire that the variables in stc-relax are binary numbers, then the
problems become equivalent. The next proposition is an analog to
Proposition 5.1.
Proposition 5.4. Let(ğ‘¥âˆ—,ğ‘¦âˆ—,ğ‘§âˆ—)be a solution to stc-relax. Write
ğ›¼âˆ—=ğ‘Ÿ(ğ‘¥âˆ—,ğ‘¦âˆ—,ğ‘§âˆ—). Similarly, let(ğ‘¥(ğ›¼),ğ‘¦(ğ›¼),ğ‘§(ğ›¼))be a solutionstc-relax(ğ›¼). Ifğ›¼>ğ›¼âˆ—, thenÃğ‘¦ğ‘–(ğ›¼)=0. On the other hand,
ifğ›¼<ğ›¼âˆ—, thenÃğ‘¦ğ‘–(ğ›¼)>0andğ‘Ÿ(ğ‘¥(ğ›¼),ğ‘¦(ğ›¼),ğ‘§(ğ›¼))>ğ›¼.
Proposition 5.4 allows us to solve stc-relax with stc-relax(ğ›¼)
and a binary search, similar to STC-ILP. However, we can solve
stc-relax directly with a single linear program, that is,
maximizeâˆ‘ï¸
ğ‘¥ğ‘–ğ‘—+ğœ†âˆ‘ï¸
ğ‘§ğ‘–ğ‘—
subject to ğ‘¥ğ‘–ğ‘—+ğ‘§ğ‘–ğ‘—â‰¤ğ‘¦ğ‘–ğ‘–ğ‘—âˆˆğ¸
ğ‘¥ğ‘–ğ‘—+ğ‘§ğ‘–ğ‘—â‰¤ğ‘¦ğ‘—ğ‘–ğ‘—âˆˆğ¸
âˆ‘ï¸
ğ‘¦ğ‘–=1
ğ‘¥ğ‘–ğ‘—+ğ‘¥ğ‘—ğ‘˜â‰¤ğ‘¦ğ‘—(ğ‘–,ğ‘—,ğ‘˜)âˆˆğ‘
ğ‘¥ğ‘–ğ‘—,ğ‘§ğ‘–ğ‘—â‰¥0 ğ‘–ğ‘—âˆˆğ¸
ğ‘¦ğ‘–â‰¥0 ğ‘–âˆˆğ‘‰
Proposition 5.5. The LP given above solves stc-relax.
Our LP is related to the LP proposed by Charikar [5], which is
used to solve the densest subgraph problem exactly. We extend
Charikarâ€™s LP by adding strong edges and additional STC con-
straints. Another related work is the LP proposed by Adriaens et al .
[1]which provides a 2-approximation for MinSTC using similar
wedge constraints.
Rounding phase: Next, we describe the heuristic used to obtain
the subgraph and the labeling from the variables. Let ( ğ‘¥âˆ—,ğ‘¦âˆ—,ğ‘§âˆ—)
be the solution to stc-relax. First we define a collection of sets
S={ğ‘†1,ğ‘†2,...,ğ‘†ğ‘›}whereğ‘†ğ‘—={ğ‘–:ğ‘¦âˆ—
ğ‘–â‰¥ğ‘¦âˆ—
ğ‘—}. Then we enumerate
over the collection of subgraphs induced by S.
For eachğ‘†ğ‘—, we initially set all the edges as weak. Then we
enumerate over each edge ğ‘’âˆˆğ¸(ğ‘†ğ‘—)starting from the largest ğ‘§âˆ—ğ‘’.
Each edgeğ‘’is labeled as strong if the STC property is not violated.
This means that we check if there is any edge adjacent to any
of the endpoints of ğ‘’which is already labeled as strong and still
creates a wedge with ğ‘’. We continue the same process for all the
edgesğ‘’âˆˆğ¸(ğ‘†ğ‘—)in the descending order of its ğ‘§âˆ—ğ‘’value. Finally, out
of all the subgraphs we pick the subgraph and the labeling that
maximizes our score.
Constructing a labeling for a single ğ‘†ğ‘—amounts to enumerating
over the wedges in O(ğ‘›ğ‘š)time, leading to a total time of O ğ‘›2ğ‘š
for the rounding.
5.3 Label, find the densest subgraph, and relabel
Next, we explain two algorithms that combine the existing methods
for finding the densest subgraph and finding the STC-compliant
labeling in an entire graph.
The approach is as follows. First, we label the edges of the entire
graph using Apr-MinSTC (see Section 3). Then we construct a
weighted version of the graph assigning a weight of 1for strong
edges and a weight of ğœ†for weak edges. Next, we search for the
densest subgraph using Cut orPeel (see Section 3) in the new
weighted graph. Finally, we relabel only the subgraph induced by
the returned solution. Relabeling is used to improve the score since
some of the edges might be marked as weak since they contributed
to certain wedges in the original graph, nevertheless, some edges no
longer contribute to all of those wedges. The pseudo-code for this
3337Dense Subgraph Discovery Meets Strong Triadic Closure KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Algorithm 1: STC-Cut(ğº,ğœ†)and STC-Peel(ğº,ğœ†), both
find a subgraph ğ‘ˆand a labeling ğ¿with good q(ğ‘ˆ,ğ¿;ğœ†).
1ğ¿â†Apr-MinSTC(ğº);
2ğ»â†the weighted graph by setting 1to strong edges and ğœ†
to weak edges of ğº;
3ğ‘ˆâ†Cut(ğ»)[9] or Peel(ğ»)[5];
4ğ¿â€²â†Apr-MinSTC(ğº(ğ‘ˆ));
5return subgraphğ‘ˆand its labeling ğ¿â€²;
method is given in Algorithm 1. We call the algorithm as STC-Cut
orSTC-Peel based on the subroutine used in Line 3 of Algorithm 1.
Next, we present the computational complexities of the STC-Peel
andSTC-Cut algorithms.
Proposition 5.6. Assume a graph ğºwithğ‘›nodes andğ‘šedges.
Assume that the wedge graph ğ‘(ğº)containsğ‘›â€²nodes andğ‘šâ€²edges.
Then the running time of STC-Peel is in
O âˆ‘ï¸
ğ‘£âˆˆğ‘‰deg(ğ‘£)2+(ğ‘š+ğ‘›logğ‘›)+(ğ‘šâ€²+ğ‘›â€²)!
âŠ†O(ğ‘›ğ‘š).
Proof. The number of wedges in ğº, and hence the number
of edges in ğ‘(ğº)is inO Ã
ğ‘£âˆˆğ‘‰deg(ğ‘£)2âŠ†O(ğ‘›Ã
ğ‘£âˆˆğ‘‰deg(ğ‘£))âŠ†
O(ğ‘›ğ‘š). The number of vertices, ğ‘›â€², in the wedge graph ğ‘(ğº)is in
O(ğ‘š).Apr-MinSTC estimates the minimum vertex cover problem
with a maximum matching for ğ‘(ğº)and the subgraph, which has a
running time ofO(ğ‘›â€²+ğ‘šâ€²)when the adjacency list representation
is used for the graph [ 7]. We can execute Peel inO(ğ‘š+ğ‘›logğ‘›)
time. The claim follows. â–¡
Proposition 5.7. Assume a graph ğºwithğ‘›nodes andğ‘šedges.
Assume that the wedge graph ğ‘(ğº)containsğ‘›â€²nodes andğ‘šâ€²edges.
Then the running time of STC-Cut is in
O ğ‘šğ‘›+ğ‘›(ğ‘›+ğ‘š)logğ‘›+(ğ‘šâ€²+ğ‘›â€²)âŠ†O(ğ‘šğ‘›logğ‘›).
Proof. The only change compared to Proposition 5.6 is that we
are using an exact algorithm instead of an approximation algorithm
for finding the densest subgraph. The exact algorithm for an edge-
weighted graph takes O(ğ‘€(ğ‘›,ğ‘›+ğ‘š)logğ‘›)time, andğ‘€(ğ‘›,ğ‘›+ğ‘š)
is the time taken to solve the min-cut problem for a graph with ğ‘›
number of nodes and (ğ‘›+ğ‘š)number of edges. It takes O(ğ‘›(ğ‘›+ğ‘š))
to find the minimum cut [18]. The claim follows. â–¡
5.4 Peeling with continuous relabeling
TheSTC-Peel algorithm, given in the previous section, first finds
a labeling and then uses Peel that constructs a set of subgraphs
among which the subgraph with the highest score is selected. Dur-
ing this search, the labeling remains fixed. Our final algorithm
modifies this approach by relabeling the graph as we are construct-
ing the subgraphs.
Our approach is as follows. We start from the whole graph ğº
and label the edges as either strong or weak using Apr-MinSTC.
Given a labeling ğ¿and a subgraph ğ‘ˆ, let the weighted degree for
a vertex degğœ†(ğ‘£,ğ‘ˆ,ğ¿,ğœ†)be defined as the sum of strong edges and
weak edges in ğ‘ˆincident toğ‘£weighted by ğœ†, i.e., degğœ†(ğ‘£,ğ‘ˆ,ğ¿)=Algorithm 2: Grd-Naive(ğº,ğœ†), finds a subgraph ğ‘ˆand a
labelingğ¿with good q(ğ‘ˆ,ğ¿;ğœ†)
1ğ‘ˆâ†ğ‘‰;
2while there are nodes do
3ğ¿â†Apr-MinSTC(ğº(ğ‘ˆ));
4ğ‘¢â†arg min
ğ‘£âˆˆğ‘ˆdegğœ†(ğ‘£,ğ‘ˆ,ğ¿,ğœ†);
5ğ‘ˆâ†ğ‘ˆ\{ğ‘¢};
6return best testedğ‘ˆand its labeling ğ¿;
degğ‘ (ğ‘£,ğ‘ˆ,ğ¿)+ğœ†degğ‘¤(ğ‘£,ğ‘ˆ,ğ¿)We dropğ¿,ğ‘ˆorğœ†when it is clear
from the context. At each iteration, we delete the node that has the
minimum weighted degree degğœ†(ğ‘£). After removing each vertex we
relabel the remaining set of edges. Finally, we choose the subgraph
ğ‘ˆwhich corresponds to the maximum score q(ğ‘ˆ,ğœ†)out of all the
iterations. The naive version for this method is given in Algorithm 2.
Next, we explain several tricks to speed up the naive implemen-
tation of Algorithm 2. We focus on updating the wedge graph, mod-
ifying the minimum vertex cover, and updating individual scores
of each vertex without computing them from scratch.
Maintain wedge graph: Note that on Line 3 of Algorithm 2, we
need to repeatedly construct a wedge graph to solve MinSTC. We
can avoid this by maintaining the existing wedge graph as vertices
are deleted.
When a node is deleted we need to consider only deleting re-
spective edges in the wedge graph since new wedges cannot be
introduced. Note that an edge in the original graph ğºcorresponds
to a node in the wedge graph ğ‘(ğº)and edges in ğ‘(ğº)represent
wedges inğº. Next, we state how to maintain ğ‘(ğº)when a vertex
is deleted in Proposition 5.8.
Proposition 5.8. Letğº=(ğ‘‰,ğ¸)be a graph. Let ğ‘£be a vertex
inğº. Defineğºâ€²=ğº(ğ‘‰\{ğ‘£},ğ¸\ğ‘(ğ‘£)), whereğ‘(ğ‘£)is the set of
adjacent edges of vertex ğ‘£inğº. Then, a new wedge graph ğ‘(ğºâ€²)is
formed by deleting the vertices in ğ‘(ğº)corresponding to ğ‘(ğ‘£).
We omit the straightforward proof.
Dynamic vertex cover using maximal matching: Next, we
consider updating the vertex cover after a vertex deletion.
Recall that we use maximum matching to approximate the vertex
cover in Apr-MinSTC. Given a maximal matching of the current
graph, IvkoviÄ‡ and Lloyd [10]presented a simple algorithm to main-
tain the cover when an edge is deleted or inserted. Here we modify
their algorithm slightly to adapt to a node deletion from ğº. Let us
consider the case where the vertex ğ‘£is deleted from the original
graphğº. Note thatğ‘(ğ‘£)is a set of edges in ğºwhich corresponds
to a subset of nodes in ğ‘(ğº). According to Proposition 5.8, the set
of nodes corresponding to ğ‘(ğ‘£)should be deleted from the wedge
graphğ‘(ğº)to compensate for the deleted vertex. We assume that
a maximal matching ğ‘€ofğ‘(ğº)is given.
The algorithm is as follows. We iterate over the elements in ğ‘(ğ‘£)
and pick a node ğ‘âˆˆğ‘(ğ‘£)inğ‘(ğº). We then test whether there is
an edge(ğ‘,ğ‘)inğ‘€for someğ‘. There can be only one, and if there
is, we delete it. Upon such deletion, ğ‘€may no longer be maximal
sinceğ‘may have a single adjacent edge that can be added. We
search for such an edge and add it if one is found.
3338KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
Algorithm 3: Dynamic-Vertex-cover (ğ‘€,ğ‘£), maintains
a vertex cover (a maximal matching ğ‘€) when a node ğ‘£is
deleted
1foreachğ‘âˆˆğ‘(ğ‘£)do
2 ifthere isğ‘such that(ğ‘,ğ‘)âˆˆğ‘€then
3 delete(ğ‘,ğ‘)fromğ‘€;
4 ifğ‘âˆ‰ğ‘(ğ‘£)and there isğ‘¡âˆ‰ğ‘(ğ‘£)such thatğ‘¡is not
an endpoint of any edge in ğ‘€and(ğ‘,ğ‘¡)âˆˆğ¸(ğ‘(ğº))
then
5 add(ğ‘,ğ‘¡)toğ‘€;
6returnğ‘€;
The pseudocode is given in Algorithm 3. Algorithm 3 still pro-
duces a maximal matching; thus a 2-approximation for Min-Vertex-
cover is guaranteed.
Speeding the vertex selection: We can speed up finding the
next vertex by maintaining degğœ†(ğ‘£,ğœ†)in a priority queue. Once a
vertex is deleted, we need to update the degree of its neighboring
nodes. Also, we may need to update the weighted degree of the
affected vertices if the vertex cover of ğ‘(ğº)changes. However, the
number of changed edges in the vertex cover is constant. The final
version of the algorithm is presented in Algorithm 4.
Algorithm 4: Greedy(ğº,ğœ†), finds a subgraph ğ‘ˆand a la-
belingğ¿with good q(ğ‘ˆ,ğ¿;ğœ†)
1ğ¿â†Apr-MinSTC(ğº);
2ğ‘ƒâ†priority queue where each node is ranked by
degğœ†(ğ‘£,ğ¿);
3ğ‘ˆâ†ğ‘‰;
4while there are nodes do
5ğ‘¢â†arg min
ğ‘£âˆˆğ‘ˆdegğœ†(ğ‘£,ğ‘ˆ,ğ¿);
6ğ‘ˆâ†ğ‘ˆ\{ğ‘¢};
7 Update the wedge graph ğ‘((ğ‘ˆ,ğ¸(ğ‘ˆ)));
8 Update labeling ğ¿using Algorithm 3;
9 Updateğ‘ƒ;
10return best testedğ‘ˆand its labeling ğ¿;
Next, we state the computational complexity of Greedy.
Proposition 5.9. Assume a graph ğºwithğ‘›nodes andğ‘šedges.
Assume that the wedge graph ğ‘(ğº)containsğ‘›â€²nodes andğ‘šâ€²edges.
Then the running time of Greedy is in
O ğ‘šğ‘›+(ğ‘›â€²+ğ‘šâ€²)+ğ‘šlogğ‘›+ğ‘›ğ‘šâŠ†O(ğ‘›ğ‘š).
Proof. Letğºğ‘–be the graph at ğ‘–th iteration. Consider deleting
vertexğ‘¢fromğºğ‘–. Upon deletion, we need to update the priorities
of the affected nodes in the queue.
Whenğ‘¢is deleted from ğºğ‘–, we need to delete the set of nodes
inğ‘(ğº)which corresponds to the adjacent edges of ğ‘¢. For each
deleted vertex in ğ‘(ğº), there can be at most one adjacent edge that
belongs to the existing matching set. Therefore, to compensate forthe edge that is removed from the maximal matching set, we need
to add at most one edge to the matching. The two endpoints of the
newly added edge correspond to two edges in ğºğ‘–+1. Therefore, the
total number of vertices that require updating priorities is at most
4. Moreover, deleting one edge from the existing matching set will
affect the priorities of at most 2vertices.
In summary,O(degğ‘¢)nodes need to be updated when we delete
ğ‘¢. Consequently, the total update time of ğ‘ƒis inO(ğ‘šlogğ‘›). More-
over, the total update time for ğ‘(ğº)is inO(ğ‘›â€²+ğ‘šâ€²). Updating
ğ‘€requires finding a new edge which may cost O(ğ‘›)time, conse-
quently, updating ğ‘€requiresO(ğ‘›ğ‘š)total time. Finally, the update
time for(ğ‘ˆ,ğ¸(ğ‘ˆ))is inO(ğ‘š).
Initially, constructing ğ‘(ğº)requiresO Ã
ğ‘£âˆˆğ‘‰deg(ğ‘£)2âŠ†O(ğ‘›ğ‘š)
time and VC-Mat requiresO(ğ‘›â€²+ğ‘šâ€²)âŠ†O(ğ‘›ğ‘š)time.
Combining these times proves the claim. â–¡
6 Experimental evaluation
Next, we evaluate our algorithms experimentally. We first generate
a synthetic dataset with a dense subgraph component and test
how well our algorithms perform. Next, we study the performance
of the algorithms on real-world networks. We implemented the
algorithms in Python1and performed the experiments using a
2.4GHz Intel Core i5 processor and 16GB RAM. In our experimental
evaluation, we used Gurobi solver in Python to solve the ILPs and
LPs associated with STC-ILP andSTC-LP respectively.
Synthetic dataset: We will now explain how the synthetic
dataset was generated. Given a vertex set ğ‘‰of size 230, we split ğ‘‰
into dense and sparse components ğ·andğ‘†. Here, we randomly se-
lectedğ·to have 38 nodes and ğ‘†to have 192 nodes. We sampled the
edges using a stochastic block model, with the edge probabilities
beingğ‘ğ‘‘=1,ğ‘ğ‘ =0.3, andğ‘ğ‘=0.05for dense component, sparse
component, and cross edges, respectively. The resulting graph had
5 197 edges, and the wedge graph had 5 197 nodes and 179 100 edges.
The density of ğ·was|ğ¸(ğ·)|/|ğ·|=18.5.
Results using synthetic dataset: We report our results in
Table 1. First, we see that all our algorithms find the ground truth
by achieving a score of 18.5which is the density of our planted
clique of size 38for example when ğœ†=0.4andğœ†=0.2. Note that
STC-ILP produced the results within an hour only for the ğœ†=0.2
case. Since STC-ILP solves an ILP in each round, it was inefficient
to run for the other ğœ†values and we stopped the execution after
one hour.
Asğœ†increases, our algorithms tend to find a score greater than
18.5by deviating away from the planted clique. We also see that
STC-LP which solves a linear program runs significantly slower
than Greedy, STC-Peel, and STC-Cut algorithms.
Next, we study how the scores and the percentage of weak edges
vary as a function of ğœ†as shown in Figure 2. We can observe that
both STC-Cut andSTC-Peel produce equal scores whereas STC-
Peel andSTC-LP slightly underperform at ğœ†=0.6andğœ†=0.5
respectively as shown in Fig. 2a. Moreover, the STC-LP slightly out-
performs other algorithms when ğœ†â‰¥0.7. In terms of percentages
of weak edges, all three algorithms produced the same decreasing
trends according to Fig. 2b. There are no weak edges in the sub-
graphs produced by any of the algorithms when ğœ†â‰¤0.4since scores
1The source code is available at https://version.helsinki.fi/dacs/.
3339Dense Subgraph Discovery Meets Strong Triadic Closure KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Table 1: Results of the experiments for synthetic and real datasets. Here, ğœ†is the weight parameter, columns CT,PL,GR,LP,
andIPrepresent STC-Cut, STC-Peel, Greedy, STC-LP, and STC-ILP, respectively, columns in qare the discovered scores,
columns in|ğ¸ğ‘ |%give the percentages of strong edges in discovered subgraph, and columns in time give the computational time.
q |ğ¸ğ‘ |% time
Dataset ğœ† CT PL GR LP IP CT PL GR LP IP CT PL GR LP IP
Synthetic 0.8 21.28 21.28 21.27 21.68 9 .45 15.96 9.43 17.2 11 .72s 6.69s 6.94s 29.58s
0.6 16.57 16.57 18.5 17.37 9 .45 15.86 100 17 .07 11 .29s 6.4s 7.11s 36.9s
0.4 18.5 18.5 18.5 18.5 100 100 100 100 9s 4.73s 7.85s 16.97s
0.2 18.5 18.5 18.5 18.5 18.5 100 100 100 100 100 7 .02s 7.02s 7.98s 12.92s 9m5s
Cora 0.8 2.58 2.33 2.3 2.65 2.69 32.51 10.03 5.16 22.16 28.57 18.14s 1.1s 1m1s 2.41s 43.26s
0.6 1.99 1.84 2.01 2.14 2.29 74.15 7.35 81.82 21.57 37.5 17.51s 0.92s 1m1s 2.8s 11m1s
0.4 2 1 .78 2 1 .62 2.09 100 100 100 39 .13 69.57 14.68s 0.94s 46.73s 2.98s 4m23s
0.2 2 1 .78 2 1 .32 2.02 100 100 100 66 .67 95.24 15.48s 0.88s 42.34s 2.79s 4m17s
Citeseer 0.8 4 3 .99 3.87 4.12 4.2 6.54 17.95 8.89 19.44 27.78 13.17s 0.51s 1m25s 1.27s 18.32s
0.6 3.11 3.08 2.99 3.35 3.5 6.93 18.64 5.45 20.37 28.16 15.44s 0.52s 1m18s 1.28s 17.54s
0.4 2.22 2.16 2.5 2.65 2.82 16.07 24.49 100 23 .3 32.94 14.55s 0.56s 56.86s 1.3s 38.62s
0.2 1.5 1.5 2.5 1.89 2.5 100 100 100 35 .29 100 15 .05s 0.68s 50.06s 1.29s 1m6s
PGP 0.8 15.96 15.59 15.4 16.48 16.86 18.41 15.24 15.68 32.05 42.19 1m33s 5.95s 31m49s 22.39s 6m55s
0.6 12.51 12.07 12 13 .97 14.66 17.75 24.68 100 33 .22 42.19 1m38s 6.67s 31m52s 20.52s 8m40s
0.4 10.5 10.5 11 11 .44 12.56 100 100 100 34 .94 48.19 1m38s 6.42s 31m4s 20.33s 9m24s
0.2 10.5 10.5 11 10 .46 12 100 100 100 67 .29 100 1m40s 6.28s 24m20s 27.82s 9m3s
Email-EU 0.8 22.17 22.17 22.12 22.44 2 .14 2.17 1.22 7.09 52 .5s 22.21s 2m29s 3m37s
0.6 16.78 16.76 16.68 17.3 2 .14 2.09 1.26 6.88 54 .26s 21.13s 2m33s 4m26s
0.4 11.4 11.38 11.24 12.2 2 .35 2.28 1.44 7.12 55s 21.76s 2m25s 5m16s
0.2 6.02 5.97 8 7 .16 3 .06 2.88 100 7 .52 57 .63s 23.54s 2m21s 4m57s
Facebook 0.8 62.26 63.33 62.02 61.48 5 .71 6.19 4.16 12.68 1m22s 37.31s 5m29s 7m27s
0.6 47.79 47.94 47.31 49.84 5 .71 6.19 4.16 12.49 1m23s 36.05s 5m39s 6m34s
0.4 33.54 33.38 33.5 36.3 6 .26 5.92 100 12 .75 1m21s 35.21s 5m32s 9m30s
0.2 19.27 19.36 33 23 .18 6 .76 6.92 100 13 .46 1m22s 34.21s 5m22s 9m27s
LastFM 0.8 11.97 12 11 .94 12.28 4 .72 5.58 3.77 15.19 1m33s 11.99s 24m54s 1m1s
0.6 9.16 9.19 8.98 9.67 4 .72 5.34 5.29 13.53 1m33s 12.09s 24m45s 58.42s
0.4 6.47 6.43 6.5 7.09 6 .21 5.76 100 14 .3 1m32s 11.38s 23m10s 1m3s
0.2 3.46 3.52 6.5 4.71 4 .38 4.83 100 15 .98 1m32s 11.8s 17m28s 1m1s
Table 2: Characteristics of real-world datasets. Here, |ğ‘‰|and
|ğ¸|give the number of vertices and edges, |ğ‘‰(ğ‘)|and|ğ¸(ğ‘)|
are the number of vertices and edges in the wedge graph,
ğ‘‘=|ğ¸(ğ‘ˆ)|/|ğ‘ˆ|gives the density of the densest subgraph, and
ğ‘‘ğ‘is the density induced by Max-Cliqe.
Dataset|ğ‘‰| |ğ¸| |ğ‘‰(ğ‘)| |ğ¸(ğ‘))|ğ‘‘ ğ‘‘ğ‘
Cora 2 708 5 278 5 151 47 411 3 .14 2
Citeseer 3 264 4 536 4 192 23 380 4 .91 2.5
PGP 10 680 24 316 23 568 270 433 19 .07 12
Email-EU 986 16 064 16 063 866 833 27 .57 8.5
Facebook 747 30 025 30 022 1 177 951 76 .73 33.5
LastFM 7 624 27 806 27 775 557 781 14 .79 7
are only contributed by the planted clique. Recall the connection
to the maximum clique problem for ğœ†=0from Proposition 4.1.
Finally, we study the running time as a function of the number
of edges|ğ¸|and the number of wedges |ğ‘‰(ğ‘)|in Figure 3. We00.20.40.60.81203040
ğœ†q(Â·;ğœ†)Greedy
STC-Cut
STC-Peel
STC-LP
(
a)00.20.40.60.81020406080100
ğœ†|ğ¸ğ‘ |%
(
b)
Figure 2: Scores and percentages of strong edges as a function
ofğœ†forSynthetic dataset.
randomly generated 6datasets each with 5 000 nodes. The number
of edges of the datasets uniformly ranges from 1Ã—104to1.1Ã—105.
We see that STC-Cut andSTC-Peel are the fastest while STC-LP
is the slowest.
3340KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
0.20.40.60.81
Â·10501
0002 0003
0004 000
|ğ¸|timeGreedy
STC-Cut
STC-Peel
STC-LP
(
a)2 4
Â·10601 0002 0003
0004 000
|ğ‘‰(ğ‘)|time
(
b)
Figure 3: Time in seconds as a function of the number of
edges|ğ¸|and the number of wedges |ğ‘‰(ğ‘)|.
Real-world datasets: We test our algorithms in publicly avail-
able, real-world datasets: Cora [20]2and Cite-seer [20]2datasets
are citation networks. Email-EU is a collaboration network be-
tween researchers.3Facebook is extracted from a friendship circle of
Facebook.4LastFM is a social network of LastFM users.4PGP is an
interaction network of the users of the Pretty Good Privacy (PGP)
algorithm.5The details of the datasets are shown in Table 2.
Results using real-world datasets: We present the results ob-
tained using our algorithms in Table 1. We compare our algorithms
in terms of scores, running time, and the percentage of the strong
edges within subgraphs they returned for a set of ğœ†values. Since
STC-ILP invokes a sequence of integer programs, the algorithm
does not scale for large datasets. We stopped the experiments that
took over one hour. We always set ğœ–=0.01when testing each
dataset with STC-ILP.
First, let us compare the scores across the algorithms. Our first
observation is that STC-ILP always yields the highest score with
the tested datasets while all other algorithms perform similarly in
terms of scores: in most cases, they produce approximately equal
scores. When STC-ILP is not usable, STC-LP has produced the max-
imum score except for 3outlier cases where Greedy andSTC-Peel
algorithms obtained the maximum score 2times and 1time respec-
tively. Nevertheless, for high ğœ†s all of them produce less deviated
scores when compared to lower ğœ†s. As expected, qincreases as ğœ†
increases for all 4algorithms.
Next, let us look at column |ğ¸ğ‘ |%which gives the percentages of
strong edges in the returned subgraph. Generally speaking, |ğ¸ğ‘ |%
monotonically decreases as ğœ†increases except for a few outlier
cases. This is because when we assign a higher weight ğœ†, it becomes
more beneficial to include more weak edges.
Computation times are given in the ğ‘¡ğ‘–ğ‘šğ‘’ columns of Table 1.
Greedy, STC-LP, and STC-Cut run significantly slower than STC-
Peel. If we compare Greedy andSTC-Cut, for all the tested cases
STC-Cut runs faster despite having to solve a sequence of minimum
cuts. This is due to the implementation differences as STC-Cut uses
a fast native library to compute the minimum cuts.
Despite STC-ILP not being scalable for larger datasets, it runs
faster than Greedy except for four cases with the tested datasets.
ForCora, Citeseer, PGP, and LastFM datasets, STC-LP runs faster
2https://networkrepository.com
3https://toreopsahl.com/datasets/
4http://snap.stanford.edu
5http://konect.cc/networks/arenas-pgp/than all other algorithms except STC-Peel. However, for the two
other remaining datasets, STC-LP is the slowest in comparison to
the other three algorithms. We see that the running times are still
reasonable in practice for the tested datasets; for example, we were
able to compute the subgraph for the Facebook dataset, with over
30 000 edges and 1 000 000 wedges, in under ten minutes.
Table 3: Co-authorship case-study for DBLP dataset with
weighted variant of STC-ILP. We set ğœ†=0.8andğœ–=0.01. For
each subgraph, we state the scores within brackets.
S1 P. S.Yu, C. C.Aggarwal, J.Han, W.Fan, J.Gao, X.Kong (6.00)
S2 C. H. Q.Ding, F.Nie, H.Huang, D.Luo (4.78)
S3 S.Yan, J.Yan, N.Liu, Z.Chen, H.Xiong, Q.Yang, Y.Fu, Y.Ge,
H.Zhu, E.Chen, C.Liu, Q.Liu, B.Zhang (4.70)
S4 S.Lin, H.Hsieh, C.Li (4.23)
S5 C.Faloutsos, J.Sun, S.Papadimitriou, H.Tong, L.Akoglu,
T.Eliassi-Rad, B.Gallagher (4.09)
S6 Y.Liu, M.Zhang, S.Ma, L.Ru (3.84)
S7 H.Liu, J.Tang, X.Hu, H.Gao (3.80)
S8 D.Phung, S.Venkatesh, S. KumarGupta, S.Rana, S.Tsumoto,
S.Hirano (3.76)
S9 C.BÃ¶hm, I. S.Dhillon, C.Plant, C.Hsieh, P.Ravikumar (3.54)
S10 S.GÃ¼nnemann, H.Kremer, T.Seidl, I.Assent, E.MÃ¼ller,
R.Krieger (3.46)
Case study: Next, we conducted a case study for DBLP [25]6
which contains co-authorship connections from top venues in data
mining and machine learning (SDM, NIPS, ICDM, KDD, ECMLP-
KDD, and WWW). Each node represents an author and each edge
corresponds to a collaboration between two authors. We removed
the author pairs who have less than 3collaborations. The size
of the dataset after prepossessing is ğ‘›=4 592,ğ‘š=5 566, and
|ğ‘(ğº)|=26 073. To compute a marginal weight that corresponds to
an author pair, we assign a weight for each paper as one divided by
the number of authors. We then weigh each edge (author-pair) by
summing up the weights of all respective collaborations. Then we
ran a weighted version of STC-ILP whose objective is to maximize
the edge-weighted score,Ã
strongğ‘’âˆˆğ¸(ğ‘ˆ)ğ‘¤(ğ‘’)+ğœ†Ã
weakğ‘’âˆˆğ¸(ğ‘ˆ)ğ‘¤(ğ‘’)
|ğ‘ˆ|.
We found top-10 non-overlapping subgraphs iteratively by deleting
the returned subgraph in each iteration and then considering the
remaining graph to find the next subgraph. We set ğœ†=0.8and
ğœ–=0.01. The list of author subgraphs is shown in Table 3. We
see that the variant of STC-ILP discovered subgraphs of prolific
authors.
7 Concluding remarks
We introduced a novel dense subgraph discovery problem that
takes into account the strength of ties within the subgraph. Here
we label each edge either as strong or weak based on the strong
triadic closure principle (STC). The STC property requires that
if one node strongly connects with two other nodes, then those
6https://www.aminer.org/citation
3341Dense Subgraph Discovery Meets Strong Triadic Closure KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
two nodes should at least have a weak connection between them.
Our goal was to maximize a density-like measure defined as the
sum of the number of strong edges and the number of weak edges
weighted by a weight parameter, divided by the number of nodes
within the subgraph. We showed that our optimization problem is
NP-hard, and connects the two well-known problems of finding
dense subgraphs and maximum cliques. To solve the problem, we
presented an exact algorithm based on integer linear programming.
In addition, we presented a polynomial-time algorithm based on
linear programming, a greedy heuristic algorithm, and two other
straightforward algorithms based on the algorithms for the densest
subgraph discovery.
The experiments with synthetic data showed that our approach
recovers the latent dense components. The experiments on real-
world networks confirmed that our proposed algorithms discovered
the subgraphs reasonably fast in practice. Finally, we presented a
case study where our algorithm produced interpretable results
suggesting the practical usefulness of our problem setting and
algorithms.
The idea of combining the dense subgraph problem with the
STC property opens up several lines of work. For example, instead
of using the ratio between the number of edges and the number
of nodes as the density measure, we can incorporate other density
measures.
Acknowledgments
This research is supported by the Academy of Finland project MAL-
SOME (343045).
References
[1]Florian Adriaens, Tijl De Bie, Aristides Gionis, Jefrey Lijffijt, Antonis Matakos,
and Polina Rozenshtein. 2020. Relaxing the strong triadic closure problem for edge
strength inference. Data Mining and Knowledge Discovery 34 (2020), 611â€“651.
[2]Chamalee Wickrama Arachchi and Nikolaj Tatti. 2023. Jaccard-constrained dense
subgraph discovery. arXiv preprint arXiv:2308.15936 (2023).
[3]Yuichi Asahiro, Kazuo Iwama, Hisao Tamaki, and Takeshi Tokuyama. 2000. Greed-
ily finding a dense subgraph. Journal of Algorithms 34, 2 (2000), 203â€“221.
[4]Sayan Bhattacharya, Monika Henzinger, Danupon Nanongkai, and Charalampos
Tsourakakis. 2015. Space-and time-efficient algorithm for maintaining dense
subgraphs on one-pass dynamic streams. In Proceedings of the forty-seventh
annual ACM symposium on Theory of computing. 173â€“182.
[5]Moses Charikar. 2000. Greedy approximation algorithms for finding dense
components in a graph. In APPROX. 84â€“95.
[6]Kenneth L Clarkson. 1983. A modification of the greedy algorithm for vertex
cover. Inform. Process. Lett. 16, 1 (1983), 23â€“25.
[7]Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, and Clifford Stein. 2022.
Introduction to algorithms. MIT press.
[8]Werner Dinkelbach. 1967. On nonlinear fractional programming. Management
science 13, 7 (1967), 492â€“498.
[9] Andrew V Goldberg. 1984. Finding a maximum density subgraph. (1984).
[10] Zoran IvkoviÄ‡ and Errol L Lloyd. 1993. Fully dynamic maintenance of vertex
cover. In International Workshop on Graph-Theoretic Concepts in Computer Science.
Springer, 99â€“111.
[11] Vinay Jethava and Niko Beerenwinkel. 2015. Finding dense subgraphs in rela-
tional graphs. In Joint European Conference on Machine Learning and Knowledge
Discovery in Databases. 641â€“654.
[12] Narendra Karmarkar. 1984. A new polynomial-time algorithm for linear pro-
gramming. In Proceedings of the sixteenth annual ACM symposium on Theory of
computing. 302â€“311.
[13] Samir Khuller and Barna Saha. 2009. On finding dense subgraphs. In International
colloquium on automata, languages, and programming. Springer, 597â€“608.
[14] Athanasios L Konstantinidis, Stavros D Nikolopoulos, and Charis Papadopoulos.
2018. Strong triadic closure in cographs and graphs of low maximum degree.
Theoretical Computer Science 740 (2018), 76â€“84.[15] Athanasios L Konstantinidis and Charis Papadopoulos. 2020. Maximizing the
strong triadic closure in split graphs and proper interval graphs. Discrete Applied
Mathematics 285 (2020), 79â€“95.
[16] Antonis Matakos and Aristides Gionis. 2022. Strengthening ties towards a highly-
connected world. Data mining and knowledge discovery 36, 1 (2022), 448â€“476.
[17] Lutz Oettershagen, Athanasios L Konstantinidis, and Giuseppe F Italiano. 2022.
Inferring Tie Strength in Temporal Networks. In Joint European Conference on
Machine Learning and Knowledge Discovery in Databases. 69â€“85.
[18] James B Orlin. 2013. Max flows in O (nm) time, or better. In Proceedings of the
forty-fifth annual ACM symposium on Theory of computing. 765â€“774.
[19] Victor Reis and Thomas Rothvoss. 2023. The subspace flatness conjecture and
faster integer programming. arXiv preprint arXiv:2303.14605 (2023).
[20] Ryan A. Rossi and Nesreen K. Ahmed. 2015. The Network Data Reposi-
tory with Interactive Graph Analytics and Visualization. In AAAI. https:
//networkrepository.com
[21] Polina Rozenshtein, Nikolaj Tatti, and Aristides Gionis. 2017. Inferring the
strength of social ties: a community-driven approach. In Proceedings of the 23rd
ACM SIGKDD International Conference on Knowledge Discovery and Data Mining.
1017â€“1025.
[22] Alexander Schrijver. 1998. Theory of Linear Integer Programming. John Wiley &
Sons.
[23] Konstantinos Semertzidis, Evaggelia Pitoura, Evimaria Terzi, and Panayiotis
Tsaparas. 2019. Finding lasting dense subgraphs. Data mining and knowledge
discovery 33, 5 (2019), 1417â€“1445.
[24] Stavros Sintos and Panayiotis Tsaparas. 2014. Using strong triadic closure to
characterize ties in social networks. In Proceedings of the 20th ACM SIGKDD
international conference on Knowledge discovery and data mining. 1466â€“1475.
[25] Jie Tang, Jing Zhang, Limin Yao, Juanzi Li, Li Zhang, and Zhong Su. 2008. Arnet-
miner: extraction and mining of academic social networks. In KDD. 990â€“998.
[26] Charalampos Tsourakakis. 2015. The k-clique densest subgraph problem. In
WWW. 1122â€“1132.
[27] Jan van den Brand. 2020. A deterministic linear program solver in current
matrix multiplication time. In Proceedings of the Fourteenth Annual ACM-SIAM
Symposium on Discrete Algorithms. SIAM, 259â€“278.
[28] David Zuckerman. 2006. Linear degree extractors and the inapproximability of
max clique and chromatic number. In Proceedings of the thirty-eighth annual ACM
symposium on Theory of computing. 681â€“690.
A Appendix
A.1 Computational complexity proofs
Proof of Proposition 4.1. We will show the NP-hardness of
stc-den by a reduction from the NP-hard Max-Cliqe problem. As
ğœ†=0, we simply write the score as ğ‘(ğ‘ˆ,ğ¿)instead ofğ‘(ğ‘ˆ,ğ¿;ğœ†)=
ğ‘(ğ‘ˆ,ğ¿; 0)for brevity. Assume that the set ğ‘ˆwith the labeling ğ¿is
an optimal solution to the stc-den problem with ğœ†=0, maximizing
the scoreğ‘(ğ‘ˆ,ğ¿)while satisfying the STC property. The density of
the strong edges in ğ‘ˆis then
ğ‘(ğ‘ˆ,ğ¿)=Ã
ğ‘£âˆˆğ‘ˆdegğ‘ (ğ‘£,ğ‘ˆ,ğ¿)
2|ğ‘ˆ|. (7)
Consider a vertex ğ‘¤inğ‘ˆwith the highest number degğ‘ (ğ‘¤,ğ‘ˆ,ğ¿)
of strong edges connected to it. As the maximum number of strong
edges, degğ‘ (ğ‘¤,ğ‘ˆ,ğ¿)has to be at least the average,
degğ‘ (ğ‘¤,ğ‘ˆ,ğ¿)â‰¥Ã
ğ‘£âˆˆğ‘ˆdegğ‘ (ğ‘¢,ğ‘ˆ,ğ¿)
|ğ‘ˆ|. (8)
Then for any two vertices ğ‘£andğ‘¢that have strong edges (ğ‘£,ğ‘¤)
and(ğ‘¢,ğ‘¤)connecting them to ğ‘¤, there must be an edge between ğ‘£
andğ‘¢to satisfy the STC property.
Thus, the vertex ğ‘¤and its strong neighbors form a clique ğ¶with
degğ‘ (ğ‘¤,ğ‘ˆ,ğ¿)+1vertices. Consider only having these vertices in
ğ¶and having a labeling ğ¿â€²that labels each edge in the clique as
strong. This would satisfy the STC property and would give a score
of
ğ‘(ğ¶,ğ¿â€²)=|ğ¶|(|ğ¶|âˆ’1)
2|ğ¶|=|ğ¶|âˆ’1
2=degğ‘ (ğ‘¤,ğ‘ˆ,ğ¿)
2.
3342KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Chamalee Wickrama Arachchi, Iiro Kumpulainen, and Nikolaj Tatti
From Equations 7 and 8, we get
ğ‘(ğ¶,ğ¿â€²)=degğ‘ (ğ‘¤,ğ‘ˆ,ğ¿)
2â‰¥Ã
ğ‘£âˆˆğ‘ˆdegğ‘ (ğ‘£,ğ‘ˆ,ğ¿)
2|ğ‘ˆ|=ğ‘(ğ‘ˆ,ğ¿).(9)
Thus, the clique ğ¶has at least the same score as ğ‘ˆ, which has
the maximum score of all subgraphs, so ğ‘(ğ¶,ğ¿â€²)=ğ‘(ğ‘ˆ,ğ¿). This
means thatğ¶must be a maximum size clique in the input graph ğº,
as larger cliques would give a higher score than ğ‘ˆ.
Therefore, by finding an optimal set of vertices ğ‘ˆand labeling ğ¿
we can find a maximum clique ğ¶. Thus, stc-den isNP-hard. â–¡
Proof of Proposition 4.2. Assume that we can find a set ğ‘ˆ
with labeling ğ¿that is anğ›¼-approximation to stc-den, while the
optimal solution has value ğ‘(ğ¶âˆ—,ğ¿âˆ—)with a maximum clique ğ¶âˆ—and
labelingğ¿âˆ—. Consider then the vertex ğ‘¤with the highest number
of strong edges and construct the clique ğ¶consisting of ğ‘¤and its
strong neighbors. Define the labeling ğ¿â€²such that each edge in the
cliqueğ¶is labeled as strong. Using Equation 9 and that ğ‘(ğ‘ˆ,ğ¿)is
anğ›¼-approximation, we get
ğ‘(ğ¶,ğ¿â€²)â‰¥ğ‘(ğ‘ˆ,ğ¿)â‰¥ğ›¼ğ‘(ğ¶âˆ—,ğ¿âˆ—).
But as the score of a clique ğ¶with only strong edges is ğ‘(ğ¶,ğ¿â€²)=
|ğ¶|âˆ’1
2, we have
|ğ¶|âˆ’1
2â‰¥ğ›¼|ğ¶âˆ—|âˆ’1
2.
By solving for|ğ¶|and usingğ›¼â‰¤1, we get
|ğ¶|â‰¥ğ›¼ ğ¶âˆ—âˆ’1+1â‰¥ğ›¼ğ¶âˆ—.
This means that we have an ğ›¼-approximation for Max-Cliqe.
Therefore, any inapproximability results for Max-Cliqe also apply
for theğœ†=0case of stc-den. Using the result by Zuckerman [28]
then finishes the proof. â–¡
To prove Proposition 4.3 we need the following lemma.
Lemma A.1. Assume graph ğº. Letğ‘‹âŠŠğ‘Œbe two subgraphs, and
letğ¿be a labeling defined on ğ‘Œ. Define
Î”(ğ‘‹,ğ‘Œ)=ğ‘šğ‘ (ğ‘Œ)+ğœ†ğ‘šğ‘¤(ğ‘Œ)âˆ’ğ‘šğ‘ (ğ‘‹)âˆ’ğœ†ğ‘šğ‘¤(ğ‘‹)
|ğ‘Œ|âˆ’|ğ‘‹|.
IfÎ”(ğ‘‹,ğ‘Œ)<q(ğ‘Œ,ğ¿), then q(ğ‘Œ,ğ¿)<q(ğ‘‹,ğ¿), ifÎ”(ğ‘‹,ğ‘Œ)>q(ğ‘Œ,ğ¿),
then q(ğ‘Œ,ğ¿)>q(ğ‘‹,ğ¿), and if Î”(ğ‘‹,ğ‘Œ)=q(ğ‘Œ,ğ¿), then q(ğ‘Œ,ğ¿)=
q(ğ‘‹,ğ¿).
Proof. Assume Î”(ğ‘‹,ğ‘Œ)<q(ğ‘Œ,ğ¿). Multiply by(|ğ‘Œ|âˆ’|ğ‘‹|)|ğ‘Œ|
and subtract|ğ‘Œ|(ğ‘šğ‘ (ğ‘Œ)+ğœ†ğ‘šğ‘¤(ğ‘Œ))from both sides. Dividing by
âˆ’|ğ‘‹||ğ‘Œ|then gives q(ğ‘‹,ğ¿)>q(ğ‘Œ,ğ¿), proving the first claim. The
proofs for other claims are identical. â–¡
Proof of Proposition 4.3. We will prove the hardness by re-
ducing an NP-hard problem MinSTC to our problem. In MinSTC,
we are asked to label the full graph and minimize the number of
weak edges [ 24]. Assume a graph ğºwith nodesğ‘‰=ğ‘£1,...ğ‘£ğ‘›. We
assume that ğ‘›â‰¥5. We define a new graph ğ»that consists of ğºand
ğ‘˜=âŒˆ1/ğœ†âŒ‰(ğ‘›+1)/2cliquesğ¶ğ‘–of sizeğ‘›. Let
ğ‘ğ‘–ğ‘—	be the nodes in
ğ¶ğ‘–. For eachğ‘—andğ‘–, we connect ğ‘£ğ‘—withğ‘ğ‘–ğ‘—.
Letğ‘ˆbe the optimal subgraph of ğ»forstc-den andğ¿be its
labeling. Let ğ¿â€²be the labeling where every ğ¸(ğ¶ğ‘–)is strong and theremaining edges are weak. Note that q(ğ‘ˆ)â‰¥q(ğ¶ğ‘–,ğ¿â€²)=(ğ‘›âˆ’1)/2â‰¥
2for anyğ¶ğ‘–. We claim that ğ‘ˆcontains every node in ğ».
To prove the claim, let us define ğ‘Šğ‘–=ğ‘ˆâˆ©ğ¶ğ‘–. If|ğ‘Šğ‘–|=1,2, then
Î”(ğ‘ˆ\ğ‘Šğ‘–,ğ‘ˆ)â‰¤ 3/2<q(ğ‘ˆ)and Lemma A.1 states that we can
deleteğ‘Šğ‘–fromğ‘ˆand obtain a better score. Assume 3â‰¤|ğ‘Šğ‘–|<ğ‘›.
Letğ‘âˆˆğ¶ğ‘–\ğ‘Šğ‘–. We can safely assume that the edges between
ğ‘Šğ‘–andğºare weak; otherwise, we can relabel them as weak and
compensate by labeling any weak edge in ğ‘Šğ‘–as strong. Now we
can extend the labeling ğ¿toğ‘by setting the edges from ğ‘toğ‘Šğ‘–as
strong, and the possibly remaining edge as weak. We can show that
Î”(ğ‘ˆ\ğ‘Šğ‘–,ğ‘ˆ)<Î”(ğ‘ˆ,ğ‘ˆâˆª{ğ‘}). Lemma A.1, applied twice, states
that either deleting ğ‘Šğ‘–or addingğ‘improves the solution. Therefore,
eitherğ‘Šğ‘–=âˆ…orğ‘Šğ‘–=ğ¶ğ‘–.
Assumeğ‘Šğ‘–=ğ¶ğ‘–andğ‘Šğ‘—=âˆ…. The optimal labeling must be such
that all edges between ğ‘Šğ‘–andğºare weak and the edges in ğ‘Šğ‘–are
all strong. We can extend the same labeling scheme to ğ¶ğ‘—. Then
Î”(ğ‘ˆ\ğ¶ğ‘–,ğ‘ˆ)=Î”(ğ‘ˆ,ğ‘ˆâˆªğ¶ğ‘—). IfÎ”(ğ‘ˆ,ğ‘ˆâˆªğ¶ğ‘—)>q(ğ‘ˆ), Lemma A.1
implies that we improve the solution by adding ğ¶ğ‘—, which is a
contradiction. Hence, Î”(ğ‘ˆ\ğ¶ğ‘–,ğ‘ˆ)â‰¤q(ğ‘ˆ). Lemma A.1 implies that
we can safely delete ğ¶ğ‘–. Applying this iteratively we arrive to an
optimal solution with nodes only in ğ‘‰. This cannot happen since
then q(ğ‘ˆ)â‰¤(ğ‘›âˆ’1)/2, but then q(ğ¶ğ‘–âˆªğ‘‰,ğ¿â€²)=(ğ‘›âˆ’1)/2+ğœ†/2>
ğ‘(ğ‘ˆ). Therefore, ğ‘Šğ‘–=ğ¶ğ‘–for everyğ‘–.
Finally, assume ğ‘£ğ‘—âˆ‰ğ‘ˆ. Then Î”(ğ‘ˆ,ğ‘ˆâˆª
ğ‘£ğ‘—	
)â‰¥ğœ†ğ‘˜â‰¥(ğ‘›+1)/2>
(ğ‘›âˆ’1)/2+ğœ†â‰¥Î”(ğ‘ˆ\ğ¶ğ‘–,ğ‘ˆ). Lemma A.1 states that either deleting
anyğ¶ğ‘–or addingğ‘£ğ‘—improves the solution. This contradicts the
optimality of ğ‘ˆ, so everyğ‘£ğ‘—âˆˆğ‘ˆ.
Consequently, ğ‘‰âŠ†ğ‘ˆ. The optimal labeling must have every
edge inğ¶ğ‘–as strong, the cross-edges between ğ¶ğ‘–andğºas weak,
and the labels for edges in ğºsolve MinSTC. â–¡
A.2 Proofs for Section 5.1
Proof of Proposition 5.1. Let us write ğ‘“(ğ‘ˆ,ğ¿)=ğ‘šğ‘ (ğ‘ˆ,ğ¿)+
ğœ†ğ‘šğ‘¤(ğ‘ˆ,ğ¿). Note that
ğ‘“(ğ‘ˆ(ğ›¼),ğ¿(ğ›¼))âˆ’ğ›¼|ğ‘ˆ(ğ›¼)|â‰¥0. (10)
Assumeğ›¼>ğ›¼âˆ—. Ifğ‘ˆ(ğ›¼)â‰ âˆ…, then Eq. 10 implies that
q(ğ‘ˆ(ğ›¼),ğ¿(ğ›¼))â‰¥ğ›¼>ğ›¼âˆ—,
which contradicts the optimality of ğ›¼âˆ—. Thus,ğ‘ˆ(ğ›¼)=âˆ….
Assumeğ›¼<ğ›¼âˆ—. Then
ğ‘“(ğ‘ˆ(ğ›¼),ğ¿(ğ›¼))âˆ’ğ›¼|ğ‘ˆ(ğ›¼)|â‰¥ğ‘“(ğ‘ˆâˆ—,ğ¿âˆ—)âˆ’ğ›¼ğ‘ˆâˆ—
>ğ‘“(ğ‘ˆâˆ—,ğ¿âˆ—)âˆ’ğ›¼âˆ—ğ‘ˆâˆ—=0.
That is,ğ‘“(ğ‘ˆ(ğ›¼),ğ¿(ğ›¼))>ğ›¼|ğ‘ˆ(ğ›¼)|, implying in turn that ğ‘ˆ(ğ›¼)â‰ âˆ…
andq(ğ‘ˆ(ğ›¼),ğ¿(ğ›¼))>ğ›¼. â–¡
Proof of Proposition 5.2. Letğ¿andğ‘ˆbe the values of the
interval when binary search is terminated. Note that ğ›¼â‰¥ğ¿due to
Proposition 5.1. We know that ğ‘ˆâˆ’ğ¿â‰¤ğœ–ğ¿andğ¿â‰¤ğ›¼âˆ—â‰¤ğ‘ˆ. Thus,
ğ›¼âˆ—âˆ’ğ¿â‰¤ğ‘ˆâˆ’ğ¿â‰¤ğœ–ğ¿, orğ›¼âˆ—â‰¤(1+ğœ–)ğ¿â‰¤(1+ğœ–)ğ›¼. â–¡
Proof of Proposition 5.3. Letğ›¼be the score of the solution
ğ‘‹,ğ¿returned by STC-ILP , and letğ›¼âˆ—be the score of the optimal
solutionğ‘‹âˆ—,ğ¿âˆ—forstc-den. We will show that if ğ›¼<ğ›¼âˆ—, then
ğ›¼âˆ—âˆ’ğ›¼â‰¥1/(ğ‘ğ‘›2), which contradicts with the fact that ğ›¼âˆ—âˆ’ğ›¼â‰¤
ğœ–ğ›¼<ğœ–ğ‘›/2=1/(ğ‘ğ‘›2).
3343Dense Subgraph Discovery Meets Strong Triadic Closure KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
To prove the claim, let Î”=ğ›¼âˆ—âˆ’ğ›¼. Then
Î”=ğ‘šğ‘ (ğ‘‹âˆ—)+ğ‘
ğ‘ğ‘šğ‘¤(ğ‘‹âˆ—)
|ğ‘‹âˆ—|âˆ’ğ‘šğ‘ (ğ‘‹)+ğ‘
ğ‘ğ‘šğ‘¤(ğ‘‹)
|ğ‘‹|
=|ğ‘‹|(ğ‘ğ‘šğ‘ (ğ‘‹âˆ—)+ğ‘ğ‘šğ‘¤(ğ‘‹âˆ—))âˆ’|ğ‘‹âˆ—|(ğ‘ğ‘šğ‘ (ğ‘‹)+ğ‘ğ‘šğ‘¤(ğ‘‹))
ğ‘|ğ‘‹||ğ‘‹âˆ—|.
Note that the numerator and the denominator are both integers.
Consequently, if Î”>0, then Î”â‰¥1/(ğ‘ğ‘›2). It follows that if we set
ğœ–=2
ğ‘ğ‘›3, then STC-ILP finds the optimal solution in O(logğ‘›+logğ‘)
number of rounds. â–¡A.3 Proofs for Section 5.2
Proof of Proposition 5.4. Scaling(ğ‘¥âˆ—,ğ‘¦âˆ—,ğ‘§âˆ—)by any constant
ğ‘>0does not change the value of ğ‘Ÿ(Â·,Â·,Â·)nor does it change the
validity of the constraints in Eqs. 2â€“4. Therefore, we can safely
assume that ğ‘¥âˆ—ğ‘’,ğ‘§âˆ—ğ‘’â‰¤1andğ‘¦âˆ—
ğ‘–â‰¤1andğ‘–âˆˆğ‘‰, for anyğ‘’âˆˆğ¸and
ğ‘–âˆˆğ‘‰. The claim now follows by repeating the steps of the proof of
Proposition 5.1. â–¡
Proof of Proposition 5.5. Scaling(ğ‘¥âˆ—,ğ‘¦âˆ—,ğ‘§âˆ—)by any constant
ğ‘>0does not change the value of ğ‘Ÿ(Â·,Â·,Â·)nor does it change the
validity of the constraints in Eqs. 2â€“4. Therefore, we can safely
require thatÃğ‘¦ğ‘–=1, which immediately proves the claim. â–¡
3344