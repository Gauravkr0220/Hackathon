Under review as submission to TMLR
Autoencoding Reduced Order Models for Control through
the Lens of Dynamic Mode Decomposition
Anonymous authors
Paper under double-blind review
Abstract
Modeling and control of high-dimensional dynamical systems often involve some dimension-
ality reduction techniques to construct a lower-order model that makes the associated task
computationally feasible or less demanding. In recent years, two techniques have become
widely popular for analysis and reduced order modeling of high-dimensional dynamical sys-
tems: (1) dynamic mode decomposition and (2) deep autoencoding learning. This paper
establishes a connection between dynamic mode decomposition and autoencoding learning
for controlled dynamical systems. Specifically, we first show that an optimization objec-
tive for learning a linear autoencoding reduced order model can be formulated such that
its solution closely resembles the solution obtained by the dynamic mode decomposition
with control algorithm. The linear autoencoding architecture is then extended to a deep
autoencoding architecture to learn a nonlinear reduced order model. Finally, the learned
reduced order model is used to design a controller utilizing stability-constrained deep neural
networks. The studied framework does not require knowledge of the governing equations
of the underlying system and learns the model and controller solely from time series data
of observations and actuations. We provide empirical analysis on modeling and control of
spatiotemporal high-dimensional systems, including fluid flow control.
1 Introduction
Designingcontrollersforhigh-dimensionaldynamicalsystemsremainsachallengeasmanycontrolalgorithms
become computationally prohibitive in high dimensions. Typically, a reduce-then-design approach (Atwell
et al. (2001)) is used in practice, which involves two steps: (1) develop a reduced order model (ROM) using
dimensionality reduction techniques and (2) design a controller for that reduced order model (Figure 1a). For
controlled dynamical systems, the reduced order modeling approaches either combine analytical techniques
with empirical approximation (Willcox & Peraire (2002)) or are purely data-driven (Juang & Pappa (1985);
Juang et al. (1993); Proctor et al. (2016)). Among these, the dynamic mode decomposition (DMD) based
methods have become widely popular in recent years due to a strong connection between DMD and Koopman
operator theory (Rowley et al. (2009)). Another recent research trend involves utilizing deep neural networks
(DNNs), particularly autoencoders, for modeling and control of high-dimensional dynamical systems (Lusch
et al. (2018); Erichson et al. (2019); Eivazi et al. (2020); Morton et al. (2018); Bounou et al. (2021); Chen
et al. (2021); Ping et al. (2021)).
In this paper, we provide a perspective connecting DMD and autoencoding reduced order models for con-
trolled dynamical systems and present a framework to learn control policies for such systems by means of
the DNN-based reduced order models. We first formulate an objective function for data-driven learning of
controlled dynamical systems in a linear autoencoding configuration. We analytically show that the asso-
ciated objective function encourages a linear ROM that closely resembles the lower-order model obtained
using the dynamic mode decomposition with control (DMDc) algorithm (Proctor et al. (2016)). The linear
autoencoding architecture is designed in such a way that its components can be replaced with DNNs and
the corresponding objective function can be optimized by gradient descent to obtain a nonlinear ROM. The
architecture with DNN components, DeepROM, closely resembles the aforementioned deep autoencoding
architectures used in recent literature for the prediction and control of dynamical systems. The learned
1Under review as submission to TMLR
Physical SystemReduced order 
ModelingLinear Reduced -order 
Model (ROM)High -dimensional
state dataConventional Control 
Design (e.g., LQR)
Linear Autoencoding 
ROM (LAROM)Reduced order Modeling
Dynamic Mode 
Decomposition
Autoencoding
Learning
Control Learning
(DeepROC )Nonlinear ROM
(DeepROM)Stability Analysis(a)
(b)Linear
option
Nonlinear
optionController
Figure 1: (a) Reduce-then-design paradigm for designing control for high-dimensional systems, (b): our
work in the context. The rounded-corner rectangles denote the actual physical system (red outlined) or
its models (green outlined) or a controller (yellow outlined). The sharp-corner rectangles indicate the tech-
niques/proceduretoobtainthemodelsorcontrollers. Amongthosesharp-cornerrectangles, theonesoutlined
in orange are associated with modeling, while the ones outlined in blue are associated with control. This
work proposes an autoencoding learning framework that establishes a linkwith dynamic mode decomposi-
tion. The similarity with dynamic mode decomposition for control is shown through a linear autoencoding
reduced order model while the prediction and control performance is evaluated using a deep autoencoding
reduced order model. The dashed arrow in the figure represents the potential control methods that can be
applied to the linear ROM.
DNN-based reduced order model is then used in a control learning framework, deep reduced order control
(DeepROC), to design a controller for the underlying system. The control policy is learned by jointly training
two DNNs: one stability-constrained DNN predicts a target closed-loop dynamics for the learned ROM while
the other DNN serves as a controller to achieve that target dynamics. We analytically show that keeping the
joint learning objective within a sufficiently small value implies stability for the closed-loop ROM in terms
ofultimate boundededness , i.e., trajectories starting close to the desired state stay close to the desired state.
The overall workflow of this paper is shown in Figure 1(b). We provide empirical analysis using examples
of spatiotemporal physical processes such as reaction‚Äìdiffusion and fluid flow systems. In summary, our
contributions are as follows:
‚Ä¢For controlled dynamical systems, we show that an objective function can be formulated in a linear
autoencoding configuration and optimized by gradient descent such that the corresponding linear
ROM closely resembles the ROM obtained using the DMDc algorithm.
‚Ä¢We extend the linear autoencoding configuration to a deep autoencoding configuration to learn a
DNN-based nonlinear ROM.
‚Ä¢We analytically show that a DNN controller can be trained such that the closed-loop trajectories of
the learned ROM remain ultimately bounded.
‚Ä¢We empirically show the similarity of the linear autoencoding reduced order model (LAROM) with
DMDc and evaluate the prediction performance of DeepROM and control performance of DeepROC
in experiments with high-dimensional systems, including suppressing vortex shedding in fluid flow.
2Under review as submission to TMLR
2 Related Work
In recent years, deep learning has seen widespread application in scientific and engineering problems, in-
cluding understanding complex dynamics of large-scale or high-dimensional systems and solving associated
computational tasks. The majority of the research in this area focuses on the modeling and prediction of
such complex dynamics using deep neural networks (DNNs) (Xingjian et al. (2015); Long et al. (2018); Raissi
(2018); Seo et al. (2019); Ayed et al. (2019); Don√† et al. (2020)) and has found application in several fields
including fluid flow (Erichson et al. (2019); Eivazi et al. (2020); Srinivasan et al. (2019)), biochemical and
electric power systems (Yeung et al. (2019)), climate and ocean systems (Scher (2018); Ren et al. (2021);
Yang et al. (2017); De B√©zenac et al. (2019)), and structural analysis Zhang et al. (2020), just to name a
few.
A second line of research, though relatively less prevalent than modeling and prediction, is utilizing deep
learning for controlling high-dimensional systems and aligns closely with our work. Most of these works focus
on fluid flow control tasks. Rabault et al. (2019); Tang et al. (2020) applied deep reinforcement learning in
active flow control for vortex shedding suppression and used a system-specific reward function involving lift
and drag. Ma et al. (2018) used an autoencoder for encoding high-dimensional fluid state to low-dimensional
features and trained RL agents with those features to control rigid bodies in a coupled 2D system involving
both fluid and rigid bodies. Garnier et al. (2021) also used an autoencoder for feature extraction to train an
RL agent for controlling the position of a small cylinder in a two-cylinder fluid system to reduce the total
drag. Beintema et al. (2020) used deep reinforcement learning with system-specific rewards to control a
Rayleigh‚ÄìB√©nard system with the aim of reducing convective effects. Model-free deep reinforcement learning
methods have high sample complexity necessitating a large number of interactions with the environment
and often require system-specific reward construction. In contrast, we consider learning the control policies
offline with limited pre-collected data. Moreover, we utilize standard distance-based metrics with respect to a
hypothesized target dynamics instead of relying on any system-specific rewards or loss functions. Model-free
RL methods require running numerical solvers in every iteration to provide feedback to the agents, which
is computationally expensive. The same concern arises for the methods involving differentiable simulators.
For example, Holl et al. (2020) used a differentiable partial differential equation (PDE) solver to generate
gradient-based feedback for a predictor-corrector scheme to control PDE-driven high-dimensional systems.
Takahashi et al. (2021) too integrated a differentiable simulator with DNNs to learn control in coupled solid-
fluid systems. In comparison, our method avoids the need for computationally intensive simulators during
the learning process as it learns from pre-collected data in an offline manner.
The alternative to model-free methods takes the traditional approach: develop a model first and then use
that to design controllers. Deep learning is now being used in this process by developing frameworks like
DeepMPC (Lenz et al. (2015)) which incorporates DNN features in model predictive control (MPC). Bieker
et al. (2020) and Morton et al. (2018) utilized the DeepMPC framework for fluid flow control. Bieker et al.
(2020) used a recurrent neural network to model the dynamics of only control-relevant quantities (i.e. lift
and drag) of the system, which is then employed in an MPC framework for the flow control tasks. Morton
et al. (2018) followed the method proposed by Takeishi et al. (2017) and used DNN-based embedding to
first learn a linear reduced order model in Koopman invariant subspace and then incorporate it in the
MPC framework. Similar approaches have been applied to other high-dimensional control tasks like control
from video input (Bounou et al. (2021)), automatic generation control in wind farms in the presence of
dynamic wake effect (Chen et al. (2021)), and transient stabilization in power grids (Ping et al. (2021)).
These model-based methods constrain the latent dynamic models to be linear that work well within a
short time window. Khodkar et al. (2019) showed that the linear combination of a finite number of dynamic
modes may not accurately represent the long-term nonlinear characteristics of complex dynamics and adding
nonlinear forcing terms yields better prediction accuracy (Eivazi et al. (2020)). The linear ROMs are needed
to be updated with online observations during operation for better prediction accuracy. Accordingly, the
aforementioned model-based approaches utilize the MPC framework to optimize the control policy online
using the updated dynamic model. Running online optimization at every step may not be computationally
feasibleinmanyscenarios. Conversely, weinvestigateifanonlinearROMprovidesamoreaccurateprediction
over a longer time window so that an offline control learning method can be used.
3Under review as submission to TMLR
3 Problem and Preliminaries
3.1 Problem statement
Consider a time-invariant controlled dynamical system
dx
dt=f(x,u), (1)
wherex(t)‚ààX‚äÇRdx,dx>>1andu(t)‚ààU‚äÇRduare the system state and the actuation (or control
input), respectively, at time t. Our objective is to learn a feedback controller u=œÄ(x)for this high-
dimensional ( dx>>1) system of (1) to stabilize it at a desired state in a data-driven reduce-then-design
approach when the nonlinear function f:X√óU‚ÜíRdxis unknown. We assume that we have observations
from the system consisting of time series data x(ti),i= 0,1,¬∑¬∑¬∑,nsubjected to random values of actuations
u(ti),i= 0,1,¬∑¬∑¬∑,(n‚àí1).
Note, we use v(in place of v(t)for brevity) as notation for any continuous-time variable (e.g., system state,
control input), whereas v(ti)is used to denote their discrete sample at time instance ti.
3.2 Stabilization of controlled systems
We assume that the system we are aiming to stabilize at an equilibrium point is locally stabilizable . Suppose
the function fin (1) is locally Lipschitz and (x=0,u=0)is an equilibrium pair of the system, i.e.,
f(0,0) =0. The system (1) is said to be locally stabilizable with respect to the equilibrium pair if there
exists a locally Lipschitz function
œÄ:X0‚ÜíU, œÄ(0) =0,
defined on some neighborhood X0‚äÇXof the origin x=0for which the closed-loop system
dx
dt=f(x,œÄ(x)) (2)
is locally asymptotically stable , i.e.‚à•x(t0)‚à•< Œ¥implies limt‚Üí‚àûx(t) =0(Sontag (2013)). We discuss the
criteria for stability and asymptotic stability in the following paragraph.
Stability of the closed-loop systemdx
dt=f(x,œÄ(x)) =h(x)at equilibrium points can be analyzed using the
method of Lyapunov. Let V:X‚ÜíRbe a continuously differentiable function such that
V(0) = 0,andV(x)>0‚àÄx‚ààX\{0}, (3)
and the time derivative of Valong the trajectories
dV
dt=‚àáV(x)‚ä§dx
dt=‚àáV(x)‚ä§h(x)‚â§0‚àÄx‚ààX. (4)
Then, the equilibrium point x=0isstable, i.e., for each œµ >0, there exists a Œ¥=Œ¥(œµ)>0such that
‚à•x(t0)‚à•< Œ¥implies‚à•x(t)‚à•< œµ,‚àÄt > t 0. The functionVwith the above properties is called a Lyapunov
function. IfdV
dt<0in some subset Xs‚äÇX\{0}, thenx=0islocally asymptotically stable . Moreover, if
there exist positive constants c1,c2,c3andc4such that
c1‚à•x‚à•2‚â§V(x)‚â§c2‚à•x‚à•2, (5)
and
‚àáV(x)‚ä§h(x)‚â§‚àíc3‚à•x‚à•2,‚àÄx‚ààXs, (6)
thenx=0isexponentially stable , i.e., there exist positive constants Œ¥,ŒªandŒ≥such that‚à•x(t)‚à• ‚â§
Œª‚à•x(t0)‚à•e‚àíŒ≥(t‚àít0),‚àÄ‚à•x(t0)‚à•<Œ¥(Khalil (2002)).
In this paper, we assume that the system we are aiming to stabilize at an equilibrium point is stabilizable in
the sense of the aforementioned definition and criteria, i.e., there exists a continuously differentiable function
4Under review as submission to TMLR
Vand a Lipschitz continuous control law œÄsuch that criteria (3) and (4) are conformed. To ensure the
stability of the closed-loop reduced order model at equilibrium, we utilize a target dynamics hypothesis that
is exponentially stable at the origin, i.e., (5) and (6) are satisfied as well for this target dynamics. Detail on
the target dynamics hypothesis is discussed in subsection 4.2.
Though the above formulation is for stabilization at an equilibrium point x=0, the same can be used to
stabilize the system at any arbitrary point xss. In that case, a steady-state control input ussis required that
can maintain the equilibrium at xss, i.e.,f(xss,uss) =0. The change of variables xe=x‚àíxss,ue=u‚àíuss
leads to a transformed system where we can apply the aforementioned formulation of stabilization. The
overall control, in this case, u=ue+usscomprises a feedback component ueand a feedforward component
uss(Khalil (2002)).
3.3 Dynamic mode decomposition with control
DMD (Schmid (2010)) is a data-driven method that reconstructs the underlying dynamics using only a time
series of snapshots from the system. DMD computes a modal decomposition where each mode is associated
with an oscillation frequency and decay/growth rate. DMD has become a widely used technique for spectral
analysis of dynamical systems. DMDc (Proctor et al. (2016)) is an extension of DMD for dynamical systems
with control. DMDc seeks best-fit linear operators AandBbetween successive observed states and the
actuations:
ÀÜx(ti+1) =Ax(ti) +Bu(ti), i= 0,1,¬∑¬∑¬∑,n‚àí1, (7)
where ÀÜx(t)denotes an approximation of x(t),A‚ààRdx√ódx, andB‚ààRdx√ódu. Direct analysis of (7) could
be computationally prohibitive for dx>>1. DMDc leverages dimensionality reduction to compute a ROM
xR,DMDc (ti) =EDMDcx(ti), (8a)
xR,DMDc (ti+1) =AR,DMDcxR,DMDc (ti) +BR,DMDcu(ti), i= 0,1,¬∑¬∑¬∑,n‚àí1, (8b)
which retains the dominant dynamic modes of (7). Here, xR,DMDc (ti)‚ààRrxis the reduced state,
whererx<< d x, andEDMDc‚ààRrx√ódx,AR,DMDc‚ààRrx√órx,BR,DMDc‚ààRrx√ódu. The full state
is reconstructed from the reduced state using the transformation ÀÜx(ti) =DDMDcxR,DMDc (ti), where
DDMDc‚ààRdx√órx. DMDc computes truncated singular value decomposition (SVD) of the data matri-
cesY= [x(t1),x(t2),¬∑¬∑¬∑,x(tn)]‚ààRdx√ónand‚Ñ¶= [œâ(t0),œâ(t1),¬∑¬∑¬∑,œâ(tn‚àí1)]‚ààR(dx+du)√ón,œâ(ti) =
[x(ti)‚ä§,u(ti)‚ä§]‚ä§‚ààRdx+duas follows:
Y=/hatwideUY/hatwideŒ£Y/hatwideV‚ä§
Y,‚Ñ¶=/hatwideU‚Ñ¶/hatwideŒ£‚Ñ¶/hatwideV‚ä§
‚Ñ¶, (9)
where/hatwideUY‚ààRdx√órx,/hatwideŒ£Y‚ààRrx√órx,/hatwideVY‚ààRn√órx,/hatwideU‚Ñ¶‚ààR(dx+du)√órxu,/hatwideŒ£‚Ñ¶‚ààRrxu√órxu, and/hatwideV‚Ñ¶‚ààRn√órxu.
rx<min(dx,n)andrx<rxu<min(dx+du,n)denote the truncation dimensions of SVDs. Utilizing the
SVDs of (9) the parameters of the ROM (8) is obtained as
EDMDc =/hatwideU‚ä§
Y,DDMDc =/hatwideUY, (10a)
AR,DMDc =/hatwideU‚ä§
YY/hatwideV‚Ñ¶/hatwideŒ£‚àí1
‚Ñ¶/hatwideU‚ä§
‚Ñ¶,1/hatwideUY,BR,DMDc =/hatwideU‚ä§
YY/hatwideV‚Ñ¶/hatwideŒ£‚àí1
‚Ñ¶/hatwideU‚ä§
‚Ñ¶,2, (10b)
where/hatwideU‚Ñ¶,1‚ààRdx√órxu,/hatwideU‚Ñ¶,2‚ààRdu√órxu, and/hatwideU‚ä§
‚Ñ¶= [/hatwideU‚ä§
‚Ñ¶,1/hatwideU‚ä§
‚Ñ¶,2].
4 Method
As mentioned earlier, in the reduce-then-design approach, we first need to develop a ROM and then design a
controller using that ROM. A controller designed for the ROM is expected to perform well in the full system
only if the ROM effectively captures the dynamic characteristics of the underlying system. In this section,
we first describe how to design a ROM that effectively captures the relation between successive observations
and actuation. Next, we delineate the process for learning controllers utilizing the learned ROM.
5Under review as submission to TMLR
4.1 Learning a reduced order model
DMDc can extract the dominant modes of underlying dynamics in a reduced order model (Proctor et al.
(2016)). In order to develop a nonlinear ROM utilizing DNNs that effectively capture the underlying dynam-
ics, we first investigate if we can obtain a linear ROM similar to DMDc, in a gradient descent arrangement.
Specifically, we analyze optimization objectives that encourage a DMDc-like solution for a reduced order
modeling problem using linear networks (single layer without nonlinear activation). Consider the following
reduced order modeling problem
xR(ti) =Exx(ti),xR(ti+1) =ARxR(ti) +BRu(ti),ÀÜx(ti) =DxxR(ti), i= 0,1,¬∑¬∑¬∑,n‚àí1,(11)
where the linear operators Ex‚ààRrx√ódxandDx‚ààRdx√órxprojects and reconstructs back, respectively,
the high-dimensional system state to and from a low-dimensional feature xR‚ààRrx. The linear operators
AR‚ààRrx√órxandBR‚ààRrx√ódudescribe the relations between successive reduced states and actuations.
We refer to this reduced order model with linear networks as linear autoencoding ROM or LAROM. In the
following, we first analyze the solution of the optimization objective of LAROM for a fixed encoderEx.
Then we establish a connection between the solution of LAROM and the solution of DMDc, and further
discuss the choice of the encoder to promote similarity between the two. Finally, we extend the linear model
to a DNN-based model, which we refer to as DeepROM.
4.1.1 Analysis of the linear reduced order model for a fixed encoder
The DMDc algorithm essentially solves for /tildewideG‚ààRrx√ó(dx+du)to minimize1
n/summationtextn‚àí1
i=0/vextenddouble/vextenddoubleExx(ti+1)‚àí/tildewideGœâ(ti)/vextenddouble/vextenddouble2
for a fixed projection matrix Ex=EDMDc =/hatwideU‚ä§
Y. Here,œâ(ti)is the concatenated vector of state and
actuation as defined in section 3.3. The optimal solution /tildewideGoptis then partitioned as [/tildewideA/tildewideB]such that
/tildewideA‚ààRrx√ódx,/tildewideB‚ààRrx√ódu. Finally,/tildewideAis post-multiplied with the reconstruction operator DDMDc =/hatwideUYto
get the ROM components AR,DMDcandBR,DMDc. Details of this process along with the proofs are given in
appendix A.5. Note, the final step of this process offers dimensionality reduction only for the linear case, not
in the case when the projection and reconstruction operators are nonlinear (e.g. DNNs). Therefore, we use
an alternative formulation with the following results to design a loss function that encourages a DMDc-like
solution for (11) and also offers dimensionality reduction when nonlinear components are used.
Theorem 4.1.1. Consider the following objective function
Lpred(Ex,G) =1
nn‚àí1/summationdisplay
i=0/vextenddouble/vextenddoubleExx(ti+1)‚àíGExuœâ(ti)/vextenddouble/vextenddouble2, (12)
whereG= [ARBR]‚ààRrx√ó(rx+du),Exu=/bracketleftbiggEx0
0Idu/bracketrightbigg
‚ààR(rx+du)√ó(dx+du),Idubeing the identity matrix
of orderdu. For any fixed matrix Ex, the objective function Lpredis convex in the coefficients of Gand
attains its minimum for any Gsatisfying
GExu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu=ExY‚Ñ¶‚ä§E‚ä§
xu, (13)
whereYand‚Ñ¶are the data matrices as defined in section (3.3). If Exhas full rank rx, and‚Ñ¶‚Ñ¶‚ä§is
non-singular, then Lpredis strictly convex and has a unique minimum for
G= [ARBR] =ExY‚Ñ¶‚ä§E‚ä§
xu(Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu)‚àí1. (14)
Proof sketch . This can be proved by a method similar to the one used for deriving the solution of linear
autoencoder in (Baldi & Hornik (1989)). For any fixed Ex, the objective function of (12) can be written as
Lpred(Ex,G) =/vextenddouble/vextenddoublevec(ExY)‚àí(‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)vec(G)/vextenddouble/vextenddouble2, where‚äódenotes the Kronecker product and vec (¬∑)
denotes vectorization of a matrix. Optimizing this linear least-square problem, we get (13) and (14), given
the stated conditions are satisfied. The complete proof is given in appendix A.1.
6Under review as submission to TMLR
Remark. For a unique solution, we assume that Exhas full rank. The other scenario, i.e., Exis rank-
deficient suggests poor utilization of the hidden units of the model. In that case, the number of hidden
units (which represents the dimension of the reduced state) should be decreased. The assumption that the
covariance matrix ‚Ñ¶‚Ñ¶‚ä§is invertible can be ensured when n‚â•dx+du, by removing any linearly dependent
features in system state and actuation. When n < d x+du, the covariance matrix ‚Ñ¶‚Ñ¶‚ä§is not invertible.
However, similar results can be obtained by adding ‚Ñì2regularization (for the coefficients/entries of G) to
the objective function. Proof of this is given in appendix A.4.
4.1.2 The connection between the solutions of the linear autoencoding model and DMDc
The connection between the ROM obtained by minimizing Lpred(for a fixedEx), i.e., (14) and the DMDc
ROMof(10b)isnotreadilyapparent. Tointerprettheconnection, weformulateanalternativerepresentation
of (14) utilizing the SVD and the Moore-Penrose inverse of matrices. This alternative representation leads
to the following result.
Corollary 4.1.1.1. Consider the (full) SVD of the data matrix ‚Ñ¶given by ‚Ñ¶=U‚Ñ¶Œ£‚Ñ¶V‚ä§
‚Ñ¶, whereU‚Ñ¶‚àà
R(dx+du)√ó(dx+du),Œ£‚Ñ¶‚ààR(dx+du)√ón, andV‚Ñ¶‚ààRn√ón. IfEx=/hatwideU‚ä§
Yand‚Ñ¶‚Ñ¶‚ä§is non-singular, then the
solution forG= [ARBR]corresponding to the unique minimum of Lpredcan be expressed as
AR=/hatwideU‚ä§
YYV‚Ñ¶Œ£‚àóU‚ä§
‚Ñ¶,1/hatwideUY,andBR=/hatwideU‚ä§
YYV‚Ñ¶Œ£‚àóU‚ä§
‚Ñ¶,2, (15)
where [U‚ä§
‚Ñ¶,1U‚ä§
‚Ñ¶,2] =U‚ä§
‚Ñ¶withU‚Ñ¶,1‚ààRdx√ó(dx+du),U‚Ñ¶,2‚ààRdu√ó(dx+du), and
Œ£‚àó= limŒµ‚Üí0(Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,1/hatwideUY/hatwideU‚ä§
YU‚Ñ¶,1Œ£‚Ñ¶+Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,2U‚Ñ¶,2Œ£‚Ñ¶+Œµ2In)‚àí1Œ£‚ä§
‚Ñ¶.
Proof sketch . This can be derived by plugging Ex=/hatwideU‚ä§
Yinto (14), and using the SVD definition and the
limit definition (Albert (1972)) of the Moore-Penrose inverse. The complete proof is given in appendix A.3
that uses some preliminary results presented in appendix A.2.
Remark. It can be verified easily that if we use the truncated SVD (as defined by 9), instead of the full
SVD, for ‚Ñ¶in corollary 4.1.1.1, we get an approximation of (15):
/hatwideAR=/hatwideU‚ä§
YY/hatwideV‚Ñ¶/hatwideŒ£‚àó/hatwideU‚ä§
‚Ñ¶,1/hatwideUY,and/hatwideBR=/hatwideU‚ä§
YY/hatwideV‚Ñ¶/hatwideŒ£‚àó/hatwideU‚ä§
‚Ñ¶,2, (16)
where/hatwideŒ£‚àó= limŒµ‚Üí0(/hatwideŒ£‚ä§
‚Ñ¶/hatwideU‚ä§
‚Ñ¶,1/hatwideUY/hatwideU‚ä§
Y/hatwideU‚Ñ¶,1/hatwideŒ£‚Ñ¶+/hatwideŒ£‚ä§
‚Ñ¶/hatwideU‚ä§
‚Ñ¶,2/hatwideU‚Ñ¶,2/hatwideŒ£‚Ñ¶+Œµ2Irxu)‚àí1/hatwideŒ£‚ä§
‚Ñ¶. We can see that (16) has
the same form as (10b), except /hatwideŒ£‚àí1
‚Ñ¶is replaced with /hatwideŒ£‚àó.
All the aforementioned results are derived for a fixed Exand the relation to the DMDc is specific to the
caseEx=/hatwideU‚ä§
Y. Note that the columns of the /hatwideUYare the left singular vectors, corresponding to the leading
singular values, of Y. Equivalently, those are also the eigenvectors, corresponding to the leading eigenvalues,
of the covariance matrix YY‚ä§.Lpredalone does not constrain Exto take a similar form and we need
another loss term to encourage such form for the encoder. To this end, we follow the work of Baldi & Hornik
(1989) on the similarity between principle component analysis and linear autoencoders, optimized with the
following objective function:
Lrecon(Ex,Dx) =1
nn/summationdisplay
i=1/vextenddouble/vextenddoublex(ti)‚àíDxExx(ti)/vextenddouble/vextenddouble2. (17)
They showed that all the critical points of Lreconcorrespond to projections onto subspaces associated with
subsets of eigenvectors of the covariance matrix YY‚ä§. Moreover, Lreconhas a unique global minimum
corresponding to the first rx(i.e., the desired dimension of the reduced state) number of eigenvectors of
YY‚ä§, associated with the leading rxeigenvalues. In other words, for any invertible matrix C‚ààRrx√órx,
Dx=UrxCandEx=C‚àí1U‚ä§
rxglobally minimizes Lrecon, whereUrxdenotes the matrix containing
leadingrxeigenvectors of YY‚ä§. Since the left singular vectors of Yare the eigenvectors of YY‚ä§, we have
Urx=/hatwideUY. Hence, we consider to utilize Lreconto promote learning an encoder Exin the form of C‚àí1/hatwideU‚ä§
Y.
7Under review as submission to TMLR
‚Ñ∞ùíô
‚Ñ∞ùíñ‚Ñ±State 
EncoderState 
Decoder
Control 
EncoderROMùíô(ùë°ùëñ) ùíôR(ùë°ùëñ)
ùíñ(ùë°ùëñ)‡∑ùùíôR(ùë°ùëñ+1)
ùíñR(ùë°ùëñ) ùíô(ùë°ùëñ+1)ùíüùíô‡∑ùùíô(ùë°ùëñ) ‚Ñírecon
‚Ñípred
‚Ñ∞ùíô
ùíôR(ùë°ùëñ+1)
Figure 2: Autoencoding architecture for reduced order modeling. The state encoder Exand control encoder
Eureduce the dimension of the state and actuation, respectively. The ROM Ftakes the current reduced
state and actuation to predict the next reduced state, which is then uplifted to the full state by the state
decoderDx. All modules are trained together using a combined loss involving LpredandLrecon. The dashed
arrow indicates that the Euis used only when du>>1; otherwise, the actuation is used as a direct input to
ROM.
Accordingly, we propose to minimize the following objective function to encourage a DMDc-like solution for
LAROM:
L(Ex,Dx,G) =Lpred(Ex,G) +Œ≤1Lrecon(Ex,Dx), (18)
whereŒ≤1>0is a tunable hyperparameter.
It is important to note that Lreconis minimized for any invertible matrix C,Dx=/hatwideUYC, andEx=C‚àí1/hatwideU‚ä§
Y.
When optimized using gradient descent, it is highly unlikely to get Cas the identity matrix like DMDc.
Rather, we expect a random C. Therefore, we need additional constraints to promote similarity with
DMDc. For this purpose, we tie the matrices ExandDxto be the transpose of each other and add a
semi-orthogonality constraint Œ≤4‚à•ExE‚ä§
x‚àíIrx‚à•,Œ≤4>0to the optimization objective of (18).
4.1.3 Extending the linear model to a deep model
Here, we discuss the process of extending LAROM to a nonlinear reduced order modeling framework. We
replace all the trainable components of LAROM, i.e., Ex,Dx, andG, with DNNs. Specifically, we use an
encoding function or encoderEx:X‚ÜíRrxand a decoding function or decoderDx:Rrx‚ÜíXto transform
the high-dimensional system state to low-dimensional features and reconstruct it back, respectively, i.e.,
xR=Ex(x),ÀÜx=Dx(xR), (19)
wherexR‚ààRrxdenotes the reduced state, and ÀÜxis the reconstruction of x. Unlike the linear case, we
use an encoderEu:U‚ÜíRru,ru<< d ufor the actuation as well, in cases where the control space is also
high-dimensional (for example, distributed control of spatiotemporal PDEs). The control encoder Eumaps
the high-dimensional actuation to a low-dimensional representation: uR=Eu(u), whereuR‚ààRrudenotes
the encoded actuation. The encoded state and control are then fed to another DNN that represents the
reduced order dynamics
dxR
dt=F(xR,uR), (20)
8Under review as submission to TMLR
whereF:Rrx√óRru‚ÜíRrx. Given the current reduced state xR(ti)and control input uR(ti), the next
reduced state xR(ti+1)can be computed by integrating Fusing standard numerical integrator or neural
ODE (Chen et al. (2018)):
xR(ti+1) =xR(ti) +/integraldisplayti+1
tiF/parenleftbig
xR(ti),uR(ti)/parenrightbig
dt‚àÜ=G/parenleftbig
xR(ti),uR(ti)/parenrightbig
. (21)
We can say thatGis the nonlinear counterpart of G.
Note, here the ROM is represented as a continuous-time dynamics, unlike the linear case where we used a
discrete-time model. We use a discrete-time formulation for LAROM to establish its similarity with DMDc,
which is formulated in discrete time. DeepROM can be formulated in a similar fashion as well. However, the
specific control learning algorithm we used, which will be discussed in the next subsection, requires vector
fields of the learned ROM for training. Therefore, we formulate the ROM in continuous time so that it
provides the vector field F(xR,uR)of the dynamics. In cases where only the prediction model is of interest
and control learning is not required, a discrete-time formulation should be used for faster training of the
ROM.
We trainEx,Eu,Dx, andFby minimizing the following loss function, analogous to (18),
L(Ex,Eu,Dx,F) =Lpred(Ex,Eu,F) +Œ≤2Lrecon(Ex,Dx), (22)
whereŒ≤2>0is a tunable hyperparameter and Lpred,Lreconare defined as follows,
Lpred(Ex,Eu,F) =1
nn‚àí1/summationdisplay
i=0/vextenddouble/vextenddouble/vextenddoubleEx/parenleftbig
x(ti+1)/parenrightbig
‚àíG/parenleftÔ£¨ig
Ex/parenleftbig
x(ti)/parenrightbig
,Eu/parenleftbig
u(ti)/parenrightbig/parenrightÔ£¨ig/vextenddouble/vextenddouble/vextenddouble2
,
Lrecon(Ex,Dx) =1
nn/summationdisplay
i=1/vextenddouble/vextenddoublex(ti)‚àíDx‚ó¶Ex/parenleftbig
x(ti)/parenrightbig/vextenddouble/vextenddouble2. (23)
Here, the operator ‚ó¶denotes the composition of two functions. In experiments, Lreconalso includes the
reconstruction loss of the desired state where we want to stabilize the system. Figure 2 shows the overall
framework for training DeepROM.
4.2 Learning control
Once we get a trained ROM of the form (20) using the method proposed in section 4.1, the next goal is
to design a controller for the system utilizing that ROM. Since our ROM is represented by DNNs, we need
a data-driven method to develop the controller. We adopt the approach presented by Saha et al. (2021)
for learning control law for nonlinear systems, represented by DNNs. The core idea of the method is to
hypothesize a target dynamics that is exponentially stable at the desired state and simultaneously learn a
control policy to realize that target dynamics in closed loop. A DNN is used to represent the vector field
Fs:Rrx‚ÜíRrxof the target dynamicsdxR
dt=Fs(xR). We use another DNN to represent a controller
Œ† :Rrx‚ÜíRduthat provides the necessary actuation for a given reduced state xR:
u= Œ†(xR). (24)
This controluis then encoded by (trained) Euto its low-dimensional representation uR. Finally, the reduced
statexRand actuation uRare fed to the (trained) ROM of (20) to get F(xR,uR). The overall framework
for learning control is shown in Figure 3.
Our training objective is to minimize the difference between F(xR,uR)andFs(xR), i.e.,
Lctrl(Fs,Œ†) =1
nn/summationdisplay
i=1/vextenddouble/vextenddoubleF/parenleftbig
Ex(x(ti)),Eu‚ó¶Œ†‚ó¶Ex(x(ti))/parenrightbig
‚àíFs‚ó¶Ex/parenleftbig
x(ti)/parenrightbig/vextenddouble/vextenddouble2. (25)
To minimize the control effort, we add a regularization loss with (25), and the overall training objective for
learning control is given by
Lctrl,reg (Fs,Œ†) =Lctrl(Fs,Œ†) +Œ≤31
nn/summationdisplay
i=1/vextenddouble/vextenddoubleŒ†(xR(ti))/vextenddouble/vextenddouble2, (26)
9Under review as submission to TMLR
‚Ñ∞ùíô
‚Ñ∞ùíñ‚Ñ±State 
Encoder
Control 
EncoderROM
Œ†
‚Ñ±ùë†
ùí±RùíôR‚Ñ±(ùíôR,ùíñR)
Controller
Target 
Dynamicsùíô ùíôR
ùíñ
ùíñR
‚Ñ±ùë†(ùíôR)
Lyapunov Function‚Ñíctrl
Figure 3: The control learning process. Given a reduced state, Fspredicts a target dynamics for the closed-
loop system, and the controller Œ†predicts an actuation to achieve that target. Both the modules are trained
jointly using the loss function Lctrl. Parameters of the dark-shaded modules are kept fixed during this
process.
whereŒ≤3>0is a tunable hyperparameter. Here we jointly train the DNNs representing Œ†andFsonly,
whereas the previously-trained DNNs for Ex,Eu, andFare kept frozen. Once all the DNNs are trained,
we only needExandŒ†during evaluation to generate actuation for the actual system, given a full-state
observation:
u= Œ†‚ó¶Ex(x) =œÄ(x). (27)
As we mentioned earlier, we require the target dynamics, hypothesized by a DNN, to be exponentially stable
at the desired state. Without loss of generality, we consider stability at xR=0. As we mentioned earlier, the
system can be stabilized at any desired state by adding a feedforward component to the control. Dynamics
represented by a standard neural network is not stable at any equilibrium point, in general. Kolter & Manek
(2019) showed that it is possible to design a DNN, by means of Lyapunov functions, to represent a dynamics
thatisexponentiallystableatanequilibriumpoint. Accordingly, werepresentourtargetdynamicsasfollows:
dxR
dt=Fs(xR) =P(xR)‚àíReLU/parenleftbig
‚àáVR(xR)‚ä§P(xR) +Œ±VR(xR)/parenrightbig
‚à•‚àáV R(xR)‚à•2‚àáVR(xR), (28)
whereŒ±is a positive constant, ReLU (z) = max(0,z), z‚ààR, andVR:Rrx‚ÜíRis a candidate Lyapunov
function, i.e., satisfies the criteria similar to (3) and (5). We use
VR(xR) =x‚ä§
RKx R, (29)
whereK‚ààRrx√órxis a positive definite matrix.
Though the efficacy of learning control by minimizing the difference with respect to a target dynamics is
experimentally demonstrated by Saha et al. (2021), the stability of the closed-loop system subjected to
the learned control law has not been studied analytically. Here, we present a result that shows that if we
can minimizeLctrlsuch that the difference between the target dynamics and the closed-loop dynamics is
sufficiently small for all xR‚ààXR‚äÇRrx, then the trajectories of the closed-loop ROM starting sufficiently
close to the origin remains close to the origin, i.e., ultimately bounded (Khalil (2002)). Boundedness of the
closed-loop ROM trajectories under the proposed control policy is a necessary but not sufficient requirement
for the stability of the original system.
10Under review as submission to TMLR
Theorem 4.2.1. Consider the target dynamics defined by (28)and the candidate Lyapunov function defined
by (29). Suppose the difference between the target dynamics and the closed-loop dynamics satisfies
‚à•F(xR,Eu‚ó¶Œ†(xR))‚àíFs(xR)‚à•‚â§Œ¥<Œ±Œ∏Œª min(K)
2Œªmax(K)/radicalÔ£¨igg
Œªmin(K)
Œªmax(K)Œ∑, (30)
for allxR‚ààXR={xR‚ààRrx| ‚à•xR‚à•< Œ∑}and 0< Œ∏ < 1. Then, for all initial points satisfying
‚à•xR(t0)‚à•</radicalÔ£¨ig
Œªmin(K)
Œªmax(K)Œ∑, the solution of the closed-loop ROMdxR
dt=F(xR,Eu‚ó¶Œ†(xR))satisfies
‚à•xR(t)‚à•‚â§Œªe‚àíŒ≥(t‚àít0)‚à•xR(t0)‚à•,‚àÄt0‚â§t<tc+t0 (31)
and
‚à•xR(t)‚à•‚â§2Œ¥
Œ±Œ∏Œª3,‚àÄt‚â•tc+t0 (32)
for some finite tc>0, where
Œ≥=Œ±(1‚àíŒ∏)Œªmin(K)
2Œªmax(K)andŒª=/radicalÔ£¨igg
Œªmax(K)
Œªmin(K)(33)
Proof Sketch. This can be proved by first deriving the Lyapunov conditions for the target dynamics (28)
(Theorem 1, Kolter & Manek (2019)) and then applying the stability analysis of perturbed systems (Lemma
9.2, Khalil (2002)) and ultimate boundedness (Theorem 4.18, Khalil (2002)) on the closed-loop ROM. A
unified proof is provided in appendix A.6.
5 Empirical Results
For empirical analysis, we consider modeling and controlling spatiotemporal PDE-driven systems with high-
dimensional measurements over discretized space. One of the primary applications of reduced order modeling
liesincomprehendingthebehaviorofcomplexphysicalprocesseswhicharetypicallycharacterizedbysystems
of PDEs. Since spatiotemporal PDE-driven systems are infinite-dimensional in their continuous form and
high-dimensional when discretized, they are a fitting choice for evaluating our method. The first example
investigates a single variable actuation, whereas distributed actuation is considered for the second example.
5.1 Baselines
ThesimilaritybetweenDMDcandLAROMisdemonstratedusingthedynamicmodesestimatedinrespective
methods. The prediction performance of DeepROM is compared against DMDc and the Deep Koopman
model(Mortonetal.(2018)). TheDeepKoopmanmodelsharesasimilarDNN-basedautoencodingstructure
as ours, with the distinction that its (reduced order) dynamic model is linear. The method proposed by
Morton et al. (2018) considers a model predictive scenario, where the state/system matrix of the linear
reduced order model is updated with online observations during operation while the input/control matrix
is kept fixed. However, in contrast to the original method, we keep both matrices fixed during operation
(once those are trained) as we consider offline control design in this paper. For the same reason, we apply
linear quadratic regulator (LQR) on the ROM obtained from the Deep Koopman method, instead of model
predictivecontrol, tocomparethecontrolperformancewithourmethod: DeepROC.Thecontrolperformance
is also compared against the reduced order controller obtained by applying LQR on the ROM derived from
DMDc.
Details on the neural network architectures and training settings for the Deep Koopman model are given in
appendix D.
11Under review as submission to TMLR
5.2 Reaction‚Äìdiffusion system stabilization
For the first experiment, we consider the Newell‚ÄìWhitehead‚ÄìSegel reaction-diffusion equation with the Neu-
mann boundary condition
‚àÇq
‚àÇt=œÉ‚àá2q+q(1‚àíq2) +1WwinI√óR+,
‚àáq(Œ∂l,t) =‚àáq(Œ∂r,t) = 0, t‚ààR+, (34)
which is used to describe various nonlinear physical systems including Rayleigh‚ÄìB√©nard convection. This
example is used by Kalise & Kunisch (2018) to evaluate nonlinear controllers designed from reduced order
state space representation. Similar systems are used for modeling problems as well in 1D (Raissi et al. (2019))
and 2D (Li et al. (2020)). In (34), q(Œ∂,t)‚ààRdenotes the measurement variable such as concentration or
temperature at location Œ∂‚ààI‚äÇRand timet;œÉdenotes the diffusion coefficient; w(t)‚ààRis the actuation
at timetand1W(Œ∂)is the indicator function with W‚äÇI;Œ∂landŒ∂rdenote the boundary points of I.
(34) is a bistable system with ¬±1as stable and 0as unstable equilibria. For the control task, we consider
feedback stabilization of (34) at the unstable equilibrium 0, as studied by Kalise & Kunisch (2018). We use
I= (‚àí1,1),W= (‚àí0.2,0.2), andœÉ= 0.2. Details on dataset generation, neural network architectures, and
training settings are given in appendix B.
5.2.1 Similarity with DMDc
To investigate the similarity DMDc, we first train the LAROM using gradient descent to minimize the
objective (18) with the semi-orthogonality regularization and enforcing Dx=E‚ä§
x, as discussed in 4.1.2.
The dynamic modes for LAROM are computed as œÜi=Dxzi, whereziis theitheigenvector of AR.
Similarly, the dynamic modes for DMDc are computed as œÜi,DMDc =DDMDczi,DMDc, wherezi,DMDcis
theitheigenvector of AR,DMDc. Note, these dynamic modes are similar to the ones used in the original
DMD algorithm Schmid (2010), not the exact modes obtained in Proctor et al. (2016). Exact modes cannot
be computed for LAROM since it does not involve SVD. Modes defined by œÜi,DMDc =DDMDczi,DMDc =
/hatwideUYzi,DMDcare the orthogonal projection of the exact modes onto the range of Y(Theorem 3, Tu et al.
(2014)). Figure 4 compares the dynamic modes obtained using DMDc and LAROM for the case when the
dimension of the ROMs is 3. It is important to note that the numbering of the modes is arbitrary as the
optimal ranking of DMDc modes is not trivial. The correspondence between the DMDc modes and LAROM
modes are determined by comparing the eigenvalues of AR,DMDcandAR. Dynamic modes of both methods
are similar except for the different signs of the first two modes.
DMDc dynamic modes LAROM dynamic modes
Figure 4: The first three dynamic modes of the reaction‚Äìdiffusion system, obtained using DMDc and
LAROM.
5.2.2 Prediction performance of DeepROM
We now compare the performance of DeepROM, Deep Koopman model, and DMDc in the prediction task.
Note, this example uses low-dimensional actuation (just a single variable). Accordingly, the control encoder
12Under review as submission to TMLR
Prediction error
DMDc prediction
(Proctor et al. (2016))
DeepROM prediction
PDE solution
Deep Koopman prediction
(Morton et al. (2018))
Figure 5: Prediction performance of DMDc, Deep Koopman, and DeepROM in the reaction‚Äìdiffusion exam-
ple. The prediction error plot shows the mean error and 95%confidence interval from 100test sequences and
for Deep Koopman and DeepROM, 3different training instances. One example sequence is used to visually
compare the predictions with the solution from a PDE solver.
Euis not used here. Figure 5 shows the quantitative and qualitative comparison of the recursive multi-step
predictions obtained using DMDc, Deep Koopman model, and DeepROM. The prediction error is computed
asnormalized mean squared error (NMSE) with respect to the solution obtained using the PDE solver. The
prediction error plot shows the mean error and 95%confidence interval from 100test sequences and for
Deep Koopman and DeepROM, 3different training instances. The color maps are shown for one example
sequence with one training instance. Prediction error increases more quickly for DMDc and Deep Koopman
than DeepROM as the linear ROMs become less accurate in the long term.
5.2.3 Control performance of DeepROC
Figure 6 shows the control performance of DeepROC, Deep Koopman + LQR, and DMDc + LQR in the
task of stabilizing the system at the unstable equilibrium 0 from an initial state 2 + cos(2œÄŒ∂) cos(œÄŒ∂). We
use the following metrics for comparison:
(i) mean squared error over time between the controlled solutions and the desired profile
(ii) differential magnitude that measures the differential changes between the profiles at consecutive time
steps. In the steady state, the differential magnitude should be close to zero.
(iii) the amount of actuation applied
For Deep Koopman and DeepROC, the plots show the mean values with 1-standard deviation interval from
3training instances. All methods show similar closed-loop error profiles. However, DeepROC requires
significantly less amount of actuation in comparison with DMDc + LQR and Deep Koopman + LQR to
reach a similar steady-state error. DeepROC can account for the decaying nonlinear term ‚àíq3present in
the system (34) and therefore learns to apply less actuation. Figure 7 visually compares the uncontrolled
solution and the controlled solutions obtained using the three methods. When uncontrolled, the system
reaches the stable equilibrium at 1, whereas the feedback-controlled system is stabilized at the desired state
0in both cases.
13Under review as submission to TMLR
Error with respect to desired profile Differential magnitude Actuation
Figure 6: Control performance of DMDc + LQR, Deep Koopman + LQR, and DeepROC in the reac-
tion‚Äìdiffusion example. For Deep Koopman and DeepROC, the plots show the mean values with 1-standard
deviation interval from 3training instances.
Uncontrolled solutionDeepROC
controlled solution
DMDc + LQR
(Proctor et al. (2016))
controlled solution
Deep Koopman + LQR
(Morton et al. (2018))
controlled solution 
Figure 7: Visual comparison of the uncontrolled solution and the controlled solutions using DeepROC, Deep
Koopman + LQR, and DMDc + LQR.
5.3 Vortex shedding suppression in fluid
In this experiment, we consider modeling and suppressing vortex shedding in two-dimensional incompressible
flow past a circular cylinder. This is a well-known problem (Sch√§fer et al. (1996)) and is of great importance
for many engineering applications (Williamson (1996)). Several previous studies on deep learning-based
modeling and control have used this system for evaluation (Eivazi et al. (2020); Erichson et al. (2019);
Rabault et al. (2019); Tang et al. (2020); Bieker et al. (2020); Morton et al. (2018)). The dynamics is
governed by the incompressible Navier-Stokes equations given by
‚àÇv
‚àÇt‚àíŒΩ‚àá2v+ (v¬∑‚àá)v=‚àí1
œÅ‚àáp+1Ww,‚àá¬∑v=0inI√óR+, (35)
14Under review as submission to TMLR
wherev(Œ∂,t)‚ààR2denotes the flow velocity at location Œ∂‚ààI‚äÇR2and timet,p(Œ∂,t)‚ààRdenotes the pres-
sure,ŒΩdenotes the kinematic viscosity and œÅdenotes the density of the fluid. w(Œ∂,t)is the actuation/force
applied to the system and 1W(Œ∂)is the indicator function with W‚äÇI. We use I= (0,2.2)√ó(0,0.41)and
W= (0.11,0.77)√ó(0,0.41). Density and kinematic viscosity are chosen such that the Reynolds number is
Re= 50, which is just above the cutoff for the onset of the vortex shedding (Williamson (1996)). In this
case, vortices are created at the back of the cylinder and are shed periodically from the upper and lower
surfaces of the cylinder forming a von K√°rm√°n vortex street (Morton et al. (2018)). We use the domain W
for observation and distributed actuation. The Stokes flow is used as the desired state for the control task.
More details on the problem setup, dataset generation, neural network architectures, and training settings
are given in appendix C.
5.3.1 Similarity with DMDc
To analyze the dynamic modes, we train the LAROM by enforcing Dx=E‚ä§
xand adding the semi-
orthogonality constraint to the learning objective, as mentioned in 4.1.2. Figure 8 compares the first two
oscillatory dynamic modes obtained using DMDc and LAROM. Only the streamwise components are shown
for brevity. Also, complex modes occur in conjugate pairs and only one from each pair is shown. The cor-
respondence between the DMDc modes and LAROM modes are determined by comparing the eigenvalues
ofAR,DMDcandAR. Dynamic modes identified by LAROM are similar to the ones obtained from DMDc,
except the real and imaginary components of the first mode are swapped.
DMDc mode 1 LAROM mode 1 DMDc mode 2 LAROM mode 2Real Imaginary
Figure 8: The first two dynamic modes obtained using DMDc and LAROM for the flow past a cylinder
system.
5.3.2 Prediction performance of DeepROM
Figure 9 shows the quantitative and qualitative comparison of the recursive multi-step predictions, starting
fromt= 0.1, obtained using DMDc, Deep Koopman model, and DeepROM. The initial state is chosen at
t= 0.1because the fluid does not reach the observation region Wbefore that time. The prediction error is
computed as the mean squared error (MSE) with respect to the solution obtained using a PDE solver. For
Deep Koopman and DeepROM, the prediction error plot shows the mean error and 1-standard deviation
interval from 3training instances. DeepROM shows lower prediction error in comparison with DMDc. The
Deep Koopman model shows better prediction performance than DeepROM and DMDc during the initial
few steps. However, its accuracy deteriorates rapidly and eventually becomes comparable to that of DMDc.
Moreover, unlike DeepROM, DMDc and Deep Koopman model are unable to capture the shedding pattern
in multi-step prediction as shown in the contour plots of the velocity magnitude.
5.3.3 Control performance of DeepROC
Figure 10 shows the control performance of DeepROC, Deep Koopman + LQR, and DMDc+LQR in the task
of suppressing vortex shedding. The controllers of DeepROC and DMDc + LQR directly estimate the high-
15Under review as submission to TMLR
Prediction error
PDE solution at step 2500
DMDc (Proctor et al. (2016)) 
prediction at step 2500DeepROM prediction at step 2500
Deep Koopman (Morton et al. (2018))
prediction at step 2500
Figure 9: Prediction performance of DMDc, Deep Koopman, and DeepROM in the fluid flow example. For
Deep Koopman and DeepROM, the prediction error plot shows the mean error and 1-standard deviation
interval from 3training instances. Predictions at time step 2500for the test sequence are visually compared
with the solution from a PDE solver. vmdenotes the velocity magnitude.
dimensional actuation distributed over space. However, the same technique proved ineffective in suppressing
the shedding for Deep Koopman + LQR. Therefore, instead of directly estimating the distributed actuation,
we utilize a low-dimensional representation of the actuation for Deep Koopman + LQR. We represent the
distributed actuation as a linear combination of some space-dependent sinusoidal basis functions. The
controller is designed to estimate the coefficients of those basis functions in the linear combination. Details
are provided in appendix D.
We use the same metrics as the previous example for comparison except for actuation. Since distributed
control is applied in this case, we use the magnitude of the actuation here. For DeepROC and Deep Koopman
+ LQR, the plots show the mean values with 1-standard deviation interval from 3training instances. To
reach a similar steady-state error, DeepROC takes a longer time compared to DMDc and Deep Koopman
+ LQR. DeepROM uses the least amount of actuation during the initial few steps, whereas Deep Koopman
+ LQR has the least steady-state actuation magnitude. Figure 11 shows the velocity magnitude of the
controlled flow for DeepROC, Deep Koopman + LQR, and DMDc+LQR at different times, starting from a
von K√°rm√°n vortex street pattern. All methods accomplish a similar steady-state flow pattern where vortex
shedding has been suppressed.
6 Conclusion
We presented a framework for autoencoder-based modeling and control learning for high-dimensional dy-
namical systems. We showed that autoencoding ROMs are capable of capturing the dominant modes that
are essential in analyzing and designing control for the underlying systems. As we showed in experiments,
DeepROM offers better prediction accuracy than a linear ROM over a relatively longer prediction horizon
when applied to nonlinear systems. However, this advantage does not always translate to significant im-
provement in control performance. Though the used control learning method theoretically ensures ultimate
boundedness for the closed-loop ROM solution, data-driven optimization of the learning objective often
makes the models susceptible to distribution shift which can impact the control performance. The control
learning process in the DeepROC framework can easily be replaced with other methods like model-based RL
or model predictive control. It would be interesting for future work to investigate whether updating both
the reduced model and the controller in the MPC framework ensures robustness under distribution shift and
16Under review as submission to TMLR
Error with respect to desired profile Differential magnitude Actuation magnitude
Figure 10: Control performance of DMDc + LQR, Deep Koopman + LQR, and DeepROC in the vortex
shedding suppression task. For Deep Koopman + LQR and DeepROC, the plots show the mean values with
1-standard deviation interval from 3training instances.
ùë°=0.5 ùë°=1.0 ùë°=6.0
ùë°=0.0
DeepROCDMDc + LQR
(Proctor et al. (2016 ))
Deep Koopman + LQR
(Morton et al. (2018))
Figure 11: Visual comparison of the velocity magnitude of the flow over time subjected to the controllers
obtained using DeepROC, Deep Koopman + LQR, and DMDc + LQR.
offers better control performance. Designing controllers for DNN-based models is a challenging task due to
the standard difficulties associated with non-convex optimization. Nevertheless, we envision great prospects
in solving many problems of control design for high-dimensional systems utilizing autoencoder-based models
as they continue to demonstrate their effectiveness in the analysis and prediction of such systems.
17Under review as submission to TMLR
References
Arthur Albert. Regression and the Moore-Penrose Pseudoinverse . Academic Press, 1972.
Jeanne A Atwell, Jeffrey T Borggaard, and Belinda B King. Reduced order controllers for burgers‚Äô equation
with a nonlinear observer. International Journal of Applied Mathematics and Computer Science , 11(6):
1311‚Äì1330, 2001.
Ibrahim Ayed, Emmanuel de B√©zenac, Arthur Pajot, Julien Brajard, and Patrick Gallinari. Learning dy-
namical systems from partial observations. arXiv preprint arXiv:1902.11136 , 2019.
Pierre Baldi and Kurt Hornik. Neural networks and principal component analysis: Learning from examples
without local minima. Neural networks , 2(1):53‚Äì58, 1989.
Gerben Beintema, Alessandro Corbetta, Luca Biferale, and Federico Toschi. Controlling rayleigh‚Äìb√©nard
convection via reinforcement learning. Journal of Turbulence , 21(9-10):585‚Äì605, 2020.
Katharina Bieker, Sebastian Peitz, Steven L Brunton, J Nathan Kutz, and Michael Dellnitz. Deep model
predictive flow control with limited sensor data and online learning. Theoretical and computational fluid
dynamics , 34:577‚Äì591, 2020.
Oumayma Bounou, Jean Ponce, and Justin Carpentier. Online learning and control of dynamical systems
from sensory input. In NeurIPS 2021-Thirty-fifth Conference on Neural Information Processing Systems
Year, 2021.
Kaixuan Chen, Jin Lin, Yiwei Qiu, Feng Liu, and Yonghua Song. Deep learning-aided model predictive
control of wind farms for agc considering the dynamic wake effect. Control Engineering Practice , 116:
104925, 2021.
Ricky TQ Chen, Yulia Rubanova, Jesse Bettencourt, and David K Duvenaud. Neural ordinary differential
equations. Advances in neural information processing systems , 31, 2018.
Emmanuel De B√©zenac, Arthur Pajot, and Patrick Gallinari. Deep learning for physical processes: Incor-
porating prior scientific knowledge. Journal of Statistical Mechanics: Theory and Experiment , 2019(12):
124009, 2019.
J√©r√©mie Don√†, Jean-Yves Franceschi, Sylvain Lamprier, and Patrick Gallinari. Pde-driven spatiotemporal
disentanglement. arXiv preprint arXiv:2008.01352 , 2020.
Hamidreza Eivazi, Hadi Veisi, Mohammad Hossein Naderi, and Vahid Esfahanian. Deep neural networks for
nonlinear model order reduction of unsteady flows. Physics of Fluids , 32(10):105104, 2020.
N Benjamin Erichson, Michael Muehlebach, and Michael W Mahoney. Physics-informed autoencoders for
lyapunov-stable fluid flow prediction. arXiv preprint arXiv:1905.10866 , 2019.
Paul Garnier, Jonathan Viquerat, Jean Rabault, Aur√©lien Larcher, Alexander Kuhnle, and Elie Hachem. A
review on deep reinforcement learning for fluid mechanics. Computers & Fluids , 225:104973, 2021.
Philipp Holl, Nils Thuerey, and Vladlen Koltun. Learning to control pdes with differentiable physics. In
International Conference on Learning Representations , 2020.
Jer-Nan Juang and Richard S Pappa. An eigensystem realization algorithm for modal parameter identifica-
tion and model reduction. Journal of guidance, control, and dynamics , 8(5):620‚Äì627, 1985.
Jer-Nan Juang, Minh Phan, Lucas G Horta, and Richard W Longman. Identification of observer/kalman
filter markov parameters-theory and experiments. Journal of Guidance, Control, and Dynamics , 16(2):
320‚Äì329, 1993.
Dante Kalise and Karl Kunisch. Polynomial approximation of high-dimensional hamilton‚Äìjacobi‚Äìbellman
equations and applications to feedback control of semilinear parabolic pdes. SIAM Journal on Scientific
Computing , 40(2):A629‚ÄìA652, 2018.
18Under review as submission to TMLR
Hassan K. Khalil. Nonlinear systems . Prentice Hall, third edition, 2002.
Mohammad Amin Khodkar, Pedram Hassanzadeh, and Athanasios Antoulas. A koopman-based framework
for forecasting the spatiotemporal evolution of chaotic dynamics with nonlinearities modeled as exogenous
forcings. arXiv preprint arXiv:1909.00076 , 2019.
J Zico Kolter and Gaurav Manek. Learning stable deep dynamics models. Advances in neural information
processing systems , 32, 2019.
Ian Lenz, Ross A Knepper, and Ashutosh Saxena. Deepmpc: Learning deep latent features for model
predictive control. In Robotics: Science and Systems , volume 10. Rome, Italy, 2015.
Angran Li, Ruijia Chen, Amir Barati Farimani, and Yongjie Jessica Zhang. Reaction diffusion system
prediction based on convolutional neural network. Scientific reports , 10(1):3894, 2020.
Anders Logg, Kent-Andre Mardal, and Garth Wells. Automated solution of differential equations by the
finite element method: The FEniCS book , volume 84. Springer Science & Business Media, 2012.
Zichao Long, Yiping Lu, Xianzhong Ma, and Bin Dong. Pde-net: Learning pdes from data. In International
Conference on Machine Learning , pp. 3208‚Äì3216. PMLR, 2018.
Bethany Lusch, J Nathan Kutz, and Steven L Brunton. Deep learning for universal linear embeddings of
nonlinear dynamics. Nature communications , 9(1):4950, 2018.
Pingchuan Ma, Yunsheng Tian, Zherong Pan, Bo Ren, and Dinesh Manocha. Fluid directed rigid body
control using deep reinforcement learning. ACM Transactions on Graphics (TOG) , 37(4):1‚Äì11, 2018.
Jan R Magnus and Heinz Neudecker. Symmetry, 0-1 matrices and jacobians: A review. Econometric Theory ,
2(2):157‚Äì190, 1986.
George Matsaglia and George PH Styan. Equalities and inequalities for ranks of matrices. Linear and
multilinear Algebra , 2(3):269‚Äì292, 1974.
Jeremy Morton, Antony Jameson, Mykel J Kochenderfer, and Freddie Witherden. Deep dynamical modeling
and control of unsteady fluid flows. Advances in Neural Information Processing Systems , 31, 2018.
Zuowei Ping, Zhun Yin, Xiuting Li, Yefeng Liu, and Tao Yang. Deep koopman model predictive control for
enhancing transient stability in power grids. International Journal of Robust and Nonlinear Control , 31
(6):1964‚Äì1978, 2021.
Joshua L Proctor, Steven L Brunton, and J Nathan Kutz. Dynamic mode decomposition with control. SIAM
Journal on Applied Dynamical Systems , 15(1):142‚Äì161, 2016.
Jean Rabault, Miroslav Kuchta, Atle Jensen, Ulysse R√©glade, and Nicolas Cerardi. Artificial neural networks
trained through deep reinforcement learning discover control strategies for active flow control. Journal of
fluid mechanics , 865:281‚Äì302, 2019.
Maziar Raissi. Deep hidden physics models: Deep learning of nonlinear partial differential equations. The
Journal of Machine Learning Research , 19(1):932‚Äì955, 2018.
Maziar Raissi, Paris Perdikaris, and George E Karniadakis. Physics-informed neural networks: A deep learn-
ing framework for solving forward and inverse problems involving nonlinear partial differential equations.
Journal of Computational physics , 378:686‚Äì707, 2019.
Xiaoli Ren, Xiaoyong Li, Kaijun Ren, Junqiang Song, Zichen Xu, Kefeng Deng, and Xiang Wang. Deep
learning-based weather prediction: a survey. Big Data Research , 23:100178, 2021.
ClarenceWRowley, IgorMeziƒá, ShervinBagheri, PhilippSchlatter, andDanSHenningson. Spectralanalysis
of nonlinear flows. Journal of fluid mechanics , 641:115‚Äì127, 2009.
19Under review as submission to TMLR
Priyabrata Saha, Magnus Egerstedt, and Saibal Mukhopadhyay. Neural identification for control. IEEE
Robotics and Automation Letters , 6(3):4648‚Äì4655, 2021.
Michael Sch√§fer, Stefan Turek, Franz Durst, Egon Krause, and Rolf Rannacher. Benchmark computations
of laminar flow around a cylinder . Springer, 1996.
Sebastian Scher. Toward data-driven weather and climate forecasting: Approximating a simple general
circulation model with deep learning. Geophysical Research Letters , 45(22):12‚Äì616, 2018.
Peter J Schmid. Dynamic mode decomposition of numerical and experimental data. Journal of fluid me-
chanics, 656:5‚Äì28, 2010.
Sungyong Seo, Chuizheng Meng, and Yan Liu. Physics-aware difference graph networks for sparsely-observed
dynamics. In International Conference on Learning Representations , 2019.
EduardoDSontag. Mathematical control theory: deterministic finite dimensional systems ,volume6. Springer
Science & Business Media, 2013.
Prem A Srinivasan, L Guastoni, Hossein Azizpour, PHILIPP Schlatter, and Ricardo Vinuesa. Predictions
of turbulent shear flows using deep neural networks. Physical Review Fluids , 4(5):054603, 2019.
Tetsuya Takahashi, Junbang Liang, Yi-Ling Qiao, and Ming C Lin. Differentiable fluids with solid coupling
for learning and control. In Proceedings of the AAAI Conference on Artificial Intelligence , volume 35(7),
pp. 6138‚Äì6146, 2021.
Naoya Takeishi, Yoshinobu Kawahara, and Takehisa Yairi. Learning koopman invariant subspaces for dy-
namic mode decomposition. Advances in neural information processing systems , 30, 2017.
Hongwei Tang, Jean Rabault, Alexander Kuhnle, Yan Wang, and Tongguang Wang. Robust active flow con-
trol over a range of reynolds numbers using an artificial neural network trained through deep reinforcement
learning. Physics of Fluids , 32(5):053605, 2020.
Jonathan H. Tu, , Clarence W. Rowley, Dirk M. Luchtenburg, Steven L. Brunton, and J. Nathan Kutz and.
On dynamic mode decomposition: Theory and applications. Journal of Computational Dynamics , 1(2):
391‚Äì421, 2014. doi: 10.3934/jcd.2014.1.391.
KarenWillcoxandJaimePeraire. Balancedmodelreductionviatheproperorthogonaldecomposition. AIAA
journal, 40(11):2323‚Äì2330, 2002.
Charles HK Williamson. Vortex dynamics in the cylinder wake. Annual review of fluid mechanics , 28(1):
477‚Äì539, 1996.
SHI Xingjian, Zhourong Chen, Hao Wang, Dit-Yan Yeung, Wai-Kin Wong, and Wang-chun Woo. Convo-
lutional lstm network: A machine learning approach for precipitation nowcasting. In Advances in neural
information processing systems , pp. 802‚Äì810, 2015.
Yuting Yang, Junyu Dong, Xin Sun, Estanislau Lima, Quanquan Mu, and Xinhua Wang. A cfcc-lstm model
for sea surface temperature prediction. IEEE Geoscience and Remote Sensing Letters , 15(2):207‚Äì211,
2017.
Enoch Yeung, Soumya Kundu, and Nathan Hodas. Learning deep neural network representations for koop-
man operators of nonlinear dynamical systems. In 2019 American Control Conference (ACC) , pp. 4832‚Äì
4839. IEEE, 2019.
RuiyangZhang, YangLiu, andHaoSun. Physics-informedmulti-lstmnetworksformetamodelingofnonlinear
structures. Computer Methods in Applied Mechanics and Engineering , 369:113226, 2020.
20Under review as submission to TMLR
Appendices
A Proofs
This section details the proofs for the results presented in section 4. The proof of theorem 4.1.1 uses the
followingpropertiesoftherank(denotedbyrank (¬∑)),theKroneckerproduct(denotedby ‚äó)andvectorization
of matrices (denoted by vec (¬∑)). All the definitions and properties are presented in the context of matrices
over real numbers.
For any conformable matrices DandEsuch thatEhas full row-rank,
rank(DE) =rank(D). (36a)
For any real matrix D,
rank(D‚ä§D) =rank(DD‚ä§) =rank(D‚ä§) =rank(D). (36b)
For any matrices (of compatible dimensions) D,E,F,andH,
vec(DEF‚ä§) = (F‚äóD)vec(E), (37a)
(D‚äóE)‚ä§=D‚ä§‚äóE‚ä§, (37b)
(D‚äóE)(F‚äóH) = (DF‚äóEH), (37c)
whenever these quantities are defined. Furthermore, if DandEare symmetric and positive semidefinite
(resp. positive definite), then D‚äóEis symmetric and positive semidefinite (resp. positive definite), i.e.,
D‚™∞0,E‚™∞0 =‚áí(D‚äóE)‚™∞0;D‚âª0,E‚âª0 =‚áí(D‚äóE)‚âª0. (37d)
Proofs of (36) and (37) can be found in (Matsaglia & PH Styan (1974)) and (Magnus & Neudecker (1986)),
respectively.
To derive the results presented in corollary (4.1.1.1), we use the following definitions of the Moore-Penrose
inverse of a matrix (denoted by (¬∑)+). For any matrix Dand its (full) SVD, i.e., D=UDŒ£DV‚ä§
D,
D+= (D‚ä§D)‚àí1D‚ä§,when (D‚ä§D)‚àí1exists, (38a)
D+=D‚ä§(DD‚ä§)‚àí1,when (DD‚ä§)‚àí1exists, (38b)
D+=VDŒ£+
DU‚ä§
D, (38c)
D+= lim
Œµ‚Üí0(D‚ä§D+Œµ2I)‚àí1D‚ä§= lim
Œµ‚Üí0D‚ä§(DD‚ä§+Œµ2I)‚àí1, (38d)
whereIis the identity matrix of compatible dimension. The proof of (38d) can be found in (Albert (1972)).
To prove Theorem 4.1.1, we use some well-known results, summarized as the following lemma in (Baldi &
Hornik (1989)), for linear least-squares optimization.
Lemma A.0.1. The quadratic function L(z) =‚à•y‚àíMz‚à•2=y‚ä§y‚àí2y‚ä§Mz+z‚ä§M‚ä§Mzis convex, and
a pointzglobally minimizes Lif and only if‚àáL(z) = 0, or equivalently, M‚ä§Mz =M‚ä§y. Furthermore,
ifM‚ä§M‚âª0, i.e., positive definite, then Lis strictly convex and reaches its unique minimum for z=
(M‚ä§M)‚àí1M‚ä§y.
A.1 Proof of theorem 4.1.1
Theorem 4.1.1. Consider the following objective function
Lpred(Ex,G) =1
nn‚àí1/summationdisplay
i=0/vextenddouble/vextenddoubleExx(ti+1)‚àíGExuœâ(ti)/vextenddouble/vextenddouble2, (12)
21Under review as submission to TMLR
whereG= [ARBR]‚ààRrx√ó(rx+du),Exu=/bracketleftbiggEx0
0Idu/bracketrightbigg
‚ààR(rx+du)√ó(dx+du),Idubeing the identity matrix
of orderdu. For any fixed matrix Ex, the objective function Lpredis convex in the coefficients of Gand
attains its minimum for any Gsatisfying
GExu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu=ExY‚Ñ¶‚ä§E‚ä§
xu, (13)
whereYand‚Ñ¶are the data matrices as defined in section (3.3). If Exhas full rank rx, and‚Ñ¶‚Ñ¶‚ä§is
non-singular, then Lpredis strictly convex and has a unique minimum for
G= [ARBR] =ExY‚Ñ¶‚ä§E‚ä§
xu(Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu)‚àí1. (14)
Proof. We can write Lpred(Ex,G)as follows,
Lpred(Ex,G) =1
nn‚àí1/summationdisplay
i=0/vextenddouble/vextenddoubleExx(ti+1)‚àíGExuœâ(ti)/vextenddouble/vextenddouble2
=/vextenddouble/vextenddoublevec(ExY)‚àívec(GExu‚Ñ¶)/vextenddouble/vextenddouble2
=/vextenddouble/vextenddoublevec(ExY)‚àí(‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)vec(G)/vextenddouble/vextenddouble2. (39)
The third equality is obtained using (37a). For fixed Ex, we can apply Lemma A.0.1 to (39): (39) is convex
in coefficient of G, andGcorresponds to a global minimum of Lpredif and only if
(‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)‚ä§(‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)vec(G) = (‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)‚ä§vec(ExY). (40)
Using (37b) and (37c), we can write (40) as
(Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)vec(G) = (Exu‚Ñ¶‚äóIrx)vec(ExY). (41)
Applying (37a) on (41), we get GExu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu=ExY‚Ñ¶‚ä§E‚ä§
xu, i.e., (13).
IfExhas full rank rx, thenExu=/bracketleftbiggEx0
0Idu/bracketrightbigg
‚ààR(rx+du)√ó(dx+du)has full rank (rx+du). If‚Ñ¶‚Ñ¶‚ä§‚àà
R(dx+du)√ó(dx+du)is non-singular, then ‚Ñ¶has full row-rank (dx+du). Consequently, using (36a) and (36b),
we have
rank(Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu) =rank(Exu‚Ñ¶) =rank(Exu) =rx+du. (42)
Hence the symmetric positive semidefinite matrix Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xuhas full rank and therefore positive definite.
Using (37b), (37c), and (37d), we can see that (‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)‚ä§(‚Ñ¶‚ä§E‚ä§
xu‚äóIrx) = (Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)is
positive definite as well. Therefore, by Lemma A.0.1, (39) is strictly convex in the coefficients of Gand has
a unique minimum. Since Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu‚âª0, it is invertible. Hence, from (13), we can say that the unique
minimum of (39) is reached at G=ExY‚Ñ¶‚ä§E‚ä§
xu(Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu)‚àí1, i.e., (14). ‚ñ†
A.2 An alternative representation of (14)
Here we provide a possible alternative representation of (14) required to prove corollary 4.1.1.1.
Lemma A.2.1. Consider the (full) SVD of the data matrix ‚Ñ¶given by ‚Ñ¶=U‚Ñ¶Œ£‚Ñ¶V‚ä§
‚Ñ¶, whereU‚Ñ¶‚àà
R(dx+du)√ó(dx+du),Œ£‚Ñ¶‚ààR(dx+du)√ón, andV‚Ñ¶‚ààRn√ón. (14) can be expressed as
G= lim
Œµ‚Üí0ExYV‚Ñ¶(Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xuExuU‚Ñ¶Œ£‚Ñ¶+Œµ2In)‚àí1Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu. (43)
Proof. Replacing ‚Ñ¶with its SVD in (14) we get,
G=ExYV‚Ñ¶Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu(ExuU‚Ñ¶Œ£‚Ñ¶V‚ä§
‚Ñ¶V‚Ñ¶Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu)‚àí1
=ExYV‚Ñ¶Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu(ExuU‚Ñ¶Œ£‚Ñ¶Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu)‚àí1
=ExYV‚Ñ¶(ExuU‚Ñ¶Œ£‚Ñ¶)+(44)
22Under review as submission to TMLR
The second equality is due to the orthogonality of V‚Ñ¶. The third equality is obtained using (38b). Substi-
tuting (ExuU‚Ñ¶Œ£‚Ñ¶)+with the limit definition (38d) of the Moore-Penrose inverse, we get
G= lim
Œµ‚Üí0ExYV‚Ñ¶(Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xuExuU‚Ñ¶Œ£‚Ñ¶+Œµ2In)‚àí1Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu. (45)
‚ñ†
A.3 Proof of Corollary 4.1.1.1
Corollary 4.1.1.1. Consider the (full) SVD of the data matrix ‚Ñ¶given by ‚Ñ¶=U‚Ñ¶Œ£‚Ñ¶V‚ä§
‚Ñ¶, whereU‚Ñ¶‚àà
R(dx+du)√ó(dx+du),Œ£‚Ñ¶‚ààR(dx+du)√ón, andV‚Ñ¶‚ààRn√ón. IfEx=/hatwideU‚ä§
Yand‚Ñ¶‚Ñ¶‚ä§is non-singular, then the
solution forG= [ARBR]corresponding to the unique minimum of Lpredcan be expressed as
AR=/hatwideU‚ä§
YYV‚Ñ¶Œ£‚àóU‚ä§
‚Ñ¶,1/hatwideUY,andBR=/hatwideU‚ä§
YYV‚Ñ¶Œ£‚àóU‚ä§
‚Ñ¶,2, (15)
where [U‚ä§
‚Ñ¶,1U‚ä§
‚Ñ¶,2] =U‚ä§
‚Ñ¶withU‚Ñ¶,1‚ààRdx√ó(dx+du),U‚Ñ¶,2‚ààRdu√ó(dx+du), and
Œ£‚àó= limŒµ‚Üí0(Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,1/hatwideUY/hatwideU‚ä§
YU‚Ñ¶,1Œ£‚Ñ¶+Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,2U‚Ñ¶,2Œ£‚Ñ¶+Œµ2In)‚àí1Œ£‚ä§
‚Ñ¶.
Proof. By the definition of truncated SVD, the columns of /hatwideUYare orthonormal. Therefore, /hatwideU‚ä§
Yhas full
row-rankrx. Hence, by theorem 4.1.1 and lemma A.2.1, if Ex=/hatwideU‚ä§
Y, and‚Ñ¶‚Ñ¶‚ä§is non-singular, then the
unique minimum of Lpred, is reached when
G=/hatwideU‚ä§
YYV‚Ñ¶(ExuU‚Ñ¶Œ£‚Ñ¶)+= lim
Œµ‚Üí0/hatwideU‚ä§
YYV‚Ñ¶(Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xuExuU‚Ñ¶Œ£‚Ñ¶+Œµ2In)‚àí1Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu.(46)
Now, substituting Ex=/hatwideU‚ä§
YinExu, and using the partition U‚ä§
‚Ñ¶= [U‚ä§
‚Ñ¶,1U‚ä§
‚Ñ¶,2], whereU‚Ñ¶,1‚àà
Rdx√ó(dx+du),U‚Ñ¶,2‚ààRdu√ó(dx+du), we get
ExuU‚Ñ¶=/bracketleftbigg/hatwideU‚ä§
Y 0
0Idu/bracketrightbigg/bracketleftbiggU‚Ñ¶,1
U‚Ñ¶,2/bracketrightbigg
=/bracketleftbigg/hatwideU‚ä§
YU‚Ñ¶,1
U‚Ñ¶,2/bracketrightbigg
, (47)
and
U‚ä§
‚Ñ¶E‚ä§
xuExuU‚Ñ¶=/bracketleftÔ£¨ig
U‚ä§
‚Ñ¶,1/hatwideUYU‚ä§
‚Ñ¶,2/bracketrightÔ£¨ig/bracketleftbigg/hatwideU‚ä§
YU‚Ñ¶,1
U‚Ñ¶,2/bracketrightbigg
=U‚ä§
‚Ñ¶,1/hatwideUY/hatwideU‚ä§
YU‚Ñ¶,1+U‚ä§
‚Ñ¶,2U‚Ñ¶,2. (48)
Plugging (47) and (48) into (46) leads to
G= lim
Œµ‚Üí0/hatwideU‚ä§
YYV‚Ñ¶(Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,1/hatwideUY/hatwideU‚ä§
YU‚Ñ¶,1Œ£‚Ñ¶+Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,2U‚Ñ¶,2Œ£‚Ñ¶+Œµ2In)‚àí1Œ£‚ä§
‚Ñ¶/bracketleftÔ£¨ig
U‚ä§
‚Ñ¶,1/hatwideUYU‚ä§
‚Ñ¶,2/bracketrightÔ£¨ig
.(49)
Defining Œ£‚àó‚àÜ= limŒµ‚Üí0(Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,1/hatwideUY/hatwideU‚ä§
YU‚Ñ¶,1Œ£‚Ñ¶+Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶,2U‚Ñ¶,2Œ£‚Ñ¶+Œµ2In)‚àí1Œ£‚ä§
‚Ñ¶, we can split (49) into
AR=/hatwideU‚ä§
YYV‚Ñ¶Œ£‚àóU‚ä§
‚Ñ¶,1/hatwideUY,andBR=/hatwideU‚ä§
YYV‚Ñ¶Œ£‚àóU‚ä§
‚Ñ¶,2,
which is (15). ‚ñ†
A.4 The case when ‚Ñ¶‚Ñ¶‚ä§not invertible
When the covariance matrix ‚Ñ¶‚Ñ¶‚ä§is not invertible, which is always true if n < d x+du, the matrix
Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xuisnotguaranteedtobeinvertible. Inthatcase, theminimumof Lpredcorrespondstoinfinitely
many solutions for G. However, minimizing Lpredwith added ‚Ñì2regularization, i.e., Lpred,reg (Ex,G) =
Lpred(Ex,G) +Œ≤‚à•vec(G)‚à•2provides a unique solution for G, for a fixedEx. We have the following result.
Theorem A.4.1. For any fixed matrix ExandŒ≤ > 0, the objective function Lpred,reg (Ex,G) =
Lpred(Ex,G) +Œ≤‚à•vec(G)‚à•2is strictly convex in the coefficients of G, and the global minimum of Lpred,reg
corresponds to the unique solution for G, given by
G=ExY‚Ñ¶‚ä§E‚ä§
xu(Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu+Œ≤Irx+du)‚àí1. (50)
23Under review as submission to TMLR
Proof.Lpred,reg (Ex,G)can be written as, using (37a-c),
Lpred,reg (Ex,G) =/vextenddouble/vextenddoublevec(ExY)‚àí(‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)vec(G)/vextenddouble/vextenddouble2+Œ≤‚à•vec(G)‚à•2
=vec(ExY)‚ä§vec(ExY)‚àí2vec(ExY)‚ä§(‚Ñ¶‚ä§E‚ä§
xu‚äóIrx)vec(G)
+vec(G)‚ä§(Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu‚äóIrx+Œ≤Irx(rx+du))vec(G)
Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xuis a symmetric positive semidefinite matrix, irrespective of whether it has full rank or not.
Hence, by (37d), Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu‚äóIrxis symmetric positive semidefinite. Consequently, for any Œ≤ > 0,
Exu‚Ñ¶‚Ñ¶‚ä§E‚ä§
xu‚äóIrx+Œ≤Irx(rx+du)is positive definite. According to lemma A.0.1, Lpred,regis therefore
strictly convex in the coefficients of Gand globally minimized when ‚àáLpred,reg = 0. The unique solution of
(50) can be derived in the same manner as theorem 4.1.1. ‚ñ†
Remark. Replacing ‚Ñ¶with its SVD in (50) we get,
G=ExYV‚Ñ¶Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu(ExuU‚Ñ¶Œ£‚Ñ¶Œ£‚ä§
‚Ñ¶U‚ä§
‚Ñ¶E‚ä§
xu+Œ≤Irx+du)‚àí1. (51)
In the limit Œ≤‚Üí0+, (51) converges to (44).
A.5 DMDc through a linear autoencoding structure
Here we present a linear autoencoding structure that leads to a linear ROM exactly resembling the DMDc so-
lution whenEx=/hatwideU‚ä§
Y. However, its DNN-based nonlinear counterpart does not actually offer dimensionality
reduction.
Theorem A.5.1. Consider the following objective function
Lpred,alt (Ex,/tildewideG) =1
nn‚àí1/summationdisplay
i=0/vextenddouble/vextenddoubleExx(ti+1)‚àí/tildewideGœâ(ti)/vextenddouble/vextenddouble2, (52)
where/tildewideG‚ààRrx√ó(dx+du). For any fixed matrix Ex, the objective function Lpred,altis convex in the coefficients
of/tildewideGand attains its minimum for any /tildewideGsatisfying
/tildewideG‚Ñ¶‚Ñ¶‚ä§=ExY‚Ñ¶‚ä§, (53)
whereYand‚Ñ¶are the data matrices as defined in section (3.3). If ‚Ñ¶‚Ñ¶‚ä§is non-singular, then Lpred,altis
strictly convex and has a unique minimum for
/tildewideG=ExY‚Ñ¶‚ä§(‚Ñ¶‚Ñ¶‚ä§)‚àí1. (54)
Proof.The proof is very similar to the proof of theorem 4.1.1. Using (37a), we can write Lpred,alt (Ex,/tildewideG)as
follows,
Lpred,alt (Ex,/tildewideG) =1
nn‚àí1/summationdisplay
i=0/vextenddouble/vextenddoubleExx(ti+1)‚àí/tildewideGœâ(ti)/vextenddouble/vextenddouble2
=/vextenddouble/vextenddoublevec(ExY)‚àívec(/tildewideG‚Ñ¶)/vextenddouble/vextenddouble2
=/vextenddouble/vextenddoublevec(ExY)‚àí(‚Ñ¶‚ä§‚äóIrx)vec(/tildewideG)/vextenddouble/vextenddouble2. (55)
For fixedEx, applying Lemma A.0.1 to (55), we can say Lpred,altis convex in the coefficients of /tildewideG, and/tildewideG
corresponds to a global minimum of Lpred,altif and only if
(‚Ñ¶‚ä§‚äóIrx)‚ä§(‚Ñ¶‚ä§‚äóIrx)vec(/tildewideG) = (‚Ñ¶‚ä§‚äóIrx)‚ä§vec(ExY). (56)
Using (37a-c), we can write (56) as /tildewideG‚Ñ¶‚Ñ¶‚ä§=ExY‚Ñ¶‚ä§, which is (53).
24Under review as submission to TMLR
If‚Ñ¶‚Ñ¶‚ä§is non-singular, then it is symmetric positive definite. Using (37b-d), we can see that
(‚Ñ¶‚ä§‚äóIrx)‚ä§(‚Ñ¶‚ä§‚äóIrx) = (‚Ñ¶‚Ñ¶‚ä§‚äóIrx)is positive definite as well. Therefore, by Lemma A.0.1,
(55) is strictly convex in coefficient in /tildewideGand has a unique minimum. In that case, from (53), we can say
that the unique minimum of (55) is reached at /tildewideG=ExY‚Ñ¶‚ä§(‚Ñ¶‚Ñ¶‚ä§)‚àí1, i.e., (54). ‚ñ†
Corollary A.5.1.1. Consider the (full) SVD of the data matrix ‚Ñ¶given by ‚Ñ¶=U‚Ñ¶Œ£‚Ñ¶V‚ä§
‚Ñ¶, whereU‚Ñ¶‚àà
R(dx+du)√ó(dx+du),Œ£‚Ñ¶‚ààR(dx+du)√ón, andV‚Ñ¶‚ààRn√ón. IfEx=/hatwideU‚ä§
Yand‚Ñ¶‚Ñ¶‚ä§is non-singular, then the
solution for/tildewideGcorresponding to the unique minimum of Lpred,altcan be expressed as
/tildewideG=/hatwideU‚ä§
YYV‚Ñ¶Œ£+
‚Ñ¶U‚ä§
‚Ñ¶. (57)
Proof.By theorem A.5.1, if Ex=/hatwideU‚ä§
Y, and‚Ñ¶‚Ñ¶‚ä§is non-singular, then the unique minimum of Lpred,altis
reached when
/tildewideG=/hatwideU‚ä§
YY‚Ñ¶‚ä§(‚Ñ¶‚Ñ¶‚ä§)‚àí1=/hatwideU‚ä§
YY‚Ñ¶+(58)
The second equality is due to (38b). Substituting ‚Ñ¶+with its SVD definition (38c) into (58), we get
/hatwideU‚ä§
YYV‚Ñ¶Œ£+
‚Ñ¶U‚ä§
‚Ñ¶, which is (57). ‚ñ†
Remark. From (52), it can be seen that /tildewideGmaps the concatenated vector, œâ(ti), of full state and actuation
to the next reduce state xR(ti+1). We can partition (57) as /tildewideG=/hatwideU‚ä§
YYV‚Ñ¶Œ£+
‚Ñ¶[U‚ä§
‚Ñ¶,1U‚ä§
‚Ñ¶,2] = [/tildewideA/tildewideB]to
separate out the blocks corresponding to state and actuation. Here, U‚Ñ¶,1,U‚Ñ¶,2are the same as defined in
corollary 4.1.1.1, and /tildewideA‚ààRrx√ódx,/tildewideB‚ààRrx√ódu. Now, if we post-multiply /tildewideAwithE‚ä§
x=/hatwideUY‚ààRdx√órx, we
get a ROM
/tildewideAR=/tildewideA/hatwideUY=/hatwideU‚ä§
YYV‚Ñ¶Œ£+
‚Ñ¶U‚ä§
‚Ñ¶,1/hatwideUY,/tildewideBR=/tildewideB=/hatwideU‚ä§
YYV‚Ñ¶Œ£+
‚Ñ¶U‚ä§
‚Ñ¶,2, (59)
which maps the current reduced state xR(ti)and actuation u(ti)to the next reduced state xR(ti+1). It can
be verified easily that if we use the truncated SVD (as defined by 9), instead of the full SVD, for ‚Ñ¶in (58)
and follow the similar steps afterward, we get an approximation of (59):
/hatwideAR=/hatwideU‚ä§
YY/hatwideV‚Ñ¶/hatwideŒ£‚àí1
‚Ñ¶/hatwideU‚ä§
‚Ñ¶,1/hatwideUY=AR,DMDc ;/hatwideBR=/hatwideU‚ä§
YY/hatwideV‚Ñ¶/hatwideŒ£‚àí1
‚Ñ¶/hatwideU‚ä§
‚Ñ¶,2=BR,DMDc.
In summary, the aforementioned method can be carried out using gradient descent-based optimization and
leads to the same ROM as DMDc, when Ex=/hatwideU‚ä§
Y. However, in this method, the benefit of dimensionality
reduction is realized only when linear networks are used. A nonlinear counterpart (a DNN in the context
of this paper) of /tildewideAR, i.e., a nonlinear mapping from RrxtoRrx, cannot be pre-computed from a nonlinear
counterpart of /tildewideG, unlike the linear case (59). Consequently, we lose the benefit of dimensionality reduction
when nonlinear networks are used.
A.6 Proof of theorem 4.2.1
Theorem 4.2.1. Consider the target dynamics defined by (28)and the candidate Lyapunov function defined
by (29). Suppose the difference between the target dynamics and the closed-loop dynamics satisfies
‚à•F(xR,Eu‚ó¶Œ†(xR))‚àíFs(xR)‚à•‚â§Œ¥<Œ±Œ∏Œª min(K)
2Œªmax(K)/radicalÔ£¨igg
Œªmin(K)
Œªmax(K)Œ∑, (30)
for allxR‚ààXR={xR‚ààRrx| ‚à•xR‚à•< Œ∑}and 0< Œ∏ < 1. Then, for all initial points satisfying
‚à•xR(t0)‚à•</radicalÔ£¨ig
Œªmin(K)
Œªmax(K)Œ∑, the solution of the closed-loop ROMdxR
dt=F(xR,Eu‚ó¶Œ†(xR))satisfies
‚à•xR(t)‚à•‚â§Œªe‚àíŒ≥(t‚àít0)‚à•xR(t0)‚à•,‚àÄt0‚â§t<tc+t0 (31)
and
‚à•xR(t)‚à•‚â§2Œ¥
Œ±Œ∏Œª3,‚àÄt‚â•tc+t0 (32)
25Under review as submission to TMLR
for some finite tc>0, where
Œ≥=Œ±(1‚àíŒ∏)Œªmin(K)
2Œªmax(K)andŒª=/radicalÔ£¨igg
Œªmax(K)
Œªmin(K)(33)
Proof.From the definition of VR, we have
Œªmin(K)‚à•xR‚à•2‚â§VR(xR)‚â§Œªmax(K)‚à•xR‚à•2,‚àÄxR‚ààRrx, (60)
whereŒªmin(K)andŒªmax(K)denotethesmallestandlargesteigenvalues, respectively, of Kandhavepositive
values since the matrix Kis positive definite. Moreover, the definition of the target dynamics (28) implies
‚àáVR(xR)‚ä§Fs(xR) =/braceleftÔ£¨igg
‚àáVR(xR)‚ä§P(xR),if‚àáVR(xR)‚ä§P(xR)‚â§‚àíŒ±VR(xR)
‚àáVR(xR)‚ä§P(xR)‚àí‚àáV R(xR)‚ä§‚àáVR(xR)‚ä§P(xR)+Œ±VR(xR)
‚à•‚àáVR(xR)‚à•2‚àáVR(xR),otherwise
=/braceleftÔ£¨igg
‚àáVR(xR)‚ä§P(xR),if‚àáVR(xR)‚ä§P(xR)‚â§‚àíŒ±VR(xR)
‚àíŒ±VR(xR),otherwise
‚â§‚àíŒ±VR(xR)
‚â§‚àíŒ±Œªmin(K)‚à•xR‚à•2,‚àÄxR‚ààRrx. (61)
The last inequality is due to (60).
Now, assumeF(xR,Eu‚ó¶Œ†(xR)) =H(xR) =Fs(xR)+J(xR)for some function J:Rrx‚ÜíRrxand consider
VR(xR) =x‚ä§
RKx Ras a candidate Lyapunov function for
dxR
dt=H(xR) =Fs(xR) +J(xR). (62)
We have‚à•‚àáV R(xR)‚à•=‚à•2Kx R‚à•‚â§2Œªmax(K)‚à•xR‚à•. The time-derivative of VRalong the trajectories of (62)
satisfies
dVR
dt=‚àáVR(xR)‚ä§Fs(xR) +‚àáVR(xR)‚ä§J(xR)
‚â§‚àíŒ±Œªmin(K)‚à•xR‚à•2+‚à•‚àáV R(xR)‚à•‚à•J(xR)‚à•
‚â§‚àíŒ±Œªmin(K)‚à•xR‚à•2+ 2Œªmax(K)‚à•xR‚à•Œ¥,‚àÄ‚à•xR‚à•<Œ∑
=‚àíŒ±(1‚àíŒ∏)Œªmin(K)‚à•xR‚à•2‚àíŒ±Œ∏Œª min(K)‚à•xR‚à•2+ 2Œªmax(K)‚à•xR‚à•Œ¥,0<Œ∏< 1,‚àÄ‚à•xR‚à•<Œ∑
‚â§‚àíŒ±(1‚àíŒ∏)Œªmin(K)‚à•xR‚à•2<0,whenŒ∑>‚à•xR‚à•‚â•2Œ¥Œªmax(K)
Œ±Œ∏Œª min(K)‚àÜ=¬µ. (63)
The second inequality is obtained using (61) and the third inequality is obtained using (30). Clearly, we
have a non-empty region wheredVR
dt<0only when
Œ¥<Œ±Œ∏Œª min(K)
2Œªmax(K)Œ∑. (64)
Letb=Œªmin(K)Œ∑2andc=Œªmax(K)¬µ2. Consider the sublevel sets œáb={xR‚ààRrx|VR(xR)< b}and
œác={xR‚ààRrx|VR(xR)‚â§c}. It can be easily verified that if Œ¥<Œ±Œ∏Œª min(K)
2Œªmax(K)/radicalÔ£¨ig
Œªmin(K)
Œªmax(K)Œ∑, thenc<b, which
impliesœác‚äÇœáb. Note, this condition satisfies the necessary condition (64) for the non-empty region since
Œªmin(K)‚â§Œªmax(K).
For anyxRinsideœáb, using (60), we have
Œªmin(K)‚à•xR‚à•2‚â§VR(xR)<b=Œªmin(K)Œ∑2, (65)
26Under review as submission to TMLR
implying‚à•xR‚à•<Œ∑. Similarly, for any xRon the boundary or outside of œác, we have
Œªmax(K)¬µ2=c‚â§VR(xR)‚â§Œªmax(K)‚à•xR‚à•2, (66)
which implies‚à•xR‚à•‚â•¬µ.
Combining (65) and (66) we can say for any xRoutside (including the boundary) of œác, but inside œáb, (63)
holds true. For such xR(i.e.xR‚ààœáb\œác) we have
dVR
dt‚â§‚àíŒ±(1‚àíŒ∏)Œªmin(K)
Œªmax(K)VR(xR)‚àÜ=‚àí2Œ≥VR(xR), (67)
using (60) and (63).
If the initial point (at time t0) satisfies‚à•xR(t0)‚à•</radicalÔ£¨ig
Œªmin(K)
Œªmax(K)Œ∑, then by (60),
b=Œªmin(K)Œ∑2>Œªmax(K)‚à•xR(t0)‚à•2‚â•VR(xR(t0)),
which implies the initial point xR(t0)is insideœáb. Assuming an initial point in œáb\œác, and integrating (67)
in time interval [t0,t], we get
VR(xR(t))‚â§VR(xR(t0))e‚àí2Œ≥(t‚àít0). (68)
Hence,Œªmin(K)‚à•xR(t)‚à•2‚â§V R(xR(t))‚â§V R(xR(t0))e‚àí2Œ≥(t‚àít0)‚â§Œªmax(K)‚à•xR(t0)‚à•2e‚àí2Œ≥(t‚àít0)as long as
xR(t)remains outside of œác. SincedVR
dtis always negative outside of œác, any trajectory starting outside of it,
must enter œácin finite time. Let the trajectory starting at xR(t0)entersœácfor the first time at time tc+t0.
Then, we have
‚à•xR(t)‚à•‚â§/radicalÔ£¨igg
Œªmax(K)
Œªmin(K)e‚àíŒ≥(t‚àít0)‚à•xR(t0)‚à•=Œªe‚àíŒ≥(t‚àít0)‚à•xR(t0)‚à•,‚àÄt0‚â§t<tc+t0.(69)
Once a trajectory enters œác, it cannot escape œácbecausedVR
dtis negative on the boundary. Therefore, all
points of a trajectory after t‚â•tc+t0satisfiesŒªmin(K)‚à•xR(t)‚à•2‚â§VR(xR(t))‚â§c, equivalently,
‚à•xR(t)‚à•‚â§/radicalÔ£¨igg
Œªmax(K)
Œªmin(K)¬µ=2Œ¥
Œ±Œ∏/parenleftÔ£¨igg
Œªmax(K)
Œªmin(K)/parenrightÔ£¨igg3/2
=2Œ¥
Œ±Œ∏Œª3,‚àÄt‚â•tc+t0. (70)
From (67), (69) and (70), we have Œ≥=Œ±(1‚àíŒ∏)Œªmin(K)
2Œªmax(K)andŒª=/radicalÔ£¨ig
Œªmax(K)
Œªmin(K). ‚ñ†
B Details on reaction‚Äìdiffusion system experiment
B.1 Dataset
We use FEniCS (Logg et al. (2012)), an open-source computing platform for solving PDEs using the finite
element method, with Python interface to generate the dataset. For the reaction-diffusion system of (34),
we generate 100training sequences of length 50with time step size 0.01and256nodes in I. The initial
conditions and actuations of these sequences are given by
q(Œ∂,0) =|a|4/summationdisplay
k=0bkTk(Œ∂), Œ∂‚ààI, (71)
and
w(ti) = 10gimax
Œ∂|q(Œ∂,ti‚àí1)|, i= 1,2,¬∑¬∑¬∑,49, (72)
whereTkdenotes the kthChebyshev polynomial of the first kind, and a‚àº N (0,1),bk,gi‚àº U(‚àí1,1)
are chosen randomly. Similarly, 100sequences are generated for the test set to evaluate the prediction
performance.
27Under review as submission to TMLR
Conv -1D, k:3, n:32, s:2
ReLU
Conv -1D, k:3, n:2, s:2
FC, n:64
ReLU
FC, n:rx, no bias
FC, n:64
ConvT -1D, k:3, n:32, s:2
ConvT -1D, k:3, n:1, s:2FC, n:128
ReLUReLUFC, n:100
ReLU
FC, n:100
ReLU
FC, n:rx, no biasFC, n:100
ReLU
FC, n:100
ReLU
FC, n:rxConcatConcat
Copy+
+
+
‚àízeros
actuationfull state
reduced 
state
State Encoder State Decoder
ROM‚Ñ∞ùíô ùíüùíô
‚Ñ±FC, n:100
ReLU
FC, n:100
ReLU
FC, n:rx, no biasreduced state
FC, n:100
ReLU
FC, n:100
ReLU
FC, n:1reduced statetarget time derivative
actuation
Controller Œ†Stability Criterion
Target Dynamics ‚Ñ±ùë† 
Integrator
Conv -1D : 1D convolution
ConvT -1D : 1D transposed convolution
FC: fully connected
k : kernel size
n : # features (for FC) or feature maps (for Conv)
s : stride1√óùëüùë•1√óùëüùë•
1√óùëüùë•
1√ó11√ó1
1√ó11√ó256
1√ó256 next full state1√óùëüùë•‚Ñ±forced
‚Ñ±forced‚Ñ±auto
Figure 12: Architectures for all the DNN modules used in the reaction‚Äìdiffusion experiment. The ‚ÄòCopy‚Äô
operation denotes the reuse of the same DNN block for zero and nonzero actuation. The ‚ÄòConcat‚Äô operator
concatenates the input features along the last dimension. Zeros are concatenated to the reduced state to
evaluate the component Fforced/parenleftbig
xR,0/parenrightbig
. The ‚ÄòIntegrator‚Äô performs the numerical integration for (21). The
‚ÄòStability Criterion‚Äô block implements (28).
B.2 DNN architectures
Figure 12 shows the DNN architectures used for different modules in the reaction‚Äìdiffusion experiment. The
stateencodercomprises1Dconvolutionallayers, followedbyfullyconnectedlayers. Thestatedecoderhasthe
reversed order with convolutional layers replaced by transposed convolutional layers. The ROM is designed
bybreakingthefunction Fintotwocomponents: F/parenleftbig
xR,uR/parenrightbig
=Fauto/parenleftbig
xR/parenrightbig
+Fforced/parenleftbig
xR,uR/parenrightbig
‚àíFforced/parenleftbig
xR,0/parenrightbig
.
Fautorepresents the autonomous dynamics that does not depend on the actuation, whereas Fforcedis respon-
sible for the impact of actuation on dynamics. The composition Fforced/parenleftbig
xR,uR/parenrightbig
‚àíFforced/parenleftbig
xR,0/parenrightbig
ensures that
the component responsible for learning the impact of actuation on the dynamics provides nonzero output
only when the actuation is nonzero. Two multilayer perceptions (MLPs) are used to implement Fautoand
Fforced. This specific structure of the ROM is not crucial and a single neural network representing F/parenleftbig
xR,uR/parenrightbig
works as well. However, we observe better performance in experiments when the aforementioned structure
is used. The output of the ROM is integrated using a numerical integrator to get the next state. The
controller is implemented using an MLP. The target dynamics is implemented using another MLP, followed
by a stability criterion in the form of (28).
B.3 Training settings
We userx= 5in the prediction task and rx= 2in the control task for all the methods. All modules are
implemented in PyTorch. In both of the learning phases, learning ROM and learning controller, we use the
Adam optimizer with an initial learning rate of 0.001and apply an exponential scheduler with a decay of
28Under review as submission to TMLR
0.99. Modules are trained for 100epochs in mini-batches of size 32.10%of the training data is used for
validation to choose the best set of models. For DeepROM training, we use Œ≤2= 1in (22). For learning
control, we use Œ≤3= 0.2in (26),Œ±= 0.2in (28), andK= 0.5Irxin (29). Since the learned ROMs from one
training instance to another can vary, the hyperparameter pair ( Œ±,Œ≤3) may require re-tuning accordingly.
C Details on vortex shedding suppression experiment
C.1 Dataset
For the flow past a circular cylinder problem, the geometry and physical parameters of the system are taken
from the DFG 2D-2 benchmark (Sch√§fer et al. (1996)). The geometry is shown in Figure 13. We use the
blue-shaded region for observation and actuation. Following the DFG 2D-2 benchmark, we use the no-slip
boundary condition of zero velocity for the walls and the cylinder boundary, zero outlet pressure, and the
inflow velocity profile (at the inlet) as
v(Œ∂,t) =/parenleftbigg
1.54Œ∂2(0.41‚àíŒ∂2)
0.412,0/parenrightbigg
, (73)
whereŒ∂1andŒ∂2denote the horizontal and vertical coordinates, respectively, of Œ∂. We use kinematic viscosity
ŒΩ= 0.002and density œÅ= 1leading to the Reynolds number Re= 50. The training sequence of length 5000
is generated in FEniCS with a time step size 0.001and applying actuations
w(Œ∂,t) =a4/summationdisplay
k=0/bracketleftbigsin(kœÄ(Œ∂1‚àí0.11)/0.66) sin(kœÄŒ∂2/0.41)/bracketrightbig/bracketleftbiggbk,1,1bk,2,1
bk,1,2bk,2,2/bracketrightbigg
,Œ∂‚ààW, (74)
wherea‚àº U(0,1)andbk,i,j‚àº U(‚àí1,1),i,j = 1,2are chosen randomly. Similarly, a test sequence is
generated to evaluate the prediction performance. For learning control, we use the Stokes flow or creeping
flow as the desired state, which can be obtained by solving the Stokes equations
ŒΩ‚àá2v‚àí1
œÅ‚àáp=0,‚àá¬∑v=0inI√óR+. (75)
For training, the flow velocity data from the observation region (blue shaded in Figure 13) are interpolated
onto a rectangular uniform grid of size 32√ó48so that it can be used in standard CNNs.
2.20.41
0.20.20.11 0.66
0.1inlet
outletwall
wall
Figure 13: Geometry of the flow past a circular cylinder set-up.
C.2 DNN architectures
Figure 14 shows the DNN architectures used for different modules in the vortex shedding control experiment.
The architectures for the ROM and target dynamics are the same as in the previous example. Moreover, the
state encoder and decoder have similar architectures as the previous example except for the 1D convolutions
and transposed convolutions are replaced by their 2D counterparts. Here, an additional module is used:
the control encoder for encoding the distributed control/actuation. It has the same architecture as the
29Under review as submission to TMLR
Conv -2D, k:3, n:32, s:2
ReLU
Conv -2D, k:3, n:2, s:1
FC, n:64
ReLU
FC, n:rx, no bias
FC, n:64
ConvT -2D, k:3, n:32, s:2
ConvT -2D, k:3, n:2, s:2FC, n:192
ReLUReLUFC, n:100
ReLU
FC, n:100
ReLU
FC, n:rx, no biasFC, n:100
ReLU
FC, n:100
ReLU
FC, n:rxConcat
Copy+
+
+
‚àíreduced 
state
State Encoder State Decoder ‚Ñ∞ùíô ùíüùíôFC, n:100
ReLU
FC, n:100
ReLU
FC, n:rx, no biasreduced state
FC, n:100
ReLU
FC, n:100
ReLU
FC, n:rureduced statetarget time derivative
coefs
Controller Œ†Stability Criterion
Target Dynamics ‚Ñ±ùë† 
IntegratorConv -2D, k:3, n:32, s:2
ReLU
ConvT -2D, k:3, n:32, s:1
ReLUConv -2D, k:3, n:32, s:2
ReLU
Conv -2D, k:3, n:2, s:1
FC, n:64
ReLU
FC, n:ru, no biasfull actuation
Control Encoder ‚Ñ∞ùíñConv -2D, k:3, n:32, s:2
ReLU
reduced 
actuation
Concatzeros
reduced 
state
ROM‚Ñ±
FC, n:64
ReLU
FC, n:64
ReLU
FC, n:2ru
Split‚äô
‚äô
full actuationcoefs
Concatactuation nodes
Conv -2D : 2D convolution
ConvT -2D : 2D transposed convolution
FC: fully connected
k : kernel size
n : # features (for FC) or feature maps (for Conv)
s : stride
N : # actuation nodes
: dot product‚äô2√ó32√ó48 full state 2√ó32√ó48
2√ó32√ó48 2√ó32√ó48 next full state1√óùëüùë•1√óùëüùë•
1√óùëüùë•1√óùëüùë¢
1√óùëüùë•1√óùëüùë¢
ùëÅ√ó21√óùëüùë•‚Ñ±forced‚Ñ±auto
‚Ñ±forced
Figure 14: Architectures for all the DNN modules used in the fluid flow experiment. The ‚ÄòSplit‚Äô operator
splits the input features into two vectors, along the last dimension. These split vectors represent the space-
dependent polynomial basis associated with the horizontal and vertical components of the actuation.
state encoder. To learn the distributed actuation, we design the controller as a linear combination of space-
dependent polynomial basis functions. One MLP is used to learn these space-dependent polynomial basis
functions given the locations of the actuation nodes and another MLP is used to learn the corresponding
coefficients. The actuation is computed as the dot product of the polynomial basis terms and the coefficient
vector. We use this architecture instead of a standard convolutional one because the PDE solver takes the
actuation input in a triangular mesh, not in a uniform rectangular grid. The polynomial basis architecture
can be used to compute actuation in both uniform rectangular grid during training and triangular mesh
during evaluation.
C.3 Training settings
We userx= 5in both the prediction task and control task for all the methods. All modules are implemented
inPyTorch. Inbothofthelearningphases, learningROMandlearningcontroller, weusetheAdamoptimizer
with an initial learning rate of 0.001and apply an exponential scheduler with a decay of 0.99. Modules are
trained for 100epochs in mini-batches of size 32.10%of the training data is used for validation to choose
the best set of models. For DeepROM training, we use Œ≤2= 1in (22). For learning control, we use Œ≤3= 2
in (26),Œ±= 0.1in (28), and K= 0.5Irxin (29). Since the learned ROMs from one training instance to
another can vary, the hyperparameter pair ( Œ±,Œ≤3) may require re-tuning accordingly.
30Under review as submission to TMLR
D Architecture and training details for the Deep Koopman model
For the encoder and decoder of the Deep Koopman model, we use the same architectures as our state encoder
and state decoder. As mentioned in section 5.1, we consider both the system and input matrices of the ROM
to be fixed during operation, in contrast to the original method proposed by Morton et al. (2018). Therefore,
during training, these matrices are treated as trainable global parameters. Similar to Morton et al. (2018),
theinputmatrixisoptimizedbygradientdescentduringtrainingalongwiththeencoder-decoderparameters,
whereas the system matrix is obtained using linear least-squares regression. The datasets are divided into
staggered 32-step sequences for training, and the model is trained by generating recursive predictions over 32
steps following Morton et al. (2018). We train the model using the Adam optimizer with an initial learning
rate of 0.001and an exponential decay of 0.99for200epochs in mini-batches of size 8.10%of the training
data is used for validation to choose the best set of models.
As mentioned in 5.3.3, we utilize a low-dimensional representation of the distributed actuation for Deep
Koopman + LQR, instead of directly estimating the high-dimensional actuation. The distributed actuation
is represented as a linear combination of the same space-dependent sinusoidal basis functions used for dataset
generation, whicharegivenby(74). Thecontrollerisdesignedtoestimatethecoefficients bk,i,j;i,j= 1,2; 0‚â§
k‚â§4.
31