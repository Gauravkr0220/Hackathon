QSketch: An Efficient Sketch for Weighted Cardinality Estimation
in Streams
Yiyan Qiâˆ—
International Digital Economy
Academy (IDEA)
Shenzhen, China
qiyiyan@idea.edu.cnRundong Liâˆ—
MOE KLINNS Lab
Xiâ€™an Jiaotong University
Xiâ€™an, China
xjtulirundong@stu.xjtu.edu.cnPinghui Wangâ€¡
MOE KLINNS Lab
Xiâ€™an Jiaotong University
Xiâ€™an, China
phwang@xjtu.edu.cn
Yufang Sun
MOE KLINNS Lab
Xiâ€™an Jiaotong University
Xiâ€™an, China
sunyufang00@stu.xjtu.edu.cnRui Xing
MOE KLINNS Lab
Xiâ€™an Jiaotong University
Xiâ€™an, China
xingrui128719@163.com
ABSTRACT
Estimating cardinality, i.e., the number of distinct elements, of a
data stream is a fundamental problem in areas like databases, com-
puter networks, and information retrieval. This study delves into
a broader scenario where each element carries a positive weight.
Unlike traditional cardinality estimation, limited research exists
on weighted cardinality, with current methods requiring substan-
tial memory and computational resources, challenging for devices
with limited capabilities and real-time applications like anomaly
detection. To address these issues, we propose QSketch, a memory-
efficient sketch method for estimating weighted cardinality in
streams. QSketch uses a quantization technique to condense con-
tinuous variables into a compact set of integer variables, with each
variable requiring only 8 bits, making it 8 times smaller than previ-
ous methods. Furthermore, we leverage dynamic properties during
QSketch generation to significantly enhance estimation accuracy
and achieve a lower time complexity of ğ‘‚(1)for updating estima-
tions upon encountering a new element. Experimental results on
synthetic and real-world datasets show that QSketch is approxi-
mately 30% more accurate and two orders of magnitude faster than
the state-of-the-art, using only 1/8of the memory.
CCS CONCEPTS
â€¢Theory of computation â†’Sketching and sampling; â€¢Infor-
mation systemsâ†’Data stream mining.
KEYWORDS
Streaming algorithms, Sketch, Weighted Cardinality Estimation
âˆ—Equal Contribution.
â€¡Corresponding Author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671695ACM Reference Format:
Yiyan Qiâˆ—, Rundong Liâˆ—, Pinghui Wangâ€¡, Yufang Sun, and Rui Xing. 2024. QS-
ketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams.
InProceedings of the 30th ACM SIGKDD Conference on Knowledge Discovery
and Data Mining (KDD â€™24), August 25â€“29, 2024, Barcelona, Spain. ACM, New
York, NY, USA, 12 pages. https://doi.org/10.1145/3637528.3671695
1 INTRODUCTION
Real-world systems generate data in a streaming fashion. Exam-
ples range from financial transactions to Internet of Things (IoT)
data, network traffic, call logs, trajectory logs, etc. Computing the
cardinality, i.e., the number of distinct elements, of such a stream
is fundamental in research areas like databases, machine learning,
and information retrieval. For example, online games and mobile
apps usually use daily active users (DAU), i.e., the number of dis-
tinct active users within a day, as a metric to measure the level of
engagement. Other examples include network security monitoring
[14] and connectivity analysis in the Internet graph [32].
Due to the unknown or even unlimited size and the high-speed
nature of these data streams, it is infeasible to collect the entire data
when the computation and memory resources of data collection
devices (e.g., network routers) are limited. To solve this challenge,
considerable attention has been paid to designing fast and memory-
efficient cardinality estimating algorithms via sketching techniques
[13,17,20,40]. They build a compact data summary (i.e., sketch) on
the fly and then estimate the cardinality from the generated sketch.
The above cardinality computing problem can be generalized to
a weighted scenario, where each element ein the data stream is
associated with a positive weight ğ‘¤âˆˆR+. In this new scenario, the
goal is to compute the total sum of weights for all distinct elements,
i.e., weighted cardinality. The weighted cardinality has various
applications, including 1) In database systems, an example is a SQL
query like â€œSELECT DISTINCT * FROM TABLEâ€. In addition to the
queryâ€™s cardinality, understanding the total size of the resultant set
aids in optimizing performance and managing resources [ 30,31].
Here, the weighted cardinality represents the total size (in bytes)
of the query result, calculated as the cumulative size of all distinct
records, weighted by their row size. 2) In a voting system, each
voter may have a weight based on their expertise and we need it to
figure out the final voting result. 3) In an app or website, users with
 
2432
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Yiyan Qi et al.
more activity might be assigned higher weights. This metric allows
for a more nuanced understanding of the app other than Daily
Active User (DAU). Weighted cardinality computation is important
in scenarios where individual contributions vary in importance.
Despite the plenty of works for estimating the regular cardi-
nality, little attention has been paid to the problem of Weighted
Cardinality Estimation (WCE). Lemiesz [ 26] conducts a formal
study on the WCE problem. The proposed method maps each ele-
ment in the data stream into ğ‘šexponential variables concerning
the elementâ€™s weight. To guarantee estimation accuracy, ğ‘šis set to
hundreds or thousands, making it infeasible to deal with real-time
streams. Zhang et al. [ 45] proposed a method FastGM to decrease
the update time complexity of Lemieszâ€™s method. Instead of generat-
ingğ‘švariables independently, FastGM generates those exponential
variables in ascending order and early stops the generation when
the value is greater than the maximal value stored in the current
registers. A recent method FastExp Sketch [ 27] shares the same idea
with FastGM. The above three methods use 64-bit floating-point reg-
isters to store these exponential variables. When a large value of ğ‘šis
employed for improved accuracy, it becomes memory-intensive for
devices with limited computational and storage resources. Addition-
ally, they require ğ‘‚(ğ‘š)operations to estimate weighted cardinality,
making them computationally expensive when aiming to provide
anytime-available estimation for real-time applications.
We develop a memory-efficient sketch, QSketch, to estimate the
weighted cardinality of distinct elements in a data stream. QSketch
generatesğ‘šindependent exponential variables for each incoming
element in descending order. This process is employed to update the
ğ‘šinteger registers, and an early termination occurs when a gen-
erated variable is smaller than the values in all registers. QSketch
employs a novel mapping strategy that transforms continuous expo-
nential variables into discrete variables, using a small set of integer
registers to represent data streams with varying weighted cardinal-
ities. Consequently, each register in our QSketch requires no more
than 5bits, making it up to 13Ã—smaller than both Lemieszâ€™s method
and FastGM. To reduce time cost and estimation error, we propose
an extension of QSketch, QSketch-Dyn, to monitor the weighted car-
dinality on the fly. QSketch-Dyn shares the same data structure as
QSketch but only needs to compute one variable for each element. It
utilizes the dynamic property of our QSketch to reduce estimation
error significantly. We summarize our main contributions as:
â€¢We propose a memory-efficient sketch method QSketch to es-
timate the weighted cardinality of distinct elements in a data
stream. QSketch employs a novel mapping strategy that trans-
forms continuous exponential variables into discrete variables,
using a small set of integer registers to represent data streams
with varying weighted cardinalities.
â€¢We also present QSketch-Dyn, an advanced variant of QSketch,
which leverages the inherent dynamic nature of QSketch, en-
abling real-time tracking of weighted cardinality.
â€¢We conduct experiments on both synthetic and real-world datasets.
The experimental results demonstrate that our new sketching
method achieves approximately 30% more accurate and is two or-
ders of magnitude faster than the state-of-the-art while requiring
only 1/8 of the memory usage.Algorithm 1: Pseudo-code of Lemieszâ€™s method.
input : stream Î ,ğ‘š.
output: sketchğ‘….
1ğ‘…â†[+âˆ,...,+âˆ];
2foreach(ğ‘¥,ğ‘¤)âˆˆÎ do
3 sforğ‘—=1,...,ğ‘š do
4ğ‘Ÿğ‘—â†âˆ’lnâ„ğ‘—(ğ‘¥)
ğ‘¤;
5ğ‘…[ğ‘—]â† min(ğ‘…[ğ‘—],ğ‘Ÿğ‘—);
The rest of this paper is organized as follows. Section 2 introduces
the problem. Section 3 briefly discusses preliminaries. Section 4
presents our method QSketch and QSketch-Dyn. The performance
evaluation and testing results are presented in Section 5. Section 6
summarizes related work. Concluding remarks then follow.
2 PROBLEM FORMULATION
We first introduce some notations. Let Î =e(1)Â·Â·Â·e(ğ‘¡)Â·Â·Â·denote
a data stream, where an element e(ğ‘¡)arriving at time ğ‘¡corresponds
to one of the elements ğ‘¥1,...,ğ‘¥ğ‘›and eachğ‘¥ğ‘–,1â‰¤ğ‘–â‰¤ğ‘›has a
positive weight ğ‘¤ğ‘–>0. Note that an element emay appear multiple
times in the stream. Denote ğ‘(ğ‘¡)
Î as the set of distinct elements
that occurred in stream Î before and including time ğ‘¡. Then, the
weighted cardinality of stream Î atğ‘¡is defined as
ğ¶(ğ‘¡)=âˆ‘ï¸
ğ‘¥ğ‘–âˆˆğ‘(ğ‘¡)
Î ğ‘¤ğ‘–. (1)
This paper aims to develop a sketch method to estimate the weighted
cardinalityğ¶(ğ‘¡)accurately and efficiently. We omit the superscript
(ğ‘¡)when no confusion arises.
3 PRELIMINARIES
In this section, we introduce two existing methods to estimate
weighted cardinality and discuss their shortcomings.
3.1 Existing Methods For WCE
â€¢Lemieszâ€™s Method [26] builds a sketch consisting of ğ‘šregisters
ğ‘…[1],...,ğ‘…[ğ‘š]. Typically,ğ‘šis set to be thousands to guarantee the
desired accuracy. All ğ‘šregisters are initialized to +âˆ. For each
ğ‘—âˆˆ{1,...,ğ‘š}, letğ‘…(ğ‘¡)[ğ‘—]denote the value of ğ‘…[ğ‘—]at timeğ‘¡. For
each e(ğ‘¡)arriving at time ğ‘¡, Lemieszâ€™s method maps it into all ğ‘š
registers independently and each register is updated as
ğ‘…(ğ‘¡)[ğ‘—]â† min(ğ‘…(ğ‘¡âˆ’1)[ğ‘—],ğ‘Ÿğ‘—(e(ğ‘¡))).
Without loss of generality, we let e(ğ‘¡)=ğ‘¥ğ‘–with weight ğ‘¤ğ‘–,1â‰¤ğ‘–â‰¤
ğ‘›. In the above equation, ğ‘Ÿğ‘—(e(ğ‘¡))is defined as
ğ‘Ÿğ‘—(e(ğ‘¡))=âˆ’lnâ„ğ‘—(ğ‘¥ğ‘–)
ğ‘¤ğ‘–,
whereâ„ğ‘—(ğ‘¥)is a hash function that maps ğ‘¥to(0,1)uniformly, i.e.,
â„ğ‘—(ğ‘¥)âˆ¼Uniform(0,1),1â‰¤ğ‘—â‰¤ğ‘š. The pseudo-code of Lemieszâ€™s
method is shown in Algorithm 1. We note that ğ‘Ÿğ‘—(e(ğ‘¡))follows an
exponential distribution EXP(ğ‘¤(ğ‘¡))andğ‘…(ğ‘¡)[ğ‘—]=min
ğ‘¥ğ‘–âˆˆğ‘(ğ‘¡)
Î ğ‘Ÿğ‘—(ğ‘¥ğ‘–)
 
2433QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
follows an exponential distribution EXP(ğ¶(ğ‘¡)), in whichğ¶(ğ‘¡)is
the weighted cardinality at time ğ‘¡. Thus, the summation variable
ğºğ‘š=Ãğ‘š
ğ‘—=1ğ‘…(ğ‘¡)[ğ‘—]follows a gamma distribution ğºğ‘šâˆ¼Î“(ğ‘š,ğ¶(ğ‘¡)).
According to [ 41], the inverse of the summation variable ğºğ‘š, i.e.,
1/ğºğ‘š, has the inverse gamma distribution 1/ğºğ‘šâˆ¼Î“âˆ’1(ğ‘š,ğ¶(ğ‘¡)),
and we have
E[1/ğºğ‘š]=ğ¶(ğ‘¡)
ğ‘šâˆ’1,Var[1/ğºğ‘š]=(ğ¶(ğ‘¡))2
(ğ‘šâˆ’2)(ğ‘šâˆ’1)2,
where the first equation holds for ğ‘šâ‰¥2and second for ğ‘šâ‰¥3.
Then at time ğ‘¡, Lemiesz gives an unbiased estimator of ğ¶(ğ‘¡)as
Ë†ğ¶(ğ‘¡)=ğ‘šâˆ’1Ãğ‘š
ğ‘—=1ğ‘…(ğ‘¡)[ğ‘—]. (2)
The above estimatorâ€™s variance is computed as
Var[Ë†ğ¶(ğ‘¡)/ğ¶(ğ‘¡)]=1
ğ‘šâˆ’2.
â€¢FastGM. Lemieszâ€™s method needs ğ‘‚(ğ‘š)time to update an element
In practice, ğ‘šis usually thousands to achieve the expected accu-
racy and is infeasible for high-speed streams. To solve this problem,
Zhang et al. [ 45] proposed FastGM, reducing the time complexity
fromğ‘‚(ğ‘š)toğ‘‚(1). FastGM shares the same sketch structure as
Lemieszâ€™s method. The difference is that ğ‘šrandom variables in
FastGMâˆ’lnâ„1(ğ‘¥ğ‘–)
ğ‘¤ğ‘–,...,âˆ’lnâ„ğ‘š(ğ‘¥ğ‘–)
ğ‘¤ğ‘–are generated in ascending or-
der as
âˆ’lnâ„ğœ‹1(ğ‘¥ğ‘–)
ğ‘¤ğ‘–,ğœ‹1
,...,
âˆ’lnâ„ğœ‹ğ‘š(ğ‘¥ğ‘–)
ğ‘¤ğ‘–,ğœ‹ğ‘š
, whereâˆ’lnâ„ğœ‹1(ğ‘¥ğ‘–)
ğ‘¤ğ‘–<
Â·Â·Â·<âˆ’lnâ„ğœ‹ğ‘š(ğ‘¥ğ‘–)
ğ‘¤ğ‘–andğœ‹1,...,ğœ‹ğ‘šis a random permutation of inte-
gers 1,...,ğ‘š . Once the current obtained random variable âˆ’lnâ„ğ‘—1(ğ‘¥ğ‘–)
ğ‘¤ğ‘–
is larger than all values in registers ğ‘…(ğ‘¡)[1],...,ğ‘…(ğ‘¡)[ğ‘š], there is
no need to generate the following random variables because they
have no chance to change the sketch. In detail, for each e(ğ‘¡)=ğ‘¥ğ‘–,
1â‰¤ğ‘–â‰¤ğ‘›, FastGM generates the first exponential variable as
ğ‘Ÿğœ‹1(e(ğ‘¡))=âˆ’1
ğ‘šÂ·lnâ„ğœ‹1(ğ‘¥ğ‘–)
ğ‘¤ğ‘–, (3)
and the following exponential variables ğ‘Ÿğœ‹ğ‘—(e(ğ‘¡)),2â‰¤ğ‘—â‰¤ğ‘šare
generated in ascending order as
ğ‘Ÿğœ‹ğ‘—(e(ğ‘¡))=ğ‘Ÿğœ‹ğ‘—âˆ’1(e(ğ‘¡))âˆ’1
ğ‘šâˆ’ğ‘—+1Â·lnâ„ğœ‹ğ‘—(ğ‘¥ğ‘–)
ğ‘¤ğ‘–. (4)
After generating a hash value ğ‘Ÿğœ‹ğ‘—(e(ğ‘¡)),ğ‘—âˆˆ{1,...,ğ‘š}, FastGM
uses the Fisher-Yates shuffle [ 15] to find its position ğœ‹ğ‘—âˆˆ{1,...,ğ‘š}.
Specially, let(ğœ‹1,...,ğœ‹ğ‘š)be initialized to(1,...,ğ‘š). To obtain the
position of the ğ‘—-th smallest hash value, FastGM randomly chooses a
positionğ‘˜âˆˆ{ğ‘—,ğ‘—+1,...,ğ‘š}, swapsğœ‹ğ‘˜andğœ‹ğ‘—, and updates ğ‘…(ğ‘¡)[ğœ‹ğ‘—]
withğ‘Ÿğœ‹ğ‘—(e(ğ‘¡)). FastGM uses an extra register ğ‘Ÿâˆ—to perform an early
stop to record the maximal values among ğ‘šregisters. Register
values in FastGM follow the same distribution as LM. They share
the same weighted cardinality estimator and the same estimation
errors. Besides, we find that a recent method FastExpSketch [ 27]
shares the same idea with FastGM.
3.2 Limitations of Existing Methods
â€¢Memory-consuming. Lemieszâ€™s method and FastGM use 32-
bit or 64-bit floating-point registers to store hash variables. They
require 32ğ‘šor64ğ‘šbits of memory to store ğ‘šhash variables for
0 1 2 4
0 -1 1 2â€¦ -2â€¦FastGM
QSketch
Â  2
Â  1
 Â -1
 Â -2Figure 1: Basic idea of QSketch
a stream Î . When we need a large ğ‘šfor better accuracy or there
are many different streams, it is memory-intensive for devices (e.g.
IoT devices or routers) with limited computational and storage
resources. Therefore, reducing the number of bits for each register
is practical, saving storage space and improving the computational
efficiency for sketch operations [26, 29].
â€¢Time-consuming. Lemieszâ€™s method requires updating each
register for element insertion, incurring an ğ‘‚(ğ‘š)time cost. While
FastGM improves upon this by ordering register updates, it still de-
mandsğ‘‚(ğ‘š)time in the worst-case scenario when element weights
grow over time. Furthermore, the time complexity for the estimation
process in both methods is quantified as ğ‘‚(ğ‘š). Such a computa-
tional demand poses challenges for providing consistent, real-time
estimations in applications that require immediate data availability.
4 OUR METHOD
In this section, we first introduce a compact sketch QSketch (Quan-
tization Sketch) which utilizes the quantization technique (i.e.,
mapping continuous infinite values to a small set of discrete values).
We design a novel estimator to estimate weighted cardinality. Then,
we exploit the dynamic properties of the register arrays over time
to significantly improve the estimation accuracy and reduce the
time cost to monitor the weighted cardinality on the fly.
4.1 Basic Idea
QSketch reduces the size of 32-bit or 64-bit floating-point registers
to a smaller bit size (5 or 6 bits) through quantization. This process
transforms an infinite range of continuous values into a limited set
of discrete values. Figure 1 illustrates how QSketchâ€™s hash value
mappings compare to those in FastGM and Lemieszâ€™s method.
4.2 QSketch
Data structure and update procedure. Denoteğ‘…as the sketch
withğ‘šregistersğ‘…[1],...,ğ‘…[ğ‘š], andâ„1,...,â„ğ‘šasğ‘šindependent
hash functions, each of them mapping ğ‘¥to a random value in range
(0,1)uniformly, i.e., â„ğ‘—(ğ‘¥) âˆ¼ Uniform(0,1),1â‰¤ğ‘—â‰¤ğ‘˜. When
inserting ewhich is associated with i ğ‘¥and weightğ‘¤, we generate
ğ‘švariablesğ‘¦1(e),...,ğ‘¦ğ‘š(e)as
ğ‘¦ğ‘—(e)=âŒŠâˆ’log2(ğ‘Ÿğ‘—(e))âŒ‹, (5)
whereğ‘Ÿğ‘—(e)=âˆ’lnâ„ğ‘—(ğ‘¥)
ğ‘¤is an exponential random variable and âŒŠÂ·âŒ‹
is the round-down operation. Then QSketch updates as
ğ‘…[ğ‘—]â† max(ğ‘…[ğ‘—],ğ‘¦ğ‘—(e)). (6)
Following [ 45], we generate ğ‘švariablesğ‘Ÿğœ‹1(e),...,ğ‘Ÿğœ‹ğ‘š(e)in an
ascending order, in which (ğœ‹1,...,ğœ‹ğ‘š)is a random permutation
of(1,...,ğ‘š). As a result, ğ‘¦ğœ‹1(e), ...,ğ‘¦ğœ‹ğ‘š(e)are generated in a
descending order. The update procedure is shown in Algorithm 2.
We use the Fisher-Yates shuffle [ 15] (Line 11-12 in Algorithm 2)
to quickly find the position to be updated and use ğ‘—âˆ—to record
 
2434KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Yiyan Qi et al.
Algorithm 2: Update procedure of QSketch.
input : stream Î , sketch size ğ‘š, register size ğ‘.
output: sketchğ‘….
1ğ‘Ÿminâ†âˆ’2ğ‘âˆ’1+1;ğ‘Ÿmaxâ†2ğ‘âˆ’1âˆ’1;
2ğ‘ˆâ†[ğ‘Ÿmin,...,ğ‘Ÿ min];ğ‘—âˆ—â†1;
3foreach eâˆˆÎ do
/* element ğ‘¥with weight ğ‘¤. */
4[ğœ‹1,...,ğœ‹ğ‘š]â†[ 1,...,ğ‘š];
5ğ‘Ÿâ†0;
6 forğ‘—=1,...,ğ‘š do
7ğ‘Ÿâ†ğ‘Ÿâˆ’lnâ„ğ‘—(ğ‘¥)
ğ‘¤(ğ‘šâˆ’ğ‘—+1);
8ğ‘¦â†âŒŠâˆ’ log2(ğ‘Ÿ)âŒ‹;
9 ifğ‘¦â‰¤ğ‘…[ğ‘—âˆ—]then
/* early stop */
10 break ;
11ğ‘˜â†RandInt(ğ‘—,ğ‘š);
12 Swap(ğœ‹ğ‘˜,ğœ‹ğ‘—);
13 ifğ‘¦>ğ‘…[ğœ‹ğ‘™]then
14 ğ‘…[ğœ‹ğ‘™]=min(max(ğ‘¦,ğ‘Ÿmin),ğ‘Ÿmax);
15 ifğœ‹ğ‘™=ğ‘—âˆ—then
16 ğ‘—âˆ—â†arg minğ‘—=1,...,ğ‘šğ‘…[ğ‘—];
the registerâ€™s index that records the sketchâ€™s minimum values. A
brief introduction to the Fisher-Yates shuffle is in Appendix A.1.
When the generated variable is smaller than ğ‘…[ğ‘—âˆ—], we early stop
the generation procedure.
Weighted Cardinality Estimation. Direct use of the estimator in
Equation (2) yields a large estimation error since the quantization
leads to a loss of precision. Instead, we design a new estimator
with the help of Maximum Likelihood Estimation (MLE). Before
that, we first derive the probability distribution of a single register
ğ‘…[ğ‘—],1â‰¤ğ‘—â‰¤ğ‘š. It has been proved that a register value ğ‘…(without
quantization) follows an exponential distribution EXP(ğ¶Î )[26,45],
in whichğ¶Î is the weighted cardinality of stream Î . In QSketch,
according to Equation (5), we quantize the continuous register value
to discrete values. Particularly, continuous register values in the
range(2âˆ’(ğ‘Ÿ+1),2âˆ’ğ‘Ÿ]will be compressed into a discrete value ğ‘Ÿ.
Then the probability distribution of a single register value ğ‘…[ğ‘–]is
ğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]=ğ‘Ÿ|ğ¶Î )=âˆ«2âˆ’ğ‘Ÿ
2âˆ’(ğ‘Ÿ+1)ğ¶Î ğ‘’âˆ’ğ¶Î ğ‘¥ğ‘‘ğ‘¥
=ğ‘’âˆ’ğ¶Î Â·2âˆ’(ğ‘Ÿ+1)âˆ’ğ‘’âˆ’ğ¶Î Â·2âˆ’ğ‘Ÿ.(7)
Given the specific register values ğ‘…[1],...,ğ‘…[ğ‘š], we compute the
likelihood function for ğ¶Î is
ğ¿(ğ¶Î )=ğ‘šÃ–
ğ‘—=1ğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]|ğ¶Î )=ğ‘šÃ–
ğ‘—=1
ğ‘’âˆ’ğ¶Î Â·2âˆ’(ğ‘…[ğ‘—]+1)âˆ’ğ‘’âˆ’ğ¶Î Â·2âˆ’ğ‘…[ğ‘—]
,
(8)and the derivative of the likelihood functionâ€™s logarithm is:
ğ‘‘(lnğ¿(ğ¶Î ))
ğ‘‘ğ¶Î =ğ‘šâˆ‘ï¸
ğ‘—=12âˆ’(ğ‘…[ğ‘—]+1)Â·2âˆ’ğ‘’ğ¶Î Â·2âˆ’(ğ‘…[ğ‘—]+1)
ğ‘’ğ¶Î Â·2âˆ’(ğ‘…[ğ‘—]+1)âˆ’1. (9)
To compute the MLE of ğ¶Î , let the above formula equal 0. Unfortu-
nately, this equation is too complicated to be solved directly. So we
use the Newton-Raphson method to obtain Ë†ğ¶Î . Specially, let
ğ‘“(ğ¶Î )=ğ‘šâˆ‘ï¸
ğ‘—=12âˆ’(ğ‘…[ğ‘—]+1)Â·2âˆ’ğ‘’ğ¶Î Â·2âˆ’(ğ‘…[ğ‘—]+1)
ğ‘’ğ¶Î Â·2âˆ’(ğ‘…[ğ‘—]+1)âˆ’1, (10)
The Newton-Raphson method [ 5] starts from an initial estimation
Ë†ğ¶(0)
Î and then repeats the following steps:
Ë†ğ¶(ğ‘™+1)
Î â†Ë†ğ¶(ğ‘™)
Î âˆ’ğ‘“(Ë†ğ¶(ğ‘™)
Î )
ğ‘“â€²(Ë†ğ¶(ğ‘™)
Î ), (11)
until Ë†ğ¶Î converges, where ğ‘“â€²(Ë†ğ¶(ğ‘™)
Î )is the derivative of ğ‘“(ğ¶Î )at
pointğ¶Î =Ë†ğ¶(ğ‘™)
Î . To start the iteration, we initialize Ë†ğ¶(0)
Î as
Ë†ğ¶(0)
Î =ğ‘šâˆ’1Ã
1â‰¤ğ‘—â‰¤ğ‘š2âˆ’ğ‘…[ğ‘—].
Since the register values in QSketch are the quantization of register
values in FastGM, Ë†ğ¶(0)
Î can be viewed as an approximation of Ë†ğ¶Î ,
which is reasonable as an initial value to guarantee convergence.
The above MLE-based estimator provides an asymptotically un-
biased estimation. The approximate variance of the above estima-
tor is based on the CramÃ©r-Rao bound [ 12]. Specifically, we have
Var[Ë†ğ¶]â‰ˆ1
ğ¼Î (Ë†ğ¶), whereğ¼Î (Ë†ğ¶)is the observed fisher information
given stream data Î , i.e., the negative of the second derivative of
the log-likelihood function at Ë†ğ¶. Formally, we have
Var[Ë†ğ¶]â‰ˆâˆ’1
ğ‘“â€²(Ë†ğ¶(ğ‘™)
Î ).
Through the quantization, all possible values of ğ‘¦(e)are integers,
i.e.,ğ‘¦(e)âˆˆZ. In practice, we notice that most values of ğ‘¦(e)are
concentrated in a small range and we can truncate these gener-
ated variables by ğ‘¦â€²(e)=min(max(ğ‘¦(e),ğ‘Ÿmin),ğ‘Ÿmax). As a result,
adjusting the probability distribution of the truncated value in each
register is necessary, as shown in Equation (7).
ğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]|ğ¶Î )=ï£±ï£´ï£´ï£´ï£´ ï£²
ï£´ï£´ï£´ï£´ï£³ğ‘’âˆ’ğ¶Î Â·2âˆ’(ğ‘Ÿmin+1), ğ‘…[ğ‘—]â‰¤ğ‘Ÿmin;
1âˆ’ğ‘’âˆ’ğ¶Î Â·2âˆ’ğ‘Ÿmax, ğ‘…[ğ‘—]â‰¥ğ‘Ÿmax;
ğ‘’âˆ’ğ¶Î Â·2âˆ’(ğ‘…[ğ‘—]+1)âˆ’ğ‘’âˆ’ğ¶Î Â·2âˆ’ğ‘…[ğ‘—],otherwise.
By substituting the above probability to Equation (8), we get the
weighted cardinality estimator under truncated values. Note that
the estimator only fails to give an unbiased estimation when all
register values equal ğ‘Ÿminorğ‘Ÿmaxas the likelihood function ğ¿(ğ¶Î )
becomes monotonous without an extremum. Fortunately, in the
following theorem, we show that by properly setting ğ‘Ÿminandğ‘Ÿmax,
the failure probability is extremely low.
Theorem 1.Let0<ğœ€â‰ª1be a small positive value. Given a
sketch ofğ‘šregisters with minimal value ğ‘Ÿminand maximal value
ğ‘Ÿmax, whenâˆ’2(ğ‘Ÿmin+1)Â·lnğœ–<ğ¶Î <âˆ’2ğ‘Ÿmaxln(1âˆ’ğœ–), the register
 
2435QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
values are not in the discrete set {ğ‘Ÿmin,...,ğ‘Ÿ max}within a maximum
probability of 2ğœ–.
The proof is in Appendix A.2. When ğ‘Ÿmin=âˆ’127,ğ‘Ÿmax=127,
andğœ€=0.001, each register value at time ğ‘¡is not tuncatated with a
probability of more than 0.998when 8.1Ã—10âˆ’38â‰¤ğ¶Î â‰¤3.4Ã—1035.
In this case, we need just 8bits to store the register values.
4.3 QSketch-Dyn
QSketch has the same expected time complexity of ğ‘‚(ğ‘šÂ·lnğ‘š+ğ‘›)
as FastGM [ 33,45]. However, it still suffers from the worst time
complexityğ‘‚(ğ‘šÂ·ğ‘›)under scenarios in which the weights of the ele-
ments increase as time progresses. In addition, we have to solve the
MLE problem whenever figuring out the latest weighted cardinality,
which costs for real-time estimation. To improve the estimation ef-
ficiency, we utilize the dynamic property of the sketch and propose
QSketch-Dyn to keep track of the weighted cardinality on the fly.
Data structure and update procedure. QSketch-Dyn shares the
same data structure, i.e., a bit array of size ğ‘š, and the same set
of hash functions â„1,...,â„ğ‘šas Lemieszâ€™s method [ 26]. The main
differences are: 1) QSketch-Dyn introduces another hash function
ğ‘”(ğ‘¥), which uniformly maps ğ‘¥to some integer in set {1,...,ğ‘š}
at random. 2) QSketch-Dyn maintains a tabular ğ‘‡to record the
frequency of values in the sketch. Specifically, the tabular ğ‘‡consists
of2ğ‘counters, in which ğ‘is the number of bits used by a register.
Next, we introduce how to update an element e(ğ‘¡)correspond-
ing toğ‘¥andğ‘¤. Instead of updating multiple register values as in
other methods, QSketch-Dyn first randomly chooses one register
ğ‘…[ğ‘—]withğ‘—=ğ‘”(ğ‘¥),1â‰¤ğ‘—â‰¤ğ‘šfrom the sketch, computes its
quantized hash value ğ‘¦ğ‘—(e)=âŒŠâˆ’log2(ğ‘Ÿğ‘—(e))âŒ‹(Equation 5), and
update the register value ğ‘…[ğ‘—]â† max(ğ‘…[ğ‘—],ğ‘¦ğ‘—(e))(Equation 6).
Once the register value ğ‘…[ğ‘—]changes, we then update the tabular
ğ‘‡asğ‘‡[ğ‘…[ğ‘—]]â†ğ‘‡[ğ‘…[ğ‘—]]âˆ’ 1andğ‘‡[ğ‘¦ğ‘—(e)]â†ğ‘‡[ğ‘¦ğ‘—(e)]+ 1.
Weighted Cardinality Estimation. Denoteğ‘(ğ‘¡)
ğ‘…as the probability
ofe(ğ‘¡)changing a register among ğ‘…[1],...,ğ‘…[ğ‘š]at timeğ‘¡,
ğ‘(ğ‘¡)
ğ‘…â‰œâˆ‘ï¸
1â‰¤ğ‘—â‰¤ğ‘šğ‘ƒğ‘Ÿ(ğ‘¦>ğ‘…[ğ‘—]âˆ§ğ‘”(ğ‘¥)=ğ‘—|ğ‘…[ğ‘—])
=âˆ‘ï¸
1â‰¤ğ‘—â‰¤ğ‘šğ‘ƒğ‘Ÿ(ğ‘¦â‰¥ğ‘…[ğ‘—]+1|ğ‘…[ğ‘—])Â·ğ‘ƒğ‘Ÿ(ğ‘”(ğ‘¥)=ğ‘—)
=1
ğ‘šÂ·âˆ‘ï¸
1â‰¤ğ‘—â‰¤ğ‘šâˆ«2âˆ’(ğ‘…[ğ‘—]+1)
0ğ‘¤Â·ğ‘’âˆ’ğ‘¤ğ‘¥ğ‘‘ğ‘¥
=1âˆ’1
ğ‘šâˆ‘ï¸
1â‰¤ğ‘—â‰¤ğ‘šğ‘’âˆ’ğ‘¤Â·(2âˆ’(ğ‘…[ğ‘—]+1)).
LetË†ğ¶(ğ‘¡)
Î denote the weighted cardinality estimate of stream Î at
timeğ‘¡. When element earrives at time ğ‘¡, we update the weighted
cardinality estimate as
Ë†ğ¶(ğ‘¡)
Î â†Ë†ğ¶(ğ‘¡âˆ’1)
Î +1(ğ‘…[ğ‘—](ğ‘¡)â‰ ğ‘…[ğ‘—](ğ‘¡âˆ’1))
ğ‘(ğ‘¡)
ğ‘…Â·ğ‘¤, (12)
in which 1(ğ‘…[ğ‘—](ğ‘¡)â‰ ğ‘…[ğ‘—](ğ‘¡âˆ’1))is an indicator variable which
equals to 1 if element echanges the register value ğ‘…[ğ‘—](remind
thatğ‘—=ğ‘”(ğ‘¥)) and equals to 0 otherwise. In later analysis, we will
prove that Ë†ğ¶(ğ‘¡)
Î is an unbiased estimation of ğ¶(ğ‘¡)
Î .Algorithm 3: Update procedure of QSketch-Dyn.
input : stream Î , sketch size ğ‘š, register size ğ‘.
output: Estimated weighted cardinality Ë†ğ¶.
1ğ‘Ÿâ†0;ğ‘ğ‘…â†0;Ë†ğ¶â†0;
2ğ‘…â†[ğ‘Ÿmin,...,ğ‘Ÿ min];ğ‘‡â†[0,0,..., 0];
3foreach eâˆˆÎ do
/* corresponding to element ğ‘¥with weight ğ‘¤.
*/
4ğ‘—â†RandInt(1,ğ‘š);
5ğ‘Ÿâ†âˆ’lnâ„ğ‘—(ğ‘¥)
ğ‘¤;
6ğ‘¦â†âŒŠâˆ’ log2(ğ‘Ÿ)âŒ‹;
7 ifğ‘¦>ğ‘…[ğ‘—]then
8 ifğ‘‡[ğ‘…[ğ‘—]âˆ’ğ‘Ÿmin]>0then
9 ğ‘‡[ğ‘…[ğ‘—]âˆ’ğ‘Ÿmin]â†ğ‘‡[ğ‘…[ğ‘—]âˆ’ğ‘Ÿmin]âˆ’1;
10 ğ‘‡[ğ‘¦âˆ’ğ‘Ÿmin]â†ğ‘‡[ğ‘¦âˆ’ğ‘Ÿmin]+1;
11 else
12 ğ‘‡[ğ‘¦âˆ’ğ‘Ÿmin]â†ğ‘‡[ğ‘¦âˆ’ğ‘Ÿmin]+1;
13ğ‘…[ğ‘—]â† min(ğ‘¦,ğ‘Ÿmax);
14ğ‘â†0;
15 forğ‘˜=0,..., 2ğ‘âˆ’1do
16 ğ‘â†ğ‘+ğ‘‡[ğ‘˜]Â·ğ‘’âˆ’ğ‘¤Â·2âˆ’(ğ‘˜+ğ‘Ÿmin+1);
17ğ‘ğ‘…=1âˆ’ğ‘
ğ‘š;
18 Ë†ğ¶â†Ë†ğ¶+ğ‘¤
ğ‘ğ‘…;
The computation of probability ğ‘(ğ‘¡)
ğ‘…needs summation over all ğ‘š
registers, which is time-consuming when ğ‘šis set to a large value.
To save time, we additionally maintain a tabular ğ‘‡recording the
histogram of register values as mentioned above, where ğ‘‡[ğ‘…[ğ‘—]]
tracks the count of value ğ‘…[ğ‘—]in the current sketch. As discussed
previously, each register occupies ğ‘bits and the number of different
values is at most 2ğ‘. Then,ğ‘(ğ‘¡)
ğ‘…is expressed as
ğ‘(ğ‘¡)
ğ‘…=1âˆ’1
ğ‘šâˆ‘ï¸
1â‰¤ğ‘—â‰¤2ğ‘ğ‘‡[ğ‘…[ğ‘—]]Â·ğ‘’âˆ’ğ‘¤Â·(2âˆ’(ğ‘…[ğ‘—]+1)).
We summarize the pseudo-code of the update and estimation pro-
cedure of QSketch-Dyn in Algorithm 3.
Complexity Analysis. The time complexity of updating an ele-
ment for QSketch-Dyn is ğ‘‚(1)since it only chooses one register
to update its value. Then it costs ğ‘‚(2ğ‘)time for QSketch-Dyn to
computeğ‘(ğ‘¡)
ğ‘…. Considering that ğ‘is small, this part costs little time.
Finally, QSketch-Dyn tracks the estimated cardinality over time,
and it costs no time for estimation compared with QSketch. For
space complexity, QSketch uses ğ‘šregisters, in which each register
occupiesğ‘bits. Besides, QSketch-Dyn maintains a tabular ğ‘‡with 2ğ‘
counters. Since there are ğ‘šregisters in the sketch, each counter of
tabularğ‘‡occupies at most log2(ğ‘š)bits. Therefore, the total space
complexity is ğ‘šÂ·ğ‘+2ğ‘Â·log2(ğ‘š).
Error Analysis. For the estimated weighted cardinality Ë†ğ¶(ğ‘¡)
Î from
QSketch-Dyn, we first prove that our estimator is unbiased and
then derive the variance of Ë†ğ¶(ğ‘¡)
Î .
 
2436KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Yiyan Qi et al.
Table 1: Statistics of real-world datasets.
Dataset #Documents Vector Size
Real-sim [39] 72,309 20,958
Rcv1 [28] 20,242 47,236
Webspam [36] 350,000 16,609,143
News20 [24] 19,996 1,355,191
Libimseti [25] 220,970 220,970
Theorem 2.The expectation and variance of Ë†ğ¶(ğ‘¡)
Î are
E[Ë†ğ¶(ğ‘¡)
Î ]=ğ¶(ğ‘¡)
Î ,
Var[Ë†ğ¶(ğ‘¡)
Î ]=âˆ‘ï¸
ğ‘–âˆˆğ‘‡(ğ‘¡)
ğ‘ (ğ‘¤(ğ‘–))2E[1âˆ’ğ‘(ğ‘–)
ğ‘…
ğ‘(ğ‘–)
ğ‘…],
whereğ‘‡(ğ‘¡)
ğ‘ is the set of timestamps that each element appears in the
stream for the first time.
Proof. See Appendix A.3 â–¡
5 EVALUATION
All algorithms are implemented in C++ and run on a processor
with a Quad-Core Intel(R) Xeon(R) CPU E3-1226 v3 CPU 3.30GHz
processor. Our source code is available [4].
5.1 Datasets
We conduct experiments on both synthetic and real-world datasets.
â€¢Synthetic Datasets. We generate synthetic datasets with the
following distributions: Uniform distribution ğ‘ˆ(0,1), Gauss distri-
butionğ‘(1,0.1), and Gamma distribution ğ›¾(1,2)For each type of
distribution, we generate datasets with different sizes of elements,
respectively. The name of the dataset is represented as â€œdistribution-
#elementsâ€. For example, Uniform-1k represents the dataset with
1,000elements, and the weight of each element follows the Uniform
distribution ğ‘(0,1). Each dataset is considered a single stream.
â€¢Real-world Datasets. We use the following real-world datasets:
Twitter [1],Real-sim [39],Rcv1 [28],Webspam [36],News20 [24]
Libimseti [25]. Twitter [ 1] is a dataset of â€œfollowingâ€ relation-
ships between Twitter users. The above two datasets are treated
as single-stream datasets. Real-sim [ 39], Rcv1 [ 28], Webspam [ 36]
and News20 [ 24] are datasets of web documents from different
resources, where each vector represents a document and each entry
in the vector refers to the TF-IDF score of a specific word for the
document. Libimseti [ 25] is a dataset of ratings of different users,
where each vector refers to a user and each entry records the userâ€™s
rating. These six datasets are considered multi-stream datasets, and
each vector within the dataset is a single stream of elements with a
weight. The details of these datasets are described in Table 1.
5.2 Baselines
We compare QSketch and QSketch-Dyn, with state-of-the-art meth-
ods, Lemieszâ€™s method [ 26] (represented as LM), FastGM [ 45] and
FastExp Sketch [ 27]. All baseline methods maintain a sketch with
ğ‘š64-bit registers. QSketch and QSketch-Dyn are truncated with
ğ‘Ÿmin=âˆ’127andğ‘Ÿmax=127, i.e., they all use 8-bit integer registers
by default. We assign each algorithm the same number of registers,which means QSketch and QSketch-Dyn use about 1/8 of the mem-
ory space of baseline methods. Following [ 3], we use a 32-bit word
to hold multiple short-bit registers. For example, with each register
set to 8 bits, a 32-bit word can hold âŒŠ32
8âŒ‹=4registers.
5.3 Metrics
â€¢Accuracy. We use Relative Root Mean Square Error (RRMSE) and
Average Absolute Relative Error (AARE) to evaluate the estimation
accuracy on single-stream datasets and multi-stream datasets, re-
spectively. In detail, the RRMSE of estimation Ë†ğ¶is defined as
ğ‘…ğ‘…ğ‘€ğ‘†ğ¸(Ë†ğ¶)=âˆšï¸ƒ
E[(Ë†ğ¶âˆ’ğ¶)2]
ğ¶,
and the AARE is defined as
ğ´ğ´ğ‘…ğ¸ =1
ğ‘›ğ‘›âˆ‘ï¸
ğ‘–=1|Ë†ğ¶ğ‘–âˆ’ğ¶ğ‘–|
|ğ¶ğ‘–|.
â€¢Efficiency. We use Throughput (Million updates per second,
Mops) to evaluate the update speed for incoming elements, and
Esimation time to assess the time taken to calculate the weighted
cardinality from the sketch. All experimental results are empirically
computed from 100 independent runs by default.
5.4 Accuracy Analysis
5.4.1 Results on Real-World Datasets. Figure 2 shows the results
on accuracy concerning the number of registers in a sketch on
real-world datasets. Specially, we vary the number of registers in
each sketchğ‘šâˆˆ{26,27,28,29,210,211,212}. For dataset Twitter and
the other 3 document datasets, we evaluate RRMSE and AARE w.r.t.
the number of registers, respectively. Notably, QSketch demon-
strates comparable performance to other baseline methods across
all datasets. Conversely, QSketch-Dyn outperforms its competitors,
leveraging the dynamic nature of the sketch. For example, on the
dataset Twitter, our method QSketch-Dyn is 30% more accurate
than alternative methods with the number of registers ğ‘š=28. It
is imperative to emphasize that QSketch and QSketch-Dyn utilize
only 1/8of the memory compared to LM and FastGM.
5.4.2 Results on Synthetic Datasets. To comprehensively assess the
efficacy of QSketch across diverse scenarios, we conduct a thorough
evaluation comparing its performance with that of other baseline
methods. This evaluation encompasses a range of factors including
data distribution, dataset scale, register count, and register size.
Performance under different data distribution. We compare
our methods QSketch and QSketch-Dyn with other methods on
synthetic datasets from different distributions. Figure 3 illustrates
the comparative performance. Remarkably, QSketch-Dyn consis-
tently outperforms other methods across all distributions, the same
as real-world dataset results.
Performance under different dataset sizes. Next, we explore
the performance of our methodologies across varying dataset sizes.
We generate datasets from three distributions at different scales
ranging from 102to106. The results of the remaining two distri-
butions are summarized in the Appendix. The number of registers
for all methods is fixed at 28. As shown in Figure 4, QSketch, LM,
FastGM, and FastExp Sketch estimation errors remain consistent
across all dataset scales. However, the performance of QSketch-Dyn
 
2437QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Twitter
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Libimseti
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) News20
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(d) Rcv1
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (e) Real-sim
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000024/uni00000024/uni00000035/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (f) Webspam
Figure 2: Accuracy of all methods under different numbers of registers on real-world datasets.
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Gamma-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Gauss-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056/uni00000013/uni00000013/uni00000011/uni00000013/uni00000017/uni00000013/uni00000011/uni00000013/uni0000001b/uni00000013/uni00000011/uni00000014/uni00000015/uni00000013/uni00000011/uni00000014/uni00000019/uni00000013/uni00000011/uni00000015/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) Uniform-10k
Figure 3: Accuracy of all methods under different numbers of registers on synthetic datasets.
102
103
104
105
106
/uni00000027/uni00000044/uni00000057/uni00000044/uni00000003/uni00000036/uni0000004c/uni0000005d/uni00000048/uni00000013/uni00000013/uni00000011/uni00000013/uni00000018/uni00000013/uni00000011/uni00000014/uni00000013/uni00000013/uni00000011/uni00000014/uni00000018/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Gamma distribution
102
103
104
105
106
/uni00000027/uni00000044/uni00000057/uni00000044/uni00000003/uni00000036/uni0000004c/uni0000005d/uni00000048/uni00000013/uni00000013/uni00000011/uni00000013/uni00000018/uni00000013/uni00000011/uni00000014/uni00000013/uni00000013/uni00000011/uni00000014/uni00000018/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Gauss distribution
102
103
104
105
106
/uni00000027/uni00000044/uni00000057/uni00000044/uni00000003/uni00000036/uni0000004c/uni0000005d/uni00000048/uni00000013/uni00000013/uni00000011/uni00000013/uni00000018/uni00000013/uni00000011/uni00000014/uni00000013/uni00000013/uni00000011/uni00000014/uni00000018/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) Uniform distribution
Figure 4: Accuracy of all methods under different data sizes on synthetic datasets.
shows a slight improvement with increasing dataset scale, with the
estimation error stabilizing around 0.05for dataset sizes exceeding
104. This phenomenon primarily stems from the fact that, with
smaller dataset sizes, most registers in QSketch-Dyn are populated
by only one element, resulting in nearly exact counting.
Performance under different register size. As mentioned in
Theorem 1, the bit size of the sketchâ€™s registers also influences its
performance. Figure 5 illustrates the estimation error of QSketch
and QSketch-Dyn on the Uniform-10k distribution, considering the
maximum value of the distribution ranging from 10âˆ’10to1010(i.e.,
weighted cardinality ranging from 5Ã—10âˆ’7to5Ã—1013). The numberof registers of both methods is set to 28. It is evident that when
employing 4- or 5-bit registers, both QSketch and QSketch-Dyn
offer accurate estimations within a limited range. However, with a
bit size increase to 7 or 8, both methods consistently perform well
across all values, aligning with the findings of Theorem 1.
5.5 Efficiency Analysis
For efficiency, we measure the Throughput (Millions of updates
per second) as the update speed of a sketch for incoming ele-
ments, and the Estimation time as the time taken to calculate the
weighted cardinality from the sketch.
 
2438KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Yiyan Qi et al.
1010
108
106
104
102
1001021041061081010
Maximum Value102
101
100101RRMSE
bit=4
bit=5bit=6
bit=7bit=8
(a) QSketch
1010
108
106
104
102
1001021041061081010
Maximum Value102
101
100101102RRMSE
bit=4
bit=5bit=6
bit=7bit=8 (b) QSketch-dyn
Figure 5: Accuracy of our methods QSketch and QSketch-Dyn under different register sizes on synthetic datasets.
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Twitter
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Libimseti
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) News20
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(d) Rcv1
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (e) Real-sim
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
102
101
100101102/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (f) Webspam
Figure 6: Update throughput of all methods under different numbers of registers on real-world datasets.
5.5.1 Results on Real-World Datasets. Figure 6 shows the results of
the update throughput on real-world datasets. The throughput for
LM, FastGM, FastExp Sketch, and QSketch demonstrates a decrease
with more registers in the sketch. Moreover, the update throughput
for FastGM and FastExp Sketch exhibits similarity and is faster than
LM. For QSketch, since it uses packed integers for implementation,
it needs fewer memory accesses than FastGM and FastExp, which
leads to a large update throughput on most datasets. The update
throughput for QSketch-Dyn remains nearly consistent across vary-
ing numbers of registers. Specifically, on dataset Rcv1, the update
time for QSketch-Dyn is approximately 2 to 3 orders of magnitude
shorter compared to FastGM and LM, respectively.
5.5.2 Results on Synthetic Datasets. Figure 7 shows the experimen-
tal results of update throughput on synthetic datasets with three
different distributions. Remarkably, the update throughput exhibits
similar trends across all three distributions. Overall, QSketch-Dyn
emerges as the superior performer among all competitors, a trend
consistent with the results observed on real-world datasets. Specifi-
cally, the update throughput for QSketch-Dyn is approximately 10
and 100 times shorter compared to FastGM and LM, respectively.
Figure 8 shows the estimation time of all methods on three synthetic
datasets. We omit similar results on other datasets. The estimationtime of LM, FastGM, and FastExp Sketch is only related to the num-
ber of registers in the sketch. QSketch needs several iterations for
convergence, which costs more time. Fortunately, in practical appli-
cation scenarios, the estimation procedure may happen much less
frequently than the update procedure, and the absolute estimation
time of QSketch is only 0.01s when using 4,096registers, which
is acceptable. Besides, QSketch-Dyn keeps track of the weighted
cardinality on the fly, and it does not need an estimation procedure.
6 RELATED WORK
6.1 Cardinality Estimation
Harmouch et al. [ 21] give a comprehensive review of existing sketch
methods of estimating the cardinality. Whang et al. [ 40] introduce
the LPC sketch using random hash functions for element map-
ping. Various enhancements to LPCâ€™s estimation range were later
proposed [ 6,14]. Flajolet and Martin [ 18] develop the FM sketch,
which was subsequently refined through methods like LogLog [ 13],
HyperLogLog [ 17], RoughEstimator [ 22], and HLL-TailCut+ [ 43],
reducing register size and employing multiple registers. Giroire
et al. [ 20] develop a sketching method MinCount (also known as
bottom-ğ‘˜sketch [ 8]) which stores the ğ‘˜minimum hash values of
 
2439QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
101
101103/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Gamma-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
101
101103/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Gauss-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056103
101
101103/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (c) Uniform-10k
Figure 7: Update throughput of all methods under different numbers of registers on synthetic datasets.
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056108
106
104
102
100/uni00000028/uni00000056/uni00000057/uni0000004c/uni00000050/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni0000000b/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053
(a) Gamma-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056108
106
104
102
100/uni00000028/uni00000056/uni00000057/uni0000004c/uni00000050/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni0000000b/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053 (b) Gauss-10k
26
27
28
29
210
211
212
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056108
106
104
102
100/uni00000028/uni00000056/uni00000057/uni0000004c/uni00000050/uni00000044/uni00000057/uni0000004c/uni00000052/uni00000051/uni00000003/uni00000037/uni0000004c/uni00000050/uni00000048/uni0000000b/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053 (c) Geometric-10k
Figure 8: Estimation time of all methods under different numbers of registers on synthetic datasets.
elements in the set. Ting [ 34] develops a martingale-based estimator
to improve the accuracy of the above sketch methods such as LPC,
HyperLogLog, and MinCount. Chen et al. [ 7] extend HyperLogLog
to sliding windows. Besides sketch methods, two sampling meth-
ods [16, 19] are also proposed for cardinality estimation. Recently,
considerable attention [ 37,42,44,46] has been given to developing
fast sketch methods for monitoring the cardinalities of network
hosts over high-speed links. Ting [ 35] developed methods to esti-
mate the cardinality of set unions and intersections from MinCount
sketches. Cohen et al. [ 10] developed a method combining MinHash
and HyperLogLog to estimate set intersection cardinalities. Karppa
et al. [ 23] optimized HyperLogLog by decomposing register values
into a base value and an offset vector, leading to more efficient
storage. Very recently, Wang et al. [ 38] proposed a method named
Half-Xor to handle element deletions in cardinality estimation.
6.2 Weighted Cardinality Estimation
To estimate the weighted cardinality, Considine et al. [ 11] used
binary representations to represent integer weights, which is not
efficient for elements with large weights. Cohen et al. [ 9] proposed a
weighted estimator based on bottom- ğ‘˜sketches. However, bottom-
ğ‘˜sketches require maintaining a sorted list of the ğ‘˜smallest values,
which needs more updating time and memory usage. Recently,
Lemiesz [ 26] presented a method that maps each element to ğ‘šex-
ponential distributed variables. Thus it needs ğ‘‚(ğ‘š)time to process
an incoming element, which is infeasible for high-speed streams.
Therefore, Zhang et al. [ 45] proposed FastGM to accelerate [ 26].
FastGM generates these exponential variables in ascending order
and stops the generation in advance if the generated value is greater
than the maximal value in current registers. As a recent simultane-
ous work, FastExpSketch [ 27] shares the same idea with FastGM.
However, these methods store generated values with 32-bit or 64-bit
floating-point registers. When we need a large ğ‘što achieve betteraccuracy or there are many different streams, it is memory-intensive
for devices with limited computational and storage resources. In
addition, these methods need ğ‘‚(ğ‘š)to estimate weighted cardinal-
ity, and it is not efficient for them to provide anytime-available
estimation for real-time applications.
7 CONCLUSIONS AND FUTURE WORK
This paper introduces QSketch, a memory-efficient sketching tech-
nique that leverages quantization methods to transform continuous
register values into discrete integers. Unlike traditional sketching
approaches which allocate 64 bits per register, our QSketch achieves
comparable performance using only 8 bits per register. The QSketch
experiences a worst-case time of ğ‘‚(ğ‘šÂ·ğ‘›)where the weights of
elements increase over time, and it needs to solve an MLE prob-
lem through the Newton-Raphson method, which introduces extra
computational overhead. Therefore, we further capitalize on the
dynamic nature of sketches by proposing QSketch-Dyn, which en-
ables real-time monitoring of weighted cardinality. This enhanced
method reduces estimation errors and maintains a constant time
complexity for updates. We validate our approach through experi-
ments conducted on both synthetic and real-world datasets. The
results demonstrate that our novel sketching approach outperforms
existing methods by approximately 30%while consuming only one-
eighth of the memory. In the future, we aim to explore weighted
cardinality in streaming scenarios, particularly focusing on han-
dling element deletions and elements with negative weights.
ACKNOWLEDGMENT
The authors thank the reviewers for their comments and sugges-
tions. This work was supported by the National Natural Science
Foundation of China (U22B2019, 62372362, 62272372, 62272379).
 
2440KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Yiyan Qi et al.
REFERENCES
[1] 2010. Twitter. https://anlab-kaist.github.io/traces/
[2] 2018. CAIDA. https://www.caida.org/
[3]2022. https://github.com/mkarppa/hyperlogloglog/blob/master/hyperlogloglog/
PackedVector.hpp#L130
[4] 2024. https://github.com/Rezerolird/QSketch
[5]Saba Akram and Quarrat Ul Ann. 2015. Newton raphson method. International
Journal of Scientific & Engineering Research 6, 7 (2015), 1748â€“1752.
[6]Aiyou Chen, Jin Cao, Larry Shepp, and Tuan Nguyen. 2011. Distinct counting
with a self-learning bitmap. JASA 106, 495 (2011), 879â€“890.
[7]Wenji Chen, Yang Liu, and Yong Guan. 2013. Cardinality change-based early
detection of large-scale cyber-attacks. In IEEE INFOCOM. 1788â€“1796.
[8]Edith Cohen and Haim Kaplan. 2007. Summarizing data using bottom-k sketches.
InPODC. 225â€“234.
[9]Edith Cohen and Haim Kaplan. 2008. Tighter estimation using bottom k sketches.
PVLDB 1, 1 (2008), 213â€“224.
[10] Reuven Cohen, Liran Katzir, and Aviv Yehezkel. 2017. A minimal variance
estimator for the cardinality of big data set intersection. In ACM SIGKDD. 95â€“
103.
[11] Jeffrey Considine, Feifei Li, George Kollios, and John Byers. 2004. Approximate
aggregation techniques for sensor databases. In IEEE ICDE. 449â€“460.
[12] Harald CramÃ©r. 1999. Mathematical methods of statistics. Vol. 26. Princeton
university press.
[13] Marianne Durand and Philippe Flajolet. 2003. Loglog counting of large cardinali-
ties. In ESA. 605â€“617.
[14] Cristian Estan, George Varghese, and Mike Fisk. 2003. Bitmap algorithms for
counting active flows on high speed links. In SIGCOMM. 153â€“166.
[15] Ronald A Fisher and Frank Yates. 1938. Statistical tables: For biological, agricultural
and medical research. Oliver and Boyd.
[16] P. Flajolet. 1990. On Adaptive Sampling. Computing 43, 4 (1990), 391â€“400.
[17] Philippe Flajolet, Ã‰ric Fusy, Olivier Gandouet, and FrÃ©dÃ©ric Meunier. 2007. Hyper-
loglog: the analysis of a near-optimal cardinality estimation algorithm. DMTCS
Proceedings (2007).
[18] Philippe Flajolet and G Nigel Martin. 1985. Probabilistic counting algorithms for
data base applications. JCSS 31, 2 (1985), 182â€“209.
[19] Phillip B Gibbons. 2001. Distinct sampling for highly-accurate answers to distinct
values queries and event reports. In VLDB, Vol. 1. 541â€“550.
[20] FrÃ©dÃ©ric Giroire. 2009. Order statistics and estimating cardinalities of massive
data sets. DAM 157, 2 (2009), 406â€“427.
[21] Hazar Harmouch and Felix Naumann. 2017. Cardinality estimation: An experi-
mental survey. PVLDB 11, 4 (2017), 499â€“512.
[22] Daniel M Kane, Jelani Nelson, and David P Woodruff. 2010. An optimal algorithm
for the distinct elements problem. In PODS. 41â€“52.
[23] Matti Karppa and Rasmus Pagh. 2022. HyperLogLogLog: Cardinality Estimation
With One Log More. In ACM SIGKDD. 753â€“761.
[24] S Sathiya Keerthi, Dennis DeCoste, and Thorsten Joachims. 2005. A modified
finite Newton method for fast solution of large scale linear SVMs. Journal of
Machine Learning Research 6, 3 (2005).
[25] JÃ©rÃ´me Kunegis, Gerd GrÃ¶ner, and Thomas Gottron. 2012. Online dating recom-
mender systems: The split-complex number approach. In Proceedings of the 4th
ACM RecSys workshop on Recommender systems and the social web. 37â€“44.
[26] Jakub Lemiesz. 2021. On the algebra of data sketches. PVLDB 14, 9 (2021),
1655â€“1667.[27] Jakub Lemiesz. 2023. Efficient framework for operating on data sketches. PVLDB
16, 8 (2023), 1967â€“1978.
[28] David D Lewis, Yiming Yang, Tony Russell-Rose, and Fan Li. 2004. Rcv1: A
new benchmark collection for text categorization research. JMLR 5, Apr (2004),
361â€“397.
[29] Ping Li and Christian KÃ¶nig. 2010. b-Bit minwise hashing. In WWW. 671â€“680.
[30] Xiaohui Long and Torsten Suel. 2005. Three-level caching for efficient query
processing in large web search engines. In WebConf. 257â€“266.
[31] Rifat Ozcan, Ismail Sengor Altingovde, and Ã–zgÃ¼r Ulusoy. 2011. Cost-aware
strategies for query result caching in web search engines. ACM TWEB 5, 2 (2011),
1â€“25.
[32] Christopher R Palmer, Georgos Siganos, Michalis Faloutsos, Christos Faloutsos,
and Phillip B Gibbons. 2001. The connectivity and fault-tolerance of the Internet
topology. (2001).
[33] Yiyan Qi, Pinghui Wang, Yuanming Zhang, Junzhou Zhao, Guangjian Tian, and
Xiaohong Guan. 2020. Fast generating a large number of gumbel-max variables.
InWebConf. 796â€“807.
[34] Daniel Ting. 2014. Streamed Approximate Counting of Distinct Elements: Beating
Optimal Batch Methods. In ACM SIGKDD. 442â€“451.
[35] Daniel Ting. 2016. Towards optimal cardinality estimation of unions and inter-
sections with sketches. In ACM SIGKDD. 1195â€“1204.
[36] De Wang, Danesh Irani, and Calton Pu. 2012. Evolutionary study of web spam:
Webb spam corpus 2011 versus webb spam corpus 2006. In IEEE CollaborateCom.
40â€“49.
[37] Pinghui Wang, Xiaohong Guan, Tao Qin, and Qiuzhen Huang. 2011. A data
streaming method for monitoring host connection degrees of high-speed links.
IEEE TIFS 6, 3 (2011), 1086â€“1098.
[38] Pinghui Wang, Dongdong Xie, Junzhou Zhao, Jinsong Li, Zhicheng Li, Rundong
Li, and Yang Ren. 2024. Half-Xor: A Fully-Dynamic Sketch for Estimating the
Number of Distinct Values in Big Tables. IEEE Transactions on Knowledge and
Data Engineering (2024).
[39] Wu Wei, Bin Li, Chen Ling, and Chengqi Zhang. 2017. Consistent Weighted
Sampling Made More Practical. In WebConf. 1035â€“1043.
[40] Kyu-Young Whang, Brad T Vander-Zanden, and Howard M Taylor. 1990. A
linear-time probabilistic counting algorithm for database applications. ACM
TODS 15, 2 (1990), 208â€“229.
[41] Viktor Witkovsk `y. 2001. Computing the distribution of a linear combination of
inverted gamma variables. Science Direct Working Paper S1574-0358 (2001), 04.
[42] Qingjun Xiao, Shigang Chen, Min Chen, and Yibei Ling. 2015. Hyper-compact
virtual estimators for big network data based on register sharing. In ACM SIG-
METRICS. 417â€“428.
[43] Qingjun Xiao, You Zhou, and Shigang Chen. 2017. Better with fewer bits: Im-
proving the performance of cardinality estimation of large data streams. In IEEE
INFOCOM. 1â€“9.
[44] M Yoon, Tao Li, Shigang Chen, and J-K Peir. 2009. Fit a spread estimator in small
memory. In IEEE INFOCOM. 504â€“512.
[45] Yuanming Zhang, Pinghui Wang, Yiyan Qi, Kuankuan Cheng, Junzhou Zhao,
Guangjian Tian, and Xiaohong Guan. 2023. Fast Gumbel-Max Sketch and its
Applications. IEEE TKDE (2023).
[46] Qi Zhao, Abhishek Kumar, and Jun Xu. 2005. Joint Data Streaming and Sampling
Techniques for Detection of Super Sources and Destinations.. In ACM SIGCOMM .
77â€“90.
 
2441QSketch: An Efficient Sketch for Weighted Cardinality Estimation in Streams KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
26
27
28
29
210
211
212
213
#Registers100101102103104Vallue of alpha
n=102
n=103n=104
n=105
Figure 9: The value of alpha with different ğ‘›andğ‘šon uni-
form distribution.
A APPENDXIX
A.1 Fisher-Yates shuffle
The Fisher-Yates shuffle is commonly utilized to generate an un-
biased permutation step-by-step. The pseudocode of the shuffle
is summarized in Algorithm 4. Note that after the ğ‘–-th step of the
Fisher-Yates shuffle, the first ğ‘–positions of the permutation are
computed and fixed.
Algorithm 4: Fisher-Yates shuffle.
input : An initial permutation [ğœ‹1,...,ğœ‹ğ‘š].
output: Shuffled permutation [ğœ‹â€²
1,...,ğœ‹â€²ğ‘š].
1[ğœ‹1,...,ğœ‹ğ‘š]â†[ 1,...,ğ‘š];
2foreachğ‘–âˆˆ{1,...,ğ‘š}do
3ğ‘˜â†RandInt(ğ‘–,ğ‘š);
4 Swap(ğœ‹ğ‘˜,ğœ‹ğ‘–);
A.2 Proof of Theorem 1
According to Equation (7), the probability that a register value
ğ‘…[ğ‘—]â‰¤ğ‘Ÿminorğ‘…[ğ‘—]â‰¥ğ‘Ÿmaxis computed as,
ğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]â‰¤ğ‘Ÿmin)=ğ‘Ÿminâˆ‘ï¸
ğ‘Ÿ=âˆ’âˆğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]=ğ‘Ÿ)
=âˆ«+âˆ
2âˆ’(ğ‘Ÿmin+1)ğ¶Î Â·ğ‘’âˆ’ğ¶Î ğ‘¥ğ‘‘ğ‘¥
=ğ‘’âˆ’ğ¶Î Â·2âˆ’(ğ‘Ÿmin+1),
and
ğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]â‰¥ğ‘Ÿmax)=ğ‘Ÿ=+âˆâˆ‘ï¸
ğ‘Ÿminğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]=ğ‘Ÿ)
=âˆ«2âˆ’ğ‘Ÿmax
0ğ¶Î Â·ğ‘’âˆ’ğ¶Î ğ‘¥ğ‘‘ğ‘¥
=1âˆ’ğ‘’âˆ’ğ‘Î Â·2âˆ’ğ‘Ÿmax.
By settingğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]â‰¤ğ‘Ÿmin)<ğœ–andğ‘ƒğ‘Ÿ(ğ‘…[ğ‘—]â‰¥ğ‘Ÿmax)<ğœ–simulta-
neously for above formulas, we have
âˆ’2(ğ‘Ÿmin+1)Â·lnğœ–<ğ¶Î <âˆ’2ğ‘ŸmaxÂ·ln(1âˆ’ğœ–),
which is the conclusion of the theorem.A.3 Proof of Theorem 2
Given the data stream Î the set of timestamps that each element
appears in the stream for the first time ğ‘‡(ğ‘¡)
ğ‘ , we first derive the
expectation. Let 1(ğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1))demote an indicator of whether
the state of sketch ğ‘…has changed at time ğ‘¡, i.e.,1(ğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1))=1
forğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1)and0otherwise. We note that ğ‘(ğ‘¡)
ğ‘…only depends
onğ‘…(ğ‘¡âˆ’1)and then we have
E[1(ğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1))|ğ‘(ğ‘¡)
ğ‘…]=E[1(ğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1))|ğ‘…(ğ‘¡âˆ’1)]=ğ‘(ğ‘¡)
ğ‘….
From the linearity of expectation and the law of total expectation,
we have
E[Ë†ğ¶(ğ‘¡)
Î ]=E[E[Ë†ğ¶(ğ‘¡)
Î |ğ‘…(ğ‘¡âˆ’1)]]
=E[E[Ë†ğ¶(ğ‘¡âˆ’1)
Î |ğ‘…(ğ‘¡âˆ’1)]+E[1(ğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1))
ğ‘(ğ‘¡)
ğ‘…ğ‘¤(ğ‘¡)|ğ‘…(ğ‘¡âˆ’1)]]
=E[Ë†ğ¶(ğ‘¡âˆ’1)
Î ]+ğ‘¤(ğ‘¡)=ğ¶(ğ‘¡)
Î .
For the variance, we have
Var[Ë†ğ¶(ğ‘¡)
Î ]=E[(Ë†ğ¶(ğ‘¡)
Î )2]âˆ’E[Ë†ğ¶(ğ‘¡)
Î ]2=E[(Ë†ğ¶(ğ‘¡)
Î )2]âˆ’(ğ¶(ğ‘¡)
Î )2.
Following a similar derivation with the expectation, we have
E[(Ë†ğ¶(ğ‘¡)
Î )2]=E[E[(Ë†ğ¶(ğ‘¡)
Î )2|ğ‘…(ğ‘¡âˆ’1)]],
where E[(Ë†ğ¶(ğ‘¡)
Î )2|ğ‘…(ğ‘¡âˆ’1)]is computed as
E[(Ë†ğ¶(ğ‘¡)
Î )2|ğ‘…(ğ‘¡âˆ’1)]
=(Ë†ğ¶(ğ‘¡âˆ’1)
Î )2+2ğ‘¤(ğ‘¡)Ë†ğ¶(ğ‘¡âˆ’1)
Î 
ğ‘(ğ‘¡)
ğ‘…E[1(ğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1))|ğ‘…(ğ‘¡âˆ’1)]+
(ğ‘¤(ğ‘¡)
ğ‘(ğ‘¡)
ğ‘…)2E[(1(ğ‘…(ğ‘¡)â‰ ğ‘…(ğ‘¡âˆ’1)))2|ğ‘…(ğ‘¡âˆ’1)]
=(Ë†ğ¶(ğ‘¡âˆ’1)
Î )2+2ğ‘¤(ğ‘¡)Ë†ğ¶(ğ‘¡âˆ’1)
Î +(ğ‘¤(ğ‘¡))2
ğ‘(ğ‘¡)
ğ‘….
Then, we have
E[(Ë†ğ¶(ğ‘¡)
Î )2]=E[(Ë†ğ¶(ğ‘¡âˆ’1)
Î )2+2ğ‘¤(ğ‘¡)Ë†ğ¶(ğ‘¡âˆ’1)
Î +(ğ‘¤(ğ‘¡))2
ğ‘(ğ‘¡)
ğ‘…]
=E[(Ë†ğ¶(ğ‘¡âˆ’1)
Î )2]+2ğ‘¤(ğ‘¡)E[Ë†ğ¶(ğ‘¡âˆ’1)
Î ]+E[(ğ‘¤(ğ‘¡))2
ğ‘(ğ‘¡)
ğ‘…]
=âˆ‘ï¸
ğ‘–âˆˆğ‘‡(ğ‘¡)
ğ‘ E[(ğ‘¤(ğ‘–))2
ğ‘(ğ‘–)
ğ‘…]+2âˆ‘ï¸
ğ‘–,ğ‘—âˆˆğ‘‡(ğ‘¡)
ğ‘ âˆ§ğ‘–â‰ ğ‘—ğ‘¤(ğ‘–)ğ‘¤(ğ‘—).
Finally, we obtain
Var[Ë†ğ¶(ğ‘¡)
Î ]=E[(Ë†ğ¶(ğ‘¡)
Î )2]âˆ’E[Ë†ğ¶(ğ‘¡)
Î ]2=âˆ‘ï¸
ğ‘–âˆˆğ‘‡(ğ‘¡)
ğ‘ (ğ‘¤(ğ‘–))2E[1âˆ’ğ‘(ğ‘–)
ğ‘…
ğ‘(ğ‘–)
ğ‘…].
An exact expression for E[1âˆ’ğ‘(ğ‘–)
ğ‘…
ğ‘(ğ‘–)
ğ‘…]can be derived with the prob-
abilityğ‘ƒ(ğ‘…(ğ‘¡)[1]=ğ‘Ÿ1,...,ğ‘…(ğ‘¡)[ğ‘š]=ğ‘Ÿğ‘š|Î ). However, it is too
 
2442KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Yiyan Qi et al.
28
210
212
214
216
218
220
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056104
103
102
101
/uni00000035/uni00000035/uni00000030/uni00000036/uni00000028
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051
(a) Accuracy
28
210
212
214
216
218
220
/uni00000006/uni00000035/uni00000048/uni0000004a/uni0000004c/uni00000056/uni00000057/uni00000048/uni00000055/uni00000056105
103
101
101103105/uni00000037/uni0000004b/uni00000055/uni00000052/uni00000058/uni0000004a/uni0000004b/uni00000053/uni00000058/uni00000057/uni00000003/uni0000000b/uni00000030/uni00000052/uni00000053/uni00000056/uni0000000c
/uni0000002f/uni00000030
/uni00000029/uni00000044/uni00000056/uni00000057/uni0000002a/uni00000030/uni00000034/uni00000036/uni0000004e/uni00000048/uni00000057/uni00000046/uni0000004b
/uni00000029/uni00000044/uni00000056/uni00000057/uni00000028/uni0000005b/uni00000053/uni00000034/uni00000036/uni0000002e/uni00000048/uni00000057/uni00000046/uni0000004b/uni00000010/uni00000027/uni0000005c/uni00000051 (b) Update Throughput
Figure 10: Experiments on CAIDA dataset under a different number of registers.
complex to analyze. Hence, we try to approximate the variance via
the empirical analysis.
Var[Ë†ğ¶(ğ‘¡)
Î ]<ğ‘¤(ğ‘¡)
maxâˆ‘ï¸
ğ‘–âˆˆğ‘‡(ğ‘¡)
ğ‘ E[ğ‘¤(ğ‘–)
ğ‘(ğ‘–)
ğ‘…]âˆ’ğ‘¤(ğ‘¡)
maxğ¶(ğ‘¡)
Î 
=(ğ›¼ğ‘‘ğ‘–ğ‘ (ğ‘›,ğ‘š)âˆ’1)ğ‘¤(ğ‘¡)
maxğ¶(ğ‘¡)
Î ,
whereğ‘¤(ğ‘¡)
max=maxğ‘–âˆˆğ‘‡(ğ‘¡)
ğ‘ ğ‘¤(ğ‘–)andğ›¼ğ‘‘ğ‘–ğ‘ (ğ‘›,ğ‘š)is a function of num-
ber of elements ğ‘›and number of registers ğ‘š.
As an illustration, we consider a uniform distribution from the
interval(0,1). Figure 9 depicts the variation in the functionâ€™s value
across different values of ğ‘šandğ‘›. As a result, we can get an up-
per bound of the variance together with the weighted cardinality
estimation.
A.4 Results on Large-Scale Dataset CAIDA
We further conduct experiments on the CAIDA [ 2] dataset, which
consists of streams of anonymized IP items collected from high-
speed monitors by CAIDA in 2018. A 1-minute CAIDA networktraffic trace contains about 27M packets. For each packet, we con-
sider the tuple (source IP, target IP) as the identifier of the element
e, and the packet size as the weight of the element e. Experimental
results are summarized in Figure 10. We vary the number of regis-
ters in each sketch ğ‘šâˆˆ{28,210,212,214,216,218,220}, and evaluate
the RRMSE as well as the update throughput. All methods achieve
better estimation accuracy when using more registers at the cost
of lower update throughput. Besides, we observe that:
â€¢QSketch achieves similar estimation accuracy as LM, FastGM,
and FastGM, and QSketch-Dyn performs best among all meth-
ods. This is consistent with previous results. For example, when
usingğ‘š=220registers, the estimation accuracy of QSketch-Dyn is
about twice that of other methods.
â€¢The update throughput for QSketch-Dyn remains nearly
consistent across varying numbers of registers and is higher
than other methods. This is also consistent with previous results.
For example, when use ğ‘š=219registers, the update throughput
of QSketch-Dyn is about 1 Mops, while the update throughput
of FastGM, QSketch, and FastExp Sketch is only about 0.2 Mops,
which means that QSketch-Dyn is about 5Ã—faster.
 
2443