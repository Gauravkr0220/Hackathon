A Unified Core Structure in Multiplex Networks: From Finding
the Densest Subgraph to Modeling User Engagement
Farnoosh Hashemi
Cornell University
Ithaca, NY, USA
sh2574@cornell.eduAli Behrouz
Cornell University
Ithaca, NY, USA
ab2947@Cornell.edu
ABSTRACT
In many complex systems, the interactions between objects span
multiple aspects. Multiplex networks are accurate paradigms to
model such systems, where each edge is associated with a type. A
key graph mining primitive is extracting dense subgraphs, and this
has led to interesting notions such as ğ‘˜-cores, known as building
blocks of complex networks. Despite recent attempts to extend the
notion of core to multiplex networks, existing studies suffer from a
subset of the following limitations: They 1force all nodes to exhibit
their high degree in the same set of relation types while in multiplex
networks some connection types can be noisy for some nodes, 2
either require high computational cost or miss the complex informa-
tion of multiplex networks, and 3assume the same importance for
all relation types. We introduce S-core, a novel and unifying family
of dense structures in multiplex networks that uses a function S(.)
to summarize the degree vector of each node. We then discuss how
one can choose a proper S(.)from the data. To demonstrate the
usefulness of S-cores, we focus on finding the densest subgraph
as well as modeling user engagement in multiplex networks. We
present a new density measure in multiplex networks and discuss
its advantages over existing density measures. We show that the
problem of finding the densest subgraph in multiplex networks is
NP-hard and design an efficient approximation algorithm based
onS-cores. Finally, we present a new mathematical model of user
engagement in the presence of different relation types. Our experi-
ments shows the efficiency and effectiveness of our algorithms and
supports the proposed mathematical model of user engagement.
CCS CONCEPTS
â€¢Mathematics of computing â†’Graph theory; â€¢Theory of
computationâ†’Graph algorithms analysis.
KEYWORDS
Multiplex Networks, ğ‘˜-core, Densest Subgraph, User Engagement
ACM Reference Format:
Farnoosh Hashemi and Ali Behrouz. 2024. A Unified Core Structure in Mul-
tiplex Networks: From Finding the Densest Subgraph to Modeling User En-
gagement. In Proceedings of the 30th ACM SIGKDD Conference on Knowledge
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3672011
ğ‘£5ğ‘£3ğ‘£7ğ‘£2ğ‘£4ğ‘£8ğ‘£6ğ‘£1ğ‘£9ğ‘£13ğ‘£10ğ‘£12ğ‘£14ğ‘£11ğ‘£15Figure 1: An example of multiplex collaboration network.
Discovery and Data Mining (KDD â€™24), August 25â€“29, 2024, Barcelona, Spain.
ACM, New York, NY, USA, 12 pages. https://doi.org/10.1145/3637528.3672011
1 INTRODUCTION
In applications such as biological, social, and financial networks,
interactions between objects span multiple aspects. For example,
in social networks interactions between people can be social or
professional, and professional interactions can differ according to
topics. Accurate modeling of such applications has led to multiplex
networks (ML) [ 39], where nodes have interactions in multiple types
of connections (a.k.a layers). They have since gained popularity in
many applications in social and biological networks, and in opinion
dynamics [17, 45, 49].
Example 1. Figure 1 shows a multiplex collaboration network, where
each node is a researcher, each edge is a collaboration, and each layer
represents collaborations in an area of research.
Understanding the network topology and finding dense subgraphs
are long-standing problems in network science with many applica-
tions [ 23,27]. A common method for identifying dense subgraphs
is to formulate an objective function (i.e., density) based on nodesâ€™
degree and solve it via optimization methods [ 5,29,51]. While
the problem of finding the densest subgraph in simple graphs is a
well-studied problem [ 40], finding dense subgraphs from multiplex
networks recently attracts attention [5, 7, 28, 32].
Despite the recent attempts to extend the known concepts of dense
subgraphs to multiplex networks (e.g., [ 7,32,43]), existing studies
suffer from a subset of the following limitations: 1They force
nodes to satisfy degree constraints in a fixed subset of layers, includ-
ing noisy/insignificant layers [ 28]. These layers can be different for
each node [ 32] and so this hard constraint can result in missing
some dense structures [ 32].2They require exponential running
time algorithms, making them infeasible for large real-world graphs.
1028
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Farnoosh Hashemi and Ali Behrouz
3Taking advantage of the complementary information provided
by different relation types is challenging as in real-world graphs, dif-
ferent relation types have different importance or roles with respect
to the application (see [ 10,14] for more details). Existing methods
treat all relation types equally, causing suboptimal performance
and missing information (see Â§6).
Besides the above limitations, the complication caused by the defi-
nition of degree in multiplex networks makes it challenging to nav-
igate the vast landscape of existing methods and evaluate trade-offs
between them in practice. That is, while the degree of each node in
simple graphs is represented by a single number, the degree of each
node in multiplex networks with |ğ¿|layers is an|ğ¿|-dimensional
vector (also called degree vector), in which the â„“-th element shows
the number of the nodeâ€™s neighbors in layer â„“. Accordingly, this
high dimensional representation of the degree results in a trade-off
between the complexity of the methods and their power to capture
the information about the neighborhood of nodes in each layer.
For example, Galimberti et al . [28] suggest using the entire degree
vector in objective function, which results in an exponential time de-
composition algorithm but Hashemi et al . [32] suggest sampling the
ğœ†-th largest element of degree vector as its representative, which
results in linear time decomposition algorithms. While the former
uses all the information provided by the degree vectors, the later
methods miss all the information about the nodesâ€™ neighbors in
different relation types except the ğœ†-th largest value. Accordingly, it
can be challenging to choose a proper objective function to extract
dense structures in practice, and in many cases, it requires paying
attention to the data and available computational capacity.
To mitigate the above limitations, we present S-core, a new unifying
family of dense subgraphs in multiplex networks. The main intu-
ition of S-cores is to use a summarizer function, S(.), and summarize
the degree vector of each node into a low dimensional space, miti-
gating time inefficiency and avoiding too hard constraints. Given a
ğ‘‘-dimensional threshold vector k, we define(k,S)-core as a max-
imal subgraph in which each node ğ‘¢has summrized degree of at
least kwithin the subgraph. Interestingly, S-cores includes exist-
ing families of dense multiplex subgraphs as its special cases when
choosing different summarizer S(.). We discuss how one can choose
a proper S(.)based on the network topology. We propose efficient
algorithms to find all possible S-cores and show their scalability
to graphs with millions of connections (see Â§ 6). Finally, we focus
on two applications of S-cores: iFinding the densest multiplex
subgraph, and iimodeling the user engagement in multiplex net-
works:
Densest Multiplex Subgraph. The main challenge to define the
density of a subgraph in multiplex networks is the trade-off be-
tween high density and the number of layers in which the high
density holds. To this end, existing studies [ 28,32] model the trade-
off as a maximin optimization of the average density objective
and use a parameter ğ›½>0to add a penalty for choosing small
subset of layers. While these formulations allow us to control the
trade-off, their main drawback is that they force allnodes within
the subgraph to exhibit their high degree in a fixsubset of layers.
In multiplex networks different layers for different nodes might
be noisy/insignificant [28, 32]. We present a new density measure
in multiplex networks, and define the density as the average ofmaximin optimization of nodesâ€™ degree (instead of maximin opti-
mization of the average degree [ 28,32]). This will allow nodes to
exhibit their high degree in different and flexible subset of layers.
We show that this optimization problem is NP-hard, and use the
densest S-core to approximate the problem of finding the densest
subgraph. Not only this approximation algorithm provide effec-
tive guarantee for our density formulation, but it also can provide
an approximate solution to the problem of densest subgraph with
respect to existing density measures [ 28,32] with approximation
guarantee that matches the best existing algorithms.
User Engagement. A fundamental question in understanding so-
cial networks is that â€œhow users decide to engage in a social net-
work?â€. Several studies [ 11] model this as a simultaneous game
where each user decides to remain engage or drop out. While these
models assume a single type of interaction, in complex social sys-
tems, users have different types of interactions and each interaction
type has its own effect on the engagement of the users. For example,
on Instagram, engagement in sharing posts, stories, and/or sending
messages are different for each user. Inspired by Bhawalkar et al .
[11], we model user engagement in each type of connection as a
simultaneous game ( |ğ¿|games in total), in which each user decides
to remain engage or drop out in that specific type of interaction. We
show that S-cores are unique maximal equilibriums of this game,
and provide empirical evidences to support the model design.
Summary of Contributions. 1We present a new family of
dense structures in multiplex networks, S-cores, that unifies ex-
isting degree-based families of dense multiplex subgraphs, using a
single function S(.).2We provide detailed discussion of how in
practice one can choose S(.)to avoid information loss. 3We intro-
duce a new, efficient, and powerful variant of S-core, WFirmCore,
and show its useful properties. 4We develop efficient algorithms
for the general case (arbitrary function S(.)) and WFirmCore. 5
We present a new density objective in multiplex networks that
mitigates the hard constraints of existing density measures, leading
to finding more cohesive subgraphs. 6We discuss the hardness
of this problem and design an approximation algorithm using the
densest S-core with provable guarantee. We further show that this
guarantee is valid when using existing density measures, which
matches the best approximation factor for this problem. 7We fur-
ther use S-cores to model user engagement in multiplex networks
as|ğ¿|(number of interaction types) simultaneous game in which
each user decides to remain engage or drop out in every single type
of interaction. We show that S-cores are unique maximal equilibri-
ums of this game and provide empirical evidences to support the
model design. Proofs, toy examples for all concepts and algorithms,
and additional experiments are in Appendix.
Notation. Let ğº=(ğ‘‰,ğ¸,ğ¿, w)be a multiplex graph, where ğ‘‰is the
set of nodes, ğ¿is the set of layers (each layer is a graph corresponds
to a specific relation type), ğ¸âŠ†ğ‘‰Ã—ğ‘‰Ã—ğ¿is the set of edges, and
w(.):ğ‘‰Ã—ğ¿â†’Râ‰¥0is a function that assigns a weight to each
layer with respect to a node. The set of neighbors of node ğ‘£in
layerâ„“is denotedğ‘â„“(ğ‘£)and the degree of ğ‘£in layerâ„“isdegâ„“(ğ‘£)=
|ğ‘â„“(ğ‘£)|. We use vector deg(ğ‘£)to refer toğ‘£â€™s degree in each layer
(i.e.,(deg(ğ‘£))â„“=degâ„“(ğ‘£)). For a set of nodes ğ»âŠ†ğ‘‰,degğ»
â„“(ğ‘£)is the
degree ofğ‘£in this subgraph. Given a vector v=[v1,...,vğ‘‘], we
1029A Unified Core Structure in Multiplex Networks: From Finding the Densest Subgraph to Modeling User Engagement KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
use Top-ğœ†element to refer to ğœ†-th largest element in v. Therefore,
we use Top- ğœ†degree ofğ‘¢to refer to Top- ğœ†element inğ‘¢â€™s degree
vector.
2 RELATED WORK AND BACKGROUNDS
Dense Subgraph Mining. Several variants of the densest subgraph
problem with different objective functions have been designed in
simple networks [ 26,29,46,51]. Recently, Veldt et al . [51] uni-
fies most existing density objective functions and suggests using
ğ‘-mean of node degrees within the subgraph as its density. In multi-
plex networks, Jethava and Beerenwinkel [34]formulate the densest
common subgraph problem and develop a linear-programming for-
mulation. Azimi-Tafreshi et al . [2] extendedğ‘˜-core to multiplex
networks: given an |ğ¿|-dimensional vector k=[ğ‘˜â„“]â„“âˆˆğ¿, the ML
k-core is a maximal subgraph, in which each node in layer â„“has
at leastğ‘˜â„“neighbors. Liu and Zou [44] extends this formulation to
multilayer networks with inter-layer connections. Galimberti et al .
[28]propose algorithms to find all possible k-cores, and generalized
the density measure of Jethava and Beerenwinkel [34] as follows:
Definition 1 (Multilayer Density [ 28]).Givenğ›½>0, the ML
density of subgraph ğº[ğ»]is defined as:
ğœŒ(ğ»)=max
Ë†ğ¿âŠ†ğ¿min
â„“âˆˆË†ğ¿|ğ¸â„“[ğ»]|
|ğ»||Ë†ğ¿|ğ›½. (1)
Hashemi et al . [32] introduce FirmCore as a maximal subgraph in
which every node is connected to at least ğ‘˜other nodes within that
subgraph, in each of at least ğœ†individual layers. Recently, variants
of FirmCore, based on triadic closure [ 7] andğ‘-mean [ 5], has been
designed to achieve more cohesive structures. Finally, Kawase et al .
[37] design an LP-based algorithm to find a stochastic solution for
the multiplex densest subgraph problem.
All these methods treat all the layers the same, consider too hard
degree constraint for nodes in all the layers, or assume pre-defined
patterns (which does not necessarily fit all networks in different
domain). Moreover, S-cores are unifying family, meaning that most
existing methods are its special cases. They help to navigate the
vast landscape of existing methods and evaluate trade-offs between
them in practice.
Modeling User Engagement. Mathematical modeling of user
engagement in social networks has attracted attention during the
past two decades [ 13,25,50]. SÃ¤Ã¤skilahti [50] present a payoff
structure when the network topology is either complete, a cycle, or
a star. Several economic models discuss positive network effects of
participation in complete graphs [ 1,36] and competing behavior
setting [ 13,25]. Bhawalkar et al . [11] model this problem as a single
simultaneous in which each user decides to remain engage or drop
out based on its number of active friends. All these studies are
different from our model as they have focused on either ispecific
graph topology, and/or iiisingle type of interaction in the network.
3S-CORE IN MULTIPLEX NETWORK
The main intuition of ğ‘˜-cores in simple graphs is to decompose
the graph into hierarchical structures, in which each node has
sufficient number of neighbours. However, the high dimensional
degree vectors in multiplex networks makes it challenging to defineuniversally accepted notion of core in multiplex networks. Simply
considering the entire degree vector for all nodes 1can cause
computational inefficiency and 2can be too hard constraint [ 32].
To address these challenges, we present S-core structures:
Definition 2 (Summarized Core). Given a multiplex network
ğº=(ğ‘‰,ğ¸,ğ¿, w), a non-decreasing function S:Z|ğ¿|
â‰¥0Ã—wâ†’Rğ‘‘
â‰¥0
that summarizes degree vector of nodes, and a ğ‘‘-dimensional vector
k=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘, the(k,S)-core (k- S-core for short) of ğºis a maximal
subgraphğ»=ğº[ğ¶ğ‘˜]=(ğ¶ğ‘˜,ğ¸[ğ¶ğ‘˜],ğ¿)such that for each node
ğ‘£âˆˆğ¶ğ‘˜we have S(degğ¶k(ğ‘£),w)ğ‘–â‰¥ğ‘˜ğ‘–for all 1â‰¤ğ‘–â‰¤ğ‘‘. We refer to
vector kas the SCvector index ( SCVindex for short) of ğ»=ğº[ğ¶ğ‘˜].
We abuse the notation and remove wwhen the context is clear.
Lemma 1. All multilayer k-core [ 28], FirmCore [ 32], and CoreCube
[43] are special cases of S-cores.
Definition 3 (Maximal SCVIndex). Given a multiplex network
ğº=(ğ‘‰,ğ¸,ğ¿, w), a function S:Z|ğ¿|
â‰¥0Ã—wâ†’Rğ‘‘
â‰¥0, andğº[ğ¶]be a
S-core ofğº, letk=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘be a SCVindex ofğº[ğ¶].kis called
maximal SCVindex ofğº[ğ¶]if there does not exist any SCVindex
kâ€²=[ğ‘˜â€²
ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘ofğº[ğ¶]such thatâˆ€ğ‘–âˆˆ{1,...,ğ‘‘}we haveğ‘˜â€²
ğ‘–â‰¥ğ‘˜ğ‘–
andâˆƒğ‘—âˆˆ{1,...,ğ‘‘}such thatğ‘˜â€²
ğ‘—>ğ‘˜ğ‘—.
Proposition 1. The maximal SCVindex for each S-core exists and
is unique.
Proposition 2 (Uniqeness). Given a function S(.)andk=
[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘, thek-S-core ofğºis unique.
Proposition 3 (Hierarchical Structure). Given a multiplex
networkğº=(ğ‘‰,ğ¸,ğ¿, w)and two S-coresğº[ğ¶k]andğº[ğ¶kâ€²]with
coreness vectors k=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘andkâ€²=[ğ‘˜â€²
ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘, respectively. If
âˆ€ğ‘–âˆˆ{1,...,ğ‘‘}:ğ‘˜ğ‘–â‰¥ğ‘˜â€²
ğ‘–thenğº[ğ¶k]âŠ†ğº[ğ¶kâ€²].
Based on the above hierarchical structure property of S-cores, we
define skyline S-core vector indices that can help us to design
efficient algorithms for the general case:
Definition 4 (Skyline SCVIndices). The skyline SCVindices of
a multiplex network are maximal SCVindex k=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘such that
there does not exist any other maximal SCVindex of kâ€²=[ğ‘˜â€²
ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘
whereâˆ€ğ‘–âˆˆ {1,...,ğ‘‘}:ğ‘˜â€²
ğ‘–â‰¥ğ‘˜ğ‘–andâˆƒğ‘—âˆˆ {1,...,ğ‘‘}such that
ğ‘˜â€²
ğ‘—>ğ‘˜ğ‘—.
Decomposing a multiplex graph to S-cores requires finding all
k=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘corresponding to possible distinct and non-empty
k-S-core. Based on the above properties, there is a nested property
in the search space of all SCVindices and traversing all states in the
search space is equivalent to find all possible S-cores. To this end,
we say a SCVindex kchild is a child of kparent if there is Ë†ğ‘–âˆˆ{1,...,ğ‘‘}
such that for all ğ‘–âˆˆ{1,...,ğ‘‘}\{Ë†ğ‘–}we have(kchild)ğ‘–=(kparent)ğ‘–
and(kchild)Ë†ğ‘–>(kparent)Ë†ğ‘–. Contrary to the search spaces of other
families of dense structures discussed in [ 7,28],SCVindices are non-
negative real numbers and their search space is infinite. However,
not all of these S-cores are distinct. Next theorem is the key to design
efficient and finite-time algorithms to traverse distinct S-cores:
Theorem 1. Given a multiplex network ğº=(ğ‘‰,ğ¸,ğ¿, w)and its S-
coreğº[ğ¶], the unique maximal SCVindex ofğº[ğ¶]is ağ‘‘-dimensional
vector Scv(ğ¶)=[minğ‘¢âˆˆğ¶S(degğ¶(ğ‘¢))ğ‘–]ğ‘‘
ğ‘–=1.
1030KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Farnoosh Hashemi and Ali Behrouz
3.1 How to Choose S(.)?
A natural question about S-cores is how to choose proper S(.)to
efficiently avoid information loss about the neighborhoods of nodes
in different layers. We need to recall the main intuition behind
core structures in networks. Core structures are densely connected
subgraphs that nodes are required to satisfy a degree constraint
(i.e., each node must have sufficient number of neighbors within
the subgraph). Therefore, we need to choose function S(.)so it can
be a good representative for the degree vector of each node.
Statistical Inference. Let L={L1,...,Lğ‘¡}be a partition of layers
such that the degree distribution of all layers in each partition are
the same. We let PDğ‘–:ğœƒğ‘–be the degree distribution of layers in
partitionLğ‘–. Givenğ‘–âˆˆ{1,...,ğ‘¡}, letLğ‘–={â„“(ğ‘–)
1,...,â„“(ğ‘–)
ğ‘¡ğ‘–}. We treat
degâ„“(ğ‘–)
1(ğ‘¢),..., degâ„“(ğ‘–)
ğ‘¡ğ‘–(ğ‘¢)asğ‘¡ğ‘–samples from the same distribution
PDğ‘–:ğœƒğ‘–. We now consider two cases:
1Layers are independent (e.g., multiplex brain networks [ 7,10],
biological networks [ 21]): In this case, given a node ğ‘¢âˆˆğ‘‰, its de-
grees in layers{â„“(ğ‘–)
1,...,â„“(ğ‘–)
ğ‘¡ğ‘–}are i.i.d. samples from a distribution
PDğ‘–:ğœƒğ‘–with parameter(s) ğœƒğ‘–. Accordingly, given these samples, the
minimal sufficient statistics of PDğ‘–:ğœƒğ‘–is the best statistics to pre-
serve information to inference on parameter(s) ğœƒğ‘–, i.e., we do not
lose information about the neighborhoods of nodes in layers in Lğ‘–.
2Layers are dependent (e.g., social networks [ 15,20,48], collabo-
ration networks [ 19]): Accordingly, degrees of a node in different
layers are dependent and simple statistical methods cannot be used.
We suggest using data summarization methods (e.g., [ 24]), which
summarize dependent data with minimal information loss.
We let the output of either 1or2forLğ‘–beSğ‘–(.). Finally, we
aggregate all found summarizer functions to obtain S(.).
Sampling from the Degree Vector. Another method to efficiently
reduce the dimension of degree vectors, is to sample order statis-
tics from the degree vectors. ğœ†-th order statistic of a vector is its
ğœ†-th smallest value. Accordingly, given ğ‘‘(choose based on com-
putational capacity), and ğœ†1,...,ğœ†ğ‘‘, one can sample ğœ†ğ‘–-th order
statistics to summarize the degree vector. FirmCore [ 32] is a special
case of this method, where ğ‘‘=1and it uses(|ğ¿|âˆ’ğœ†+1)-th order
statistic.
Learn to Find Dense Structures. The main drawback of existing
dense subgraph mining methods is that they are based on pre-
defined patterns or constraints (e.g., ğ‘˜-core [ 42],ğ‘˜-truss [ 18]). Real-
world networks, however, are complex in nature and a pre-defined
pattern cannot fit all networks in different domains. Machine learn-
ing models are powerful tools to learn from the data; however,
they mostly focus on classification [ 6], prediction [ 10], and regres-
sion [ 35] tasks and their usefulness in finding the network building
blocks is still unexplored. Our formulation of S-core, can bridge
the gap and allows using machine learning methods to learn what
is the best patterns in a data-driven manner. The main challenge
is the lack of objective function. In the information theoretic per-
spective, since we aim to learn node representation that are good
representative for nodeâ€™s degree, we suggest maximizing the mutual
information between the actual degree vector and the encoding of
nodes. Given a graph neural network Gnn(.)[38], we maximizethe following objective: (I( .)is mutual information)
Loss :=1
|ğ‘‰|âˆ‘ï¸
ğ‘¢âˆˆğ‘‰I(Gnn(ğ‘¢),deg(ğ‘¢)
). (2)
3.2 Temporal Graphs as Multiplex Networks
Dynamic systems are every where [ 8], and temporal networks
are powerful paradigms to model the interactions and their dy-
namics over time in complex dynamic systems. A temporal graph
ğº={ğº1,...,ğºğ‘‡}is a graph, in which each edge is associated with
a timestamp and each ğºğ‘–shows the graph snapshot at time ğ‘–[33].
Recently, representation of temporal graphs as multiplex networks
attracts attention, where each layer of the multiplex network rep-
resents a snapshot of the temporal graph [32, 53].
Lemma 2. Givenğœ†, letwâ„“=2â„“for allâ„“âˆˆğ¿andS(X)=Top-ğœ†(X),
then all(ğ‘˜,Î”)-Span-cores [52] are special cases of ğ‘˜-S-core.
In temporal graphs, the degree vector of each node is a time series
data that shows nodeâ€™s degree over time. Accordingly, to find S(.),
one can use summarizing methods for time series data (e.g., [47]).
3.3 S-core: Algorithms
Given a vector k=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘, Algorithm 1 finds the k-S-core,Ck.
We start from the entire graph and in each iteration, we remove a
nodeğ‘¢that does not satisfy S-coreâ€™s condition, i.e., S(deg(ğ‘¢))ğ‘–<ğ‘˜ğ‘–
for someğ‘–. We repeat this process until all remaining nodes satisfies
S-coreâ€™s conditions. This algorithm iterates at most |ğ‘‰|times as we
stop or remove one node in each iteration. Also, in each iteration,
we update the degree vector with O(|ğ¿|)and check the conditions
withO(ğ‘‘). Sinceğ‘‘â‰¤|ğ¿|, the time complexity is O(|ğ‘‰||ğ¿|+|ğ¸|).
Toy Example for Algorithm 1. In the graph shown in Figure 1,
for the sake of simplicity assume w=1. Since the graph has three
layers, the degree of each node is a vector of size three. Assume
that the degree summarization function for this graph is given as
ğ‘†(hğ‘¥1ğ‘¥2ğ‘¥3i
)=hğ‘šğ‘–ğ‘›(ğ‘¥1,ğ‘¥2,ğ‘¥3)
ğ‘šğ‘ğ‘¥(ğ‘¥1,ğ‘¥2,ğ‘¥3)i
. Also assume k=[3,4] and we want to
findkâˆ’S-core, which is a maximal subgraph in which each node has
at least a minimum degree of 3 and at least a maximum degree of 4
among the three layers within the subgraph. In the first iteration,
ğ»=ğ‘‰and we have ğ‘‘ğ‘’ğ‘”(ğ‘£6)=h4
4
2i
andğ‘†(h4
4
2i
)=2
4. Since
2<ğ‘˜1=3, vertexğ‘£6will be removed from ğ». After removing ğ‘£6,
the degree vectors of its neighbors will be updated, resulting in all its
neighbors having a minimum degree of less than 3. Consequently,
ğ‘£7,ğ‘£8,ğ‘£9, andğ‘£10(all orange vertices) will be removed from ğ».
Additionally, since ğ‘‘ğ‘’ğ‘”(ğ‘£2)=h3
3
3i
,ğ‘†(h3
3
3i
)=3
3, and 3<ğ‘˜2=4,
vertexğ‘£2will be removed from ğ», and the degree vectors of all its
neighbors will be updated. Consequently, ğ‘£1,ğ‘£3,ğ‘£4andğ‘£5(purple
vertices) will have a maximum degree of less than 4 and will be
discarded from ğ». The nodes remaining in ğ», which are only the
green nodes, have a minimum degree of at least 3 and maximum
degree of at least 4; therefore, they constitute the k-S-core.
Simply traversing SCVindices and applying Algorithm 1 to find
S-cores results in inefficient performance since we start from the en-
tire graph for different SCVindices. Using S-coresâ€™ nested property
(Proposition 3), we use the following corollary to improve efficiency:
1031A Unified Core Structure in Multiplex Networks: From Finding the Densest Subgraph to Modeling User Engagement KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Algorithm 1 Finding k-S-core
Input: A multiplex network ğº=(ğ‘‰,ğ¸,ğ¿, w), a set of nodes ğ»âŠ†ğ‘‰, a non-
decreasing function S:Z|ğ¿|
â‰¥0Ã—wâ†’Rğ‘‘
â‰¥0, and a vector k=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘.
Output: Thek-S-core ofğº.
1:whileâˆƒğ‘¢âˆˆğ»andâˆƒğ‘–:S(degğ»(ğ‘¢))ğ‘–<ğ‘˜ğ‘–do
2:ğ»â†ğ»\{ğ‘¢};
returnğº[ğ»];
Algorithm 2 S-core Decomposition of Multiplex Networks
Input: A multiplex network ğº=(ğ‘‰,ğ¸,ğ¿, w), and a non-decreasing func-
tion S:Z|ğ¿|
â‰¥0Ã—wâ†’Rğ‘‘
â‰¥0.
Output: All distinct and non-empty k-S-core ofğº.
1:QBfsâ†{[ 0]ğ‘‘};
2:QDfsâ†Ã
ğ‘–âˆˆ{1,...,ğ‘‘}{k|CkâˆˆDfs-Path(ğº,S,QBfs,ğ‘–)};âŠ²Algorithm 3
3:Ckeeps visited S-cores until now, i.e., Câ†{ğ¶k|kâˆˆQDfs};
4:while QBfs\QDfsâ‰ âˆ…do
5: Pick and remove k=[ğ‘˜ğ‘–]ğ‘–âˆˆ{1,...,ğ‘‘}from queue QBfs;
6: ifkâˆ‰QDfsthen
7: Ckâ†S-core(ğº,Ã
ËœkâˆˆP(k)CËœk,k);âŠ²Algorithm 1, Corollary 1
8: ifCkâ‰ âˆ…then
9:Câ†Câˆª{ Ck};
10: QDfsâ†QDfsâˆª{k,[min
ğ‘¢âˆˆCkS(degCk(ğ‘¢))ğ‘–]ğ‘‘
ğ‘–=1};âŠ²Theorem 1
11: else
12: forğ‘–=1,...,ğ‘‘ do
13: ğ‘˜ğ‘–newâ†ğ‘˜ğ‘–;ğ‘¢âˆ—â†âˆ… ;Ë†Ckâ†Ck;
14: whileğ‘˜ğ‘–new=ğ‘˜ğ‘–do âŠ²Theorem 1
15: Ë†Ckâ†Ë†Ck\{ğ‘¢âˆ—}
16: ğ‘¢âˆ—â†arg min
ğ‘¢âˆˆCkS(min
ğ‘£âˆˆCk\{ğ‘¢}degCk\{ğ‘¢}(ğ‘£))ğ‘–;
17: ğ‘˜new
ğ‘–â†S(min
ğ‘£âˆˆCk\{ğ‘¢âˆ—}degCk\{ğ‘¢âˆ—}(ğ‘£))ğ‘–;
18: Ë†kâ†[ğ‘˜1,...,ğ‘˜ğ‘–new,...,ğ‘˜ğ‘‘];
19: enqueue Ë†kintoQBfs;P(Ë†k)â†P( Ë†k)âˆª{ k};âŠ²Theorem 1
returnC;
Algorithm 3 Dfs-Path
Input: A multiplex network ğº=(ğ‘‰,ğ¸,ğ¿, w), a setğ»âŠ†ğ‘‰,S:Z|ğ¿|
â‰¥0Ã—wâ†’
Rğ‘‘
â‰¥0, a vector k=[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘, and an index ğ‘–âˆˆ{1,...,ğ‘‘}.
Output: The set of all the S-cores ofğºvarying theğ‘–-th element of k.
1:C(k,ğ‘–)â†âˆ… ;Bâ†âˆ… ;Indexâ†âˆ…
2:forğ‘¢âˆˆğ»do
3: B[S(degğ»(ğ‘¢))ğ‘–]â† B[S(degğ»(ğ‘¢))ğ‘–]âˆª{ğ‘¢};
4: Indexâ†Indexâˆª{S(degğ»(ğ‘¢))ğ‘–};
5:forğ‘˜âˆˆIndex do
6: while B[ğ‘˜]â‰ âˆ…do
7: remove a node ğ‘¢from B[ğ‘˜];ğ»â†ğ»\{ğ‘¢};
8: for(ğ‘¢,ğ‘£,â„“)âˆˆğ¸[ğ»]andS(degğ»(ğ‘£))ğ‘–â‰¥ğ‘˜do
9: B[S(degğ»(ğ‘£)+1)ğ‘–]â† B[S(degğ»(ğ‘£)+1)ğ‘–]\{ğ‘£};
10: B[S(degğ»(ğ‘£))ğ‘–]â† B[S(degğ»(ğ‘£))ğ‘–]âˆª{ğ‘£};
11: Indexâ†Indexâˆª{S(degğ»(ğ‘£))ğ‘–};
12: forğ‘—âˆˆ{1,...,ğ‘‘}\{ğ‘–}do
13: for(ğ‘¢,ğ‘£,â„“)âˆˆğ¸[ğ»]andS(degğ»(ğ‘£))ğ‘—<ğ‘˜ğ‘—do
14: B[S(degğ»(ğ‘£))ğ‘–]â† B[S(degğ»(ğ‘£))ğ‘–]\{ğ‘£};
15:C(k,ğ‘–)â†C( k,ğ‘–)âˆª{ğ»};
returnC(k,ğ‘–);
Corollary 1. Given a k-S-core,ğ¶, letP(ğ¶)be the set of all S-cores
with maximal SCVindices that are the parents of kin the search
space lattice. We have ğ¶âŠ†Ã‘
Ëœğ¶âˆˆP(ğ¶)Ëœğ¶.While the corollary suggests using breadth-first search (BFS) tra-
verse over the maximal SCVindices, so the intersection of S-cores
corresponds to parents can be used in the next level, a simple BFS
traverse causes counting each index as many as its number of
parents. Further, at each new level of the search we re-start the
decomposition algorithm, which is inefficient. To mitigate it, we
use a depth-first search traverse of indices, while inspired by BFS,
we also consider the union of S-cores corresponds to the parents
of each state.
Algorithm 2 shows the pseudocode of the S-core decomposition
algorithm. QBfsandQBfsare queues that keep track of search in
breadth-first and depth-first manners, respectively. We start from
the root (i.e.,[0]ğ‘‘). To look ahead and traverse indices in DFS
manner, we first find S-cores corresponds to all indices that only
theirğ‘–-th element is non-zero. These S-cores has nested property
and we only need to look at ğ‘–-th element. Algorithm 3 shows this
procedure. We use bin-sort [ 3] to keep the ğ‘–-th element of S(deg(.))
of nodes sorted throughout the algorithm and can update them
inO(1)time. We recursively remove nodes in bucket ğ‘˜until all
remaining nodes satisfy the S-core conditions. Note that, here, the
indices of buckets are real numbers and so we use set Index to
store all indices of non-empty buckets.
In Algorithm 2, after finding S-cores corresponds to the above paths
(line 2), we start from an index in the Bfsqueue. If it has not seen
in the Dfstraverse, we use Algorithm 1 to find its corresponding
S-core. Notably, based on Corollary 1, we start from the union of
theS-cores corresponds to the current index parents. Lines 8-10
store non-empty S-cores and potential root indices for the Dfs
traverse. Lines 12-19 find potential SCVindices. Note that, using
Theorem 1, it only needs to look at indices whose ğ‘–-th element is
the minimum S(deg(.))ğ‘–of nodes within the subgraph. Therefore,
for next SCVindex, we need to change the ğ‘–-th element to second
smallest S(deg(.))ğ‘–within the subgraph (changing to the smallest
result in the same S-coreas the previously found S-core).
Lemma 3. There is a multiplex network ğº=(ğ‘‰,ğ¸,ğ¿, w)and function
S(.)such that Algorithm 2 takes O(|ğ‘‰|ğ‘‘+1|ğ¿|+|ğ¸||ğ‘‰|ğ‘‘)time.
3.4 S-coreâ€™s variants: Weighted FirmCore
There is a trade-off between the diverse solution space and the time
complexity of dense subgraph models in multiplex networks. While
S-core provide the most diverse search space and can unify previous
core structures in multiplex networks, it might require exponential
time algorithm to find all S-cores (e.g., when ğ‘‘âˆˆO(|ğ¿|)). Next,
we discuss a simple but effective (see Sections 4 and 6) variant of
S-cores and show that it 1is potentially more efficient than the
general case, and 2has good quality in both theory and practice.
Definition 5 (Layer-Weighted FirmCore). Given a multiplex
graphğº, a non-negative real-value thresholdğœ†, and an integer ğ‘˜â‰¥0,
the(ğ‘˜,ğœ†)-WFirmCore of ğºis a maximal subgraph ğ»=ğº[ğ¶ğ‘˜]=
(ğ¶ğ‘˜,ğ¸[ğ¶ğ‘˜],ğ¿)such that for each node ğ‘£âˆˆğ¶ğ‘˜there are some layers
with cumulative relative importance of at least ğœ†(i.e.,âˆƒ{â„“1,...,â„“ğ‘ }âŠ†ğ¿
withÃğ‘ 
ğ‘–=1w(ğ‘£,â„“ğ‘–)â‰¥ğœ†) such that degğ¶ğ‘˜
â„“ğ‘–(ğ‘¢)â‰¥ğ‘˜, for1â‰¤ğ‘–â‰¤ğ‘ .
When refering to(ğ‘˜,ğœ†)-WFirmCore, we assume that ğœ†is maximal,
i.e., for at least one vertex ğ‘¢in(ğ‘˜,ğœ†)-WFirmCore, there is a subset
of layers with cumulative relative importance of exactly ğœ†in which
1032KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Farnoosh Hashemi and Ali Behrouz
ğ‘¢has a degree of at least ğ‘˜. Since WFirmCores are special cases
ofS-cores, they have its nice properties. However, changing the
value ofğœ†requires changing function S(.), which its hierarchical
property is unclear.
Property 5.1 (Hierarchical Structure). Given a non-negative
real-value threshold ğœ†, and an integer ğ‘˜â‰¥0, the(ğ‘˜,ğœ†+ğœ–)-WFirmCore
ofğºis a subgraph of its (ğ‘˜,ğœ†)-WFirmCore for any ğœ–âˆˆR+.
Theorem 2. WFirmCore decomposition, which is finding all WFirm-
Cores in a multiplex network, is NP-hard. When w(.)â€™s outputs are
integer, the decomposition can be done in Pseudo-polynomial time.
Efficient WFirmCore Decomposition. While WFirmCore is a
special case of S-core, using Algorithm 1 is inefficient as we have
nested property with respect to not only ğ‘˜, but alsoğœ†(Property 5.1).
Givenğœ†, we define the WFirmCore index of a node ğ‘¢, Wcoreğœ†(ğ‘¢), as
the maximum ğ‘˜âˆˆN, such thatğ‘¢is part of a(ğ‘˜,ğœ†)-WFirmCore. We
further define Top- ğœ†(deg(ğ‘¢),w)as the maximum value of ğ‘˜that
there are some layers {â„“1,...,â„“ğ‘¡}with a cumulative relative weight
(with respect to ğ‘¢) of at least ğœ†(i.e.,Ãğ‘¡
ğ‘–=1w(ğ‘£,â„“ğ‘–)â‰¥ğœ†) in which
degğ»
â„“(ğ‘¢)â‰¥ğ‘˜. To calculate the Top- ğœ†(deg(ğ‘¢),w), we can simply
sort vector degğ»(ğ‘¢)and check if the cumulative relative weights
of layers in which ğ‘¢has a degğ»
â„“(ğ‘¢)â‰¥ğ‘˜isâ‰¥ğœ†. This process takes
O(|ğ¿|log|ğ¿|)time. It is simple to see that ğ‘¢can be in at most(ğ‘˜,ğœ†)-
WFirmCore, where ğ‘˜=Top-ğœ†(deg(ğ‘¢),w). Accordingly, Algorithm
4 processes the nodes in increasing order of Top âˆ’ğœ†(deg(ğ‘¢),w). It
uses a vector Bof lists such that each element ğ‘–contains nodes with
potential Wcore at most ğ‘–. This technique allows us to keep vertices
sorted throughout the algorithm and to update each element in
O(1)time. Algorithm 4 iterates over all given ğœ†ğ‘–s and for each, first
initializes Bwith the minimum of Top âˆ’ğœ†ğ‘–(deg(ğ‘¢),w)andğ‘¢â€™s index
forğœ†ğ‘–âˆ’1. The reason is due to the nested property with respect to ğœ†,
ifWcoreğœ†(ğ‘¢)=ğ‘˜, then Wcoreğœ†+ğœ€(ğ‘¢)â‰¤ğ‘˜. We process Bâ€™s elements
in increasing order. If a node ğ‘¢is processed at iteration ğ‘˜, its Wcoreğœ†ğ‘–
is assigned to ğ‘˜and removed from the graph. Therefore, we need
to update the degree of its neighbors in each layer, which leads to
changing the Topâˆ’ğœ†ğ‘–(deg(ğ‘£),w)of its neighbors and changing their
bucket accordingly (lines 10-12). Note that the above algorithm finds
all(ğ‘˜,ğœ†ğ‘–)-WFirmCores, given ğœ†ğ‘–for allğœ†ğ‘–âˆˆÎ›: at the end of(ğ‘˜âˆ’1)-
th iteration, each remaining nodes like ğ‘¢has Topâˆ’ğœ†ğ‘–(deg(ğ‘¢),w)â‰¥
ğ‘˜as we removed all nodes with Top âˆ’ğœ†(deg(ğ‘¢),w)less thanğ‘˜in
the(ğ‘˜âˆ’1)-th iteration.
4 THE MULTIPLEX DENSEST SUBGRAPH
As discussed in Section 2, existing density measures in multiplex
networks, assume 1all layers are complete and important, 2
noisy/insignificant/unimportant layers are the same for all nodes
while in many applications, like financial or transportation net-
works, the importance of each relation type for each node is dif-
ferent [ 9], and 3all nodes are forced to exhibit their high-density
in a fixed subset of layers. To address the limitations, we present a
new multiplex density measure that allows layers to have different
weights with respect to each node. Moreover, it does not force the
densest subgraph to exihibits high degree for all nodes in the same
set of layers. The new formulation let each node in the subgraph to
exihibits its high degree in different set of layers.Algorithm 4 Finding
all(ğ‘˜,ğœ†)-WFirmCores for all ğœ†âˆˆÎ›
Input: A multiplex graph ğº=(ğ‘‰,ğ¸,ğ¿, w)and a sorted set Î›={ğœ†1,...,ğœ†ğ‘}.
Output: WFirmCore index Wcore ğœ†(ğ‘£)for eachğ‘£âˆˆğ‘‰andğœ†âˆˆÎ›.
1:forğœ†ğ‘–âˆˆÎ›do
2:ğ»â†ğ‘‰;
3: forğ‘£âˆˆğ»do
4: Index[ğ‘£]â† min{Top-ğœ†ğ‘–(deg(ğ‘¢),w),Wcoreğœ†ğ‘–âˆ’1(ğ‘¢)};
5: B[Index[ğ‘£]]â†ğµ[Index[ğ‘£]]âˆª{ğ‘£};
6: forğ‘˜=1,2,...,|ğ»|do
7: while B[ğ‘˜]â‰ âˆ…do
8: pick and remove ğ‘£from B[ğ‘˜]; Wcoreğœ†(ğ‘£)â†ğ‘˜;
9: for(ğ‘£,ğ‘¢,â„“)âˆˆğ¸[ğ»]andIndex[ğ‘¢]>ğ‘˜do
10: update Top-ğœ†(deg(ğ‘¢)); removeğ‘¢from B[Index[ğ‘¢]];
11: update Index[ğ‘¢];B[Index[ğ‘¢]]â† B[Index[ğ‘¢]]âˆª{ğ‘¢};
12: ğ»â†ğ»\{ğ‘£};
return WCore;
Algorithm 5 WFC-
Approx
Input: A multiplex graph ğº=(ğ‘‰,ğ¸,ğ¿, w), and parameter ğ›¼âˆˆ{1,...,|ğ¿|}
Output: Approximation solution to the densest subgraph problem.
1:Î›â†summations of all subsets of layer weights with size 1â‰¤ğ‘ â‰¤ğ›¼;
2:forğœ†âˆˆÎ›do
3:Qğœ†â†find all(ğ‘˜,ğœ†)-WFirmCore âŠ²Using Algorithm 4
4: Ë†ğ¶ğœ†â†find the densest(ğ‘˜,ğœ†)-WFirmCoreâˆˆQğœ†.
return the densest subgraph among all Ë†ğ¶ğœ†forğœ†âˆˆÎ›.
Problem 1 (Multiplex Densest Subgraph). Given a multiplex
graphğº=(ğ‘‰,ğ¸,ğ¿, w), ağ›½>0, and function ğœŒ: 2ğ‘‰â†’R+:
ğœŒ(ğ‘†)=1
|ğ‘†|âˆ‘ï¸
ğ‘¢âˆˆğ‘†max
Ë†ğ¿âŠ†ğ¿min
â„“âˆˆË†ğ¿degâ„“(ğ‘¢)Ã—Â©Â­
Â«âˆ‘ï¸
â„“â€²âˆˆË†ğ¿w(â„“â€²)ÂªÂ®
Â¬ğ›½
, (3)
find
a subset of vertices ğ‘†âˆ—âŠ†ğ‘‰that maximizes ğœŒfunction, i.e.,
ğ‘†âˆ—=arg max
ğ‘†âŠ†ğ‘‰ğœŒ(ğ‘†). (4)
Note that we can simplify the definition of function ğœŒ(.)for a
subgraphğ‘†as follows:
ğœŒ(ğ‘†)=1
|ğ‘†|âˆ‘ï¸
ğ‘¢âˆˆğ‘†max
ğœ†âˆˆğš½Top-ğœ†(deg(ğ‘¢),w
)ğœ†ğ›½, (5)
where ğš½is the set of weight summation of all subset of layers.
We followed Galimberti et al . [28] , and consider a penalty for choos-
ing small number of layers. In fact, termÃ
â„“â€²âˆˆË†ğ¿w(â„“â€²)ğ›½
encour-
ages the density measure to choose more layers.
Theorem 3. The multiplex densest subgraph problem is NP-hard,
and cannot be approximated within a constant factor, unless P=NP.
Approximation Algorithm. To overcome the complexity of the
problem, next, we provide a fast approximation algorithm with
provable guarantee. Algorithm 5 shows the pseudocode of the al-
gorithm. Given a threshold ğ›¼, we first construct a candidate set for
the value of ğœ†. To this end, we consider the set of summations of all
possible subsets of layer weights with size 1â‰¤ğ‘ â‰¤ğ›¼, denoted as Î›.
Next, we use Algorithm 4 for each ğœ†âˆˆÎ›, and then report the dens-
est WFirmCore as the approximate solution. In our experiments,
we observe that ğ›¼=min{|ğ¿|,10}results in a good approximate
1033A Unified Core Structure in Multiplex Networks: From Finding the Densest Subgraph to Modeling User Engagement KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
solution. We let Î©be the maximum summation of layer weights
over a node, and ğ‘†SLbe the densest single-layer subgraph among
all layers with a minimum degree of ğœ‡âˆ—. Letğœ“be the maximum
value that(ğœ‡âˆ—,ğœ“)-WFirmCore is non-empty:
Theorem 4. Givenğ›¼, Algorithm 5 providesmin{ğ›¼,ğœ“}ğ›½
2Î©ğ›½ -approximation
solution to the problem of Multiplex Densest Subgraph.
Corollary 2 ( ğ›¼-independent factor). Independent of ğ›¼, when
w(.)=1, Algorithm 5 provides1
2|ğ¿|ğ›½-approximation solution.
Proposition 4 (Comparison of Density Measures). LetğœŒâˆ—(.)
be the density proposed by Galimberti et al . [28] (Definition 1) and
ğœŒ(.)be our density then for any subgraph ğº[ğ»]âŠ†ğºwe have:
ğœŒ(ğº[ğ»])â‰¥ğœŒâˆ—(ğº[ğ»]). (6)
This result shows the power of our density measure compare to
[28], as it finds any subgraph found by [ 28] (not vice versa). Also, it
shows our algorithm provides1
2|ğ¿|ğ›½-approx solution to the problem
of densest subgraph with respect to ML density measure [ 28], which
matches its best approximation guarantee [28, 32].
5 A USER ENGAGEMENT MODEL
Several studies [ 11] have modeled user engagement as a simultane-
ous game where each user decides to remain engage or drop out.
However, the main drawback of this approach is that it assumes
there is only one type of connection in the network. In complex
social systems, users have different type of interactions and each
interaction type has its own effect on the engagement of the user.
For example, on Instagram, engagement in sharing posts, stories,
and/or sending messages are different for each user. The behavior
of each userâ€™s friends can affect their type of engagement (whether
share a story, post a content, or both). Inspired by Bhawalkar et al .
[11], we model user engagement in each type of connection as a
simultaneous game, in which each user decides to remain engage
or drop out. For each user in relation type â„“, we define its utility
asuâ„“(ğ‘£)=|ğ‘+
â„“(ğ‘£)|âˆ’ğ‘˜â„“if it remains engage, and uâ„“(ğ‘£)=0, if it
drops out. Here,|ğ‘+
â„“(ğ‘£)|is the set of ğ‘£â€™s neighbour in layer â„“that
remains engage. Next, we define the final utility of the user ğ‘£as
uğ‘“
â„“(ğ‘£)=S(uâ„“1(ğ‘£),..., uâ„“|ğ¿|(ğ‘£)), where S(.)is some function.
Theorem 5. k-S-core is the unique maximal equilibrium to the above
game, where(k)â„“=ğ‘˜â„“.
Having presented the basic theoretical model, next we propose a
measure for characterizing the engagement of users:
Definition 6 (Nodeâ€™s Engagement). The engagement level of a
node is defined as the maximum L1-norm of its maximal SCVindices:
ğœ(ğ‘¢)= max
kâˆˆMaximalSCV(ğ‘¢)||k||1. (7)
To show the significance of this model, we empirically will answer
the following questions in our experimental evaluation: 1Do we
really need to consider different types of interactions? (See Figure 6),
2Is degree enough to model user engagement? (See Figure 5
(Right)), and 3How does the proposed nodeâ€™s engagement measure
work in real networks? (See Figure 5 (Left))6 EXPERIMENTS
In this section, we evaluate our models and algorithms, and address
the following questions:
â€¢Q1: Is there a superior core model for multiplex networks? Or
depends on the data different core models are needed? (see
Table 1)
â€¢Q2: Is there a trade-off between efficiency and cohesiveness?
(see Table 1, last part)
â€¢Q3: How the dimension of degree summery ( ğ‘‘) affect time and
density? (see Figure 2)
â€¢Q4: How do our algorithms scale with respect to the graph size?
(see Figure 3)
â€¢Q5: How does our approximation algorithm perform compare
to the optimal solution and baselines? (see Figure 4)
â€¢Q6: How well our mathematical model of user engagement can
predict the usersâ€™ departure from the network? (see Figure 5)
â€¢Q7: Do we need multiple games to model user engagement?
(see Figure 6)
Datasets. We perform experimental evaluation on thirteen real net-
works (ten datasets for evaluating the algorithms and 3 datasets for
validating the user engagement model) including social [ 15,30,48],
genetic [ 21], co-authorship [ 7], financial [ 22], and co-purchasing
networks [ 41], whose main characteristics are summarized in Ta-
ble 1. The detailed description of datasets is in Appendix C
Baselines. S-core is a unifying family of dense structures and so
existing dense subgraph models are special cases of S-cores. We
use state-of-the-art algorithms FirmCore [ 32] and ML k-core [ 28],
as well as other seven variants of S-cores with different summa-
rizer S(.). WFirmCore is introduced in Â§ 3.4. S(.)=Sum(.)and
=WSum(.)use the summation and weighted summation of el-
ements in the degree vector, respectively. S(.)=MGcn(.)and
=MGAT(.)useGcn [38] and attention variants of the multiplex
graph neural network in [ 9], respectively, to encode degree vectors.
Finally, S(.)=Stat(.)uses statistical inference discussed in Â§ 3.1.
Cohesiveness. We first, compere the the density of different vari-
ants of S-cores (including existing state-of-the-art family of dense
subgraphs in the literature) using three different existing density
measures for multiplex networks, i.e., edge density (clique density),
ML degree density [ 28], and our proposed density in Problem 1.
The results are reported in Table 1. 1The results show that there
is no single core model that fits all datasets as the network topol-
ogy and the distribution of node degrees in different layers are the
main indicators of what summarizer function is the best represen-
tative of nodes neighborhood. The proposed WFirmCore, however,
shows promising overall performance compared to other variants,
more specifically with respect to edge density and our density. The
main reason is its flexibility to consider different layer weights with
respect to different nodes. 2The only exception is in genetic net-
works, where learning-based summarizer functions, i.e., MGcn and
MGat achieve the best overall results in three density measures,
possibly due to complex interactions of entities. 3Learning-based
and statistical inference-based methods consistently achieve high
density with respect to all density measures. The main reason is
1034KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Farnoosh Hashemi and Ali Behrouz
Table 1: The density of the densest different variants of S-cores with respect to edge density, ML density [28], and our density. The best (resp.
the second best) result is highlighted in blue (resp. gray). OOT: Time exceeds 24 hours, OOM: Memory exeeds 100 GB.
Dataset Homo Sacchcer
e FAO Brain DBLP Amazon FFTwitter Friendfeed StackO Google+
|ğ‘‰| 18k 6.5k
214 190 513k 410k 155k 510k 2.6M 28.9M
|ğ¸| 153k 247k
319K 934K 1.0M 8.1M 13M 18M 47.9M 1.19B
Metric |ğ¿| 7 7 364
520 10 4 2 3 24 4
WFirmCore 0.58 0.46 0.47 0.90 0.39 0.51
0.59 0.48 0.53 0.84
S(.)=[Max(.),Min(.)]0.43 0.41
0.30 0.72 0.36 0.33 0.48 0.31 0.42 OOT
Edge Densityâ†‘ FirmCor e
[32] 0.47 0.42
0.35 0.78 0.41 0.42 0.52 0.36 0.45 0.52
(Ã
â„“âˆˆğ¿wâ„“|ğ¸â„“[ğ‘†]|
wâˆ—Ã—(|ğ‘†|
2))MLk-core
[28] 0.44 0.43
OOM OOM 0.37 0.40
0.56 0.35 OOM OOT
S(.)=Sum(.) 0.40 0.39
0.29 0.70 0.32 0.37 0.46 0.31 0.41 0.44
S(.)=WSum(.) 0.42 0.40
0.31 0.73 0.35 0.34 0.49 0.32 0.40 0.47
S(.)=MGcn(.)[9] 0.69 0.66 0.38 OOM 0.38 0.43
0.52 0.38 OOM OOM
S(.)=MGa t(.)[9] 0.71 0.66 0.40 OOM 0.37 0.45
0.51 0.41 OOM OOM
S(.)=Sta
t(.)[Â§ 3.1] 0.42 0.41
OOM 0.74 0.36
0.44 0.47 0.37 OOM 0.47
WFirmCore 31.14 28.59 1854.07 7935.29
82.91 61.38 99.26 216.74 118.33 173.81
S(.)=[Max(.),Min(.)]26.07 24.88
1469.31 6932.78 74.72 38.85 96.53 160.02 105.28 OOT
MLDensityâ†‘ FirmCor e
[32] 29.74 25.87
1673.18 7163.89 78.91 43.52 100.24 170.87 107.09 164.81
(Galimberti et al. [28]) MLk-core
[28] 27.84 26.92
OOM OOM 75.19 40.54
102.37 164.81 OOM OOT
S(.)=Sum(.) 23.58 22.91
1419.43 6846.21 71.58 37.68 93.44 159.18 101.36 157.92
S(.)=WSum(.) 25.85 24.07
1492. 97 6984.49 74.08 39.46 97.81 161.25 104.67 160.73
S(.)=MGcn(.)[9] 31.50 28.51 1649.17
OOM 76.65 54.52
96.48 184.35 OOM OOM
S(.)=MGa t(.)[9] 31.09 28.51 1752.28
OOM 77.31 52.83
98.95 191.28 OOM OOM
S(.)=Sta
t(.)[Â§ 3.1] 25.97 25.15
OOM 7072.63 75.07
55.38 97.24 91.08 OOM 162.68
WFirmCore 70.17 58.17 3044.85 10935.29 94.36 61.38 104.70 228.09 205.98 199.62
S(.)=[Max(.),Min(.)] 60.86 50.71
2480.63 8115.23 72.69 46.85 92.48 209.72 191.03 OOT
OurDensityâ†‘ FirmCor e
[32] 68.79 54.20
2718.91 9017.69 82.56 57.38 101.55 220.43 198.71 180.62
(Problem 1) MLk-core
[28] 63.79 51.67
OOM OOM 75.09 51.33
99.71 219.84 OOM OOT
S(.)=Sum(.) 60.28 47.96
2472.58 8025.94 70.73 45.91 91.55 204.57 191.22 173.38
S(.)=WSum(.) 61.58 49.40
2499.74 8252.33 71.18 47.38 93.58 207.49 193.14 175.26
S(.)=MGcn(.)[9] 71.43 58.33 2635.17 OOM 78.68 50.04
95.47 214.72 OOM OOM
S(.)=MGa t(.)[9] 72.39 58.33 2881.32 OOM 81.25 48.87
97.29 212.49 OOM OOM
S(.)=Sta
t(.)[Â§ 3.1] 62.51 52.20
OOM 8368.29 72.69
50.95 91.68 211.31 OOM 176.83
WFirmCore 36 82
4219 7205 872 954 917 4788 20811 74893
S(.)=[Max(.),Min(.)]31 758
14355 7584 729 976 2980 6053 40172 OOT
Running Time
(s)â†“ FirmCor e
[32] 20 41
2454 3273 362 394 359 891 8053 36027
(Decomposition Alg.) MLk-core
[28] 57 3129
OOM OOM 1283 6852
3082 14159 OOM OOT
S(.)=Sum(.) 11 17 25 54 62 210 219 547 628 18518
S(.)=WSum(.) 24 21 23 59 68 296 307 526 579 19577
S(.)=MGcn(.)[9] 52 2062
30217 OOM 987 4570
1282 8911 OOM OOM
S(.)=MGa t(.)[9] 50 2208
24195 OOM 1199 1604
2735 5106 OOM OOM
S(.)=Sta
t(.)[Â§ 3.1] 27 968
OOM 433 775
4739 212 7946 OOM 19904
1 5 10 15 20 24
d102103104Running Time
1 5 10 15 20 24
d0.400.450.500.55Edge Density
Figure 2: The effect of ğ‘‘on Time (Left), and Density (Right).
that these methods do not use a pre-defined rule/pattern and find a
good summarizer in data-driven manner. 4As expected, (weighted)
collapsing the multiplex networks, by using S(.)=Sum(.)and
=WSum(.)achieve poor performance as it misses complex inter-
actions in different layers, causing impossibility of inference about
nodesâ€™ neighborhood [ 31].5The superior performance of WFirm-
Core over FirmCore shows the importance of considering layer
weights when finding dense structures.
Efficiency of Algorithms. The last part of Table 1 compares the
running time of the different dense subgraph models. As expected,
using simple summarizer function (e.g., Sum(.)and Top-ğœ†(.)) to
summarize the degree vector to a single number results in more
efficient decomposition algorithms. Furthermore, it shows that
using high dimensional representation of degree (i.e., large ğ‘‘) makes
the approach impractical for networks with either large size or |ğ¿|.
|E|0.5Ã—104
104
2Ã—104
4Ã—104
8Ã—104
16Ã—104|L|
1471013162024Time (s)
10 102 103 104 105
|V|0.5Ã—103
103
2Ã—103
4Ã—103
8Ã—103
16Ã—103|L|
1471013162024Time (s)
10102103104105Figure 3: The effect of |ğ¸|(Left), and|ğ‘‰|(Right) on running time.
Conclusion of Table 1. Table 1 is a clear evidence of the three-way
trade-off of efficiency (both time and memory), effectiveness (i.e.,
density), and too hard degree constraints (the output dimension of
S(.)) in real-world multiplex networks. That is, for large networks
(either graph size or #layers) we have to use methods that sum-
marize the degree vector to a single number. The main reason of
this three-way trade-off is that there is no pre-defined pattern/rule
that fits all networks, and so we need to decide about the patterns
of interests in a data driven manner, depending on the network
topology and available computation capacity.
The effect of ğ‘‘. To evaluate the effect of ğ‘‘on both running time
and density of S-cores, we vary its value and report the density and
1035A Unified Core Structure in Multiplex Networks: From Finding the Densest Subgraph to Modeling User Engagement KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
1 5 10 15 20 25 30 
Ï„10âˆ’310âˆ’210âˆ’1100Probability of Departure
Cannes2013
ObamaInIsraelNYClimate
1 500 1000 1500 2000 2500 
Degree010âˆ’410âˆ’310âˆ’210âˆ’1100Probability of Departure
Figure 5: Probability of departure vs. nodesâ€™ engagement level ğœ(Left), and nodesâ€™ average
degree (Right).
1 10 20 30  
k10âˆ’310âˆ’210âˆ’1100Probability of Departure
Cannes2013
ObamaInIsrael
NYClimateFigure 6: Probability of departure vs. core num-
ber in the collapsed graph.
Homo Sacchcere Brain DBLP0.00.20.40.60.81.0Ratio
ML K-Core
GuaranteeWFirmCore
Figure 4: The empirical approximation factor of WFC-Approx.
running time of S-coreon a subset of StackOverflow in Figure 2. As
expected, larger ğ‘‘always results in a slower decomposition algo-
rithm, as we have larger search space. On the other hand, however,
finding the best value of ğ‘‘to achieve higher density depends on the
network topology and the trend can vary from a dataset to another.
Accordingly, increasing ğ‘‘might result in lower density as it might
be a too hard constraint for core structures.
Scalability. Figure 3 demonstrates the effect of #layers and graph
size on the running time of the S-core decomposition algorithm. In
this part, we use different versions of a variable size subgraph of
StackOverflow obtained by selecting a variable number of layers
from 1 to 24. The running time of S-core, scales gracefully with
respect to both|ğ¸|and|ğ¿|and also scales near linear with respect
to|ğ¿|. Notably, based on the running time results in Table 1, some
variants of S-core (e.g., FirmCore [ 32] and WFirmCore) can scale
to graphs with billions of edges.
Densest Subgraph: Approximation Performance. To empiri-
cally evaluate the quality of the solution found by our proposed
approximation algorithm for Problem 1, we report the ratio of the
density of the found solution over the optimal density in Figure 4.
The results show that WFC-Approx algorithm, in practice, finds
solutions with higher density than its guarantee. We further com-
pare it with ML k-core, which is the state-of-the-art algorithm for
approximating the densest subgraph problem. The results show the
superior performance of our algorithm.
DBLP Case Study. Existing density measure forces all nodes to
exhibit their high degree in a fixed subset of layers. To support our
motivation of designing a new density measure that allows nodes to
exhibit their high degree in flexible subsets of layers, we perform a
case study on DBLP dataset. Here, each node is a researcher and two
nodes are connected if they have published a paper with each other.
The type of connections are obtained using LDA [ 12] algorithm
on the topics and abstracts of the paper. Accordingly, each layer is
the collaboration network in a specific research topic. We then findand compare the densest subgraph by our approach and Galimberti
et al. [28] . The found subgraph by our approach consists of two
communities,AandB, with edge density of 0.41, while the found
densest subgraph by Galimberti et al . [28] is onlyAwith edge
density of 0.38. Since the ML density forces all nodes to have high
degree in a fixed set of layers, it misses the Bcommunity as they
collaborated in different topics than the Acommunity. The found
communities are visualized in Appendix C.1.
Modeling User Engagement. In this experiment, we evaluate
the correlation between the proposed user engagement level, ğœ(.),
and the probability of departure from the network. We use three
temporal multiplex networks obtained from X(formerly Twitter)
during exceptional events with 3 layers, corresponding to repost,
mentions, and replies between users (details are in Appendix C).
We consider a user departed if they stop posting about the topic.
Figure 5 (Left) reports the probability of departure with respect to
ğœ(.). Interestingly, most users with a low (resp. high) engagement
level depart (resp. stay in) the network. These results support our
mathematical formulation for user engagement. Figure 5 (Right)
reports the same experiments with respect to the average degree.
The results show that a simple average degree is not a good indicator
of engagement in social networks.
Importance of Multiple Games. Figure 6 reports the probability
of departure with respect to the core number in a collapsed graph
obtained from a multilayer graph by merging edges. The results
indicate that the core number in a collapsed network, while infor-
mation about different types of connections is available, is not a
good indicator of engagement in social networks.
7 CONCLUSION
We present a new family of dense subgraphs in multiplex networks
that unifies existing families using a single function S(.). We show
thatS-core has the nice properties of ğ‘˜-cores in simple graphs and
suggest three methods (i.e., statistical inference-, sampling-, and
learning-based) to choose function S(.)in a data-driven manner.
We further propose a new density measure for multiplex networks,
and design a new variant of S-cores to effectively approximate
the solution of the densest subgraph problem. Finally, based on
S-cores, we propose a new mathematical model for modeling user
engagement in social networks with different types of interactions.
Our experimental evaluation shows the efficiency and effectiveness
of our algorithms and supports the proposed mathematical model
of user engagement.
1036KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Farnoosh Hashemi and Ali Behrouz
REFERENCES
[1]W Brian Arthur. 1989. Competing technologies, increasing returns, and lock-in
by historical events. The economic journal 99, 394 (1989), 116â€“131.
[2]N. Azimi-Tafreshi, J. Gomez-Garde, and S. N. Dorogovtsev. 2014. k-
corepercolation on multiplex networks. Physical Review E 90, 3 (Sep 2014).
[3]Vladimir Batagelj and MatjaÅ¾ ZaverÅ¡nik. 2011. Fast algorithms for determining
(generalized) core groups in social networks. Advances in Data Analysis and
Classification 5, 2 (2011), 129â€“145.
[4]Ali Behrouz and Farnoosh Hashemi. 2022. CS-MLGCN: Multiplex Graph Convo-
lutional Networks for Community Search in Multiplex Networks. In Proceedings
of the 31st ACM International Conference on Information and Knowledge Manage-
ment (Atlanta, GA, USA) (CIKM â€™22). Association for Computing Machinery, New
York, NY, USA, 3828â€“3832. https://doi.org/10.1145/3511808.3557572
[5]Ali Behrouz and Farnoosh Hashemi. 2023. Generalized Densest Subgraph in
Multiplex Networks. arXiv preprint arXiv:2310.04893 (2023).
[6]Ali Behrouz and Farnoosh Hashemi. 2024. Graph Mamba: Towards Learning on
Graphs with State Space Models. arXiv preprint arXiv:2402.08678 (2024).
[7]Ali Behrouz, Farnoosh Hashemi, and Laks V. S. Lakshmanan. 2022. FirmTruss
Community Search in Multilayer Networks. Proc. VLDB Endow. 16, 3 (nov 2022),
505â€“518. https://doi.org/10.14778/3570690.3570700
[8]Ali Behrouz, Michele Santacatterina, and Ramin Zabih. 2024. Chimera: Effectively
Modeling Multivariate Time Series with 2-Dimensional State Space Models. arXiv
preprint arXiv:2406.04320 (2024).
[9]Ali Behrouz and Margo Seltzer. 2022. Anomaly Detection in Multiplex Dynamic
Networks: from Blockchain Security to Brain Disease Prediction. In NeurIPS
2022 Temporal Graph Learning Workshop. https://openreview.net/forum?id=
UDGZDfwmay
[10] Ali Behrouz and Margo Seltzer. 2023. Anomaly Detection in Human Brain via
Inductive Learning on Temporal Multiplex Networks. In Machine Learning for
Healthcare Conference, Vol. 219. PMLR.
[11] Kshipra Bhawalkar, Jon Kleinberg, Kevin Lewi, Tim Roughgarden, and Aneesh
Sharma. 2015. Preventing unraveling in social networks: the anchored k-core
problem. SIAM Journal on Discrete Mathematics 29, 3 (2015), 1452â€“1475.
[12] David Blei, Andrew Ng, and Michael Jordan. 2001. Latent Dirichlet Allocation.
The Journal of Machine Learning Research 3, 601â€“608.
[13] Lawrence E Blume. 1993. The statistical mechanics of strategic interaction. Games
and economic behavior 5, 3 (1993), 387â€“424.
[14] Alessio Cardillo, JesÃºs GÃ³mez-Gardenes, Massimiliano Zanin, Miguel Romance,
David Papo, Francisco del Pozo, and Stefano Boccaletti. 2013. Emergence of
network features from multiplexity. Scientific reports 3, 1 (2013), 1â€“6.
[15] Fabio Celli, F Marta L Di Lascio, Matteo Magnani, Barbara Pacelli, and Luca Rossi.
2010. Social Network Data and Practices: the case of Friendfeed. In SBP-BRiMS
(Lecture Notes in Computer Science). Springer Berlin Heidelberg.
[16] Moses Charikar, Yonatan Naamad, and Jimmy Wu. 2018. On Finding Dense
Common Subgraphs. arXiv:1802.06361 [cs.DS]
[17] Shuntong Chen, Huaien Qian, Yanping Wu, Chen Chen, and Xiaoyang Wang.
2019. Efficient Adoption Maximization in Multi-layer Social Networks. In 2019
International Conference on Data Mining Workshops (ICDMW). 56â€“60. https:
//doi.org/10.1109/ICDMW.2019.00017
[18] Jonathan Cohen. 2008. Trusses: Cohesive Subgraphs for Social Network Analysis.
InNational security agency. Technical report.
[19] The dblp team. [n. d.]. dblp computer science bibliography. https://dblp.uni-
trier.de/xml/.
[20] M. De Domenico, A. Lima, P. Mougel, and M. Musolesi. 2013. The Anatomy of a
Scientific Rumor. Scientific Reports 3, 1 (2013).
[21] M. De Domenico, M. A. Porter, and A. Arenas. 2014. MuxViz: a tool for multilayer
analysis and visualization of networks. Journal of Complex Networks 3, 2 (Oct
2014), 159â€“176. https://doi.org/10.1093/comnet/cnu038
[22] M. De Domenico, V. Nicosia, A. Arenas, and V. Latora. 2015. Structural reducibility
of multilayer networks. Nature communications 6 (2015), 6864.
[23] Xiaoxi Du, Ruoming Jin, Liang Ding, Victor E. Lee, and John H. Thornton Jr.
2009. Migration motif: a spatial - temporal pattern mining approach for financial
markets. In KDD. 1135â€“1144.
[24] Ehsan Elhamifar and M De Paolis Kaluza. 2017. Subset selection and summariza-
tion in sequential data. Advances in Neural Information Processing Systems 30
(2017).
[25] Glenn Ellison. 1993. Learning, local interaction, and coordination. Econometrica:
Journal of the Econometric Society (1993), 1047â€“1071.
[26] AndrÃ¡s FaragÃ³. 2008. A general tractable density concept for graphs. Mathematics
in Computer Science 1, 4 (2008), 689â€“699.
[27] Eugene Fratkin, Brian T Naughton, Douglas L Brutlag, and Serafim Batzoglou.
2006. MotifCut: regulatory motifs finding with maximum density subgraphs.
Bioinformatics (Oxford, England) 22, 14 (July 2006).
[28] Edoardo Galimberti, Francesco Bonchi, and Francesco Gullo. 2017. Core De-
composition and Densest Subgraph in Multilayer Networks. In Conference on
Information and Knowledge Management (CIKM).
[29] A. Goldberg. 1984. Finding a Maximum Density Subgraph. Technical Report.[30] Neil Zhenqiang Gong, Wenchang Xu, Ling Huang, Prateek Mittal, Emil Stefanov,
Vyas Sekar, and Dawn Song. 2012. Evolution of Social-Attribute Networks: Mea-
surements, Modeling, and Implications Using Google+. In Internet Measurement
Conference. ACM, NY, USA, 131â€“144.
[31] Farnoosh Hashemi and Ali Behrouz. 2024. A Unified Core Structure in Multiplex
Networks: From Finding the Densest Subgraph to Modeling User Engagement.
arXiv preprint arXiv:2406.13734 (2024).
[32] Farnoosh Hashemi, Ali Behrouz, and Laks V.S. Lakshmanan. 2022. FirmCore
Decomposition of Multilayer Networks. In Proceedings of the ACM Web Confer-
ence 2022 (Virtual Event, Lyon, France) (WWW â€™22). Association for Computing
Machinery, New York, NY, USA, 1589â€“1600. https://doi.org/10.1145/3485447.
3512205
[33] Petter Holme and Jari SaramÃ¤ki. 2012. Temporal networks. Physics Reports
519, 3 (2012), 97â€“125. https://doi.org/10.1016/j.physrep.2012.03.001 Temporal
Networks.
[34] V. Jethava and N. Beerenwinkel. 2015. Finding Dense Subgraphs in Relational
Graphs. In Machine Learning and Knowledge Discovery in Databases. Springer
International Publishing, Cham, 641â€“654.
[35] Junteng Jia and Austion R Benson. 2020. Residual correlation in graph neural net-
work regression. In Proceedings of the 26th ACM SIGKDD international conference
on knowledge discovery & data mining. 588â€“598.
[36] Michael L Katz and Carl Shapiro. 1985. Network externalities, competition, and
compatibility. The American economic review 75, 3 (1985), 424â€“440.
[37] Yasushi Kawase, Atsushi Miyauchi, and Hanna Sumita. 2023. Stochastic So-
lutions for Dense Subgraph Discovery in Multilayer Networks. In Proceedings
of the Sixteenth ACM International Conference on Web Search and Data Mining
(<conf-loc>, <city>Singapore</city>, <country>Singapore</country>, </conf-
loc>) (WSDM â€™23). Association for Computing Machinery, New York, NY, USA,
886â€“894. https://doi.org/10.1145/3539597.3570444
[38] Thomas N. Kipf and Max Welling. 2017. Semi-Supervised Classification with
Graph Convolutional Networks. In International Conference on Learning Repre-
sentations. https://openreview.net/forum?id=SJU4ayYgl
[39] Mikko KivelÃ¤, Alex Arenas, Marc Barthelemy, James P. Gleeson, Yamir Moreno,
and Mason A. Porter. 2014. Multilayer networks. Journal of Complex Networks 2
(2014), 203â€“271. https://doi.org/10.1093/comnet/cnu016
[40] Tommaso Lanciano, Atsushi Miyauchi, Adriano Fazzone, and Francesco
Bonchi. 2023. A Survey on the Densest Subgraph Problem and its Variants.
arXiv:2303.14467 [cs.DS]
[41] Jure Leskovec, Lada A. Adamic, and Bernardo A. Huberman. 2007. The Dynamics
of Viral Marketing. ACM Trans. Web 1, 1 (May 2007), 5â€“es.
[42] Don R. Lick and Arthur T. White. 1970. k-Degenerate Graphs. Canadian Journal
of Mathematics 22, 5 (1970), 1082â€“1096. https://doi.org/10.4153/CJM-1970-125-1
[43] Boge Liu, Fan Zhang, Chen Zhang, Wenjie Zhang, and Xuemin Lin. 2019. Core-
Cube: Core Decomposition in Multilayer Graphs. In Web Information Systems
Engineering â€“ WISE 2019, Reynold Cheng, Nikos Mamoulis, Yizhou Sun, and Xin
Huang (Eds.). Springer International Publishing, Cham, 694â€“710.
[44] Dandan Liu and Zhaonian Zou. 2023. gCore: Exploring Cross-Layer Cohesiveness
in Multi-Layer Graphs. Proc. VLDB Endow. 16, 11 (jul 2023), 3201â€“3213. https:
//doi.org/10.14778/3611479.3611519
[45] Xueming Liu, Enrico Maiorino, Arda Halu, Kimberly Glass, Rashmi B. Prasad,
and Joseph Loscalzo. 2020. Robustness and lethality in multilayer biological
molecular networks. Nature Communications 11 (2020).
[46] Lutz Oettershagen, Honglian Wang, and Aristides Gionis. 2024. Finding Densest
Subgraphs with Edge-Color Constraints. In Proceedings of the ACM on Web Con-
ference 2024 (, Singapore, Singapore,) (WWW â€™24). Association for Computing Ma-
chinery, New York, NY, USA, 936â€“947. https://doi.org/10.1145/3589334.3645647
[47] Umit Y Ogras and Hakan Ferhatosmanoglu. 2006. Online summarization of
dynamic time series data. The VLDB Journal 15 (2006), 84â€“98.
[48] Elisa Omodei, Manlio De Domenico, and Alex Arenas. 2015. Characterizing
interactions in online social networks during exceptional events. Frontiers in
Physics 3 (2015), 59. https://doi.org/10.3389/fphy.2015.00059
[49] Kaiyan Peng, Zheng Lu, Vanessa Lin, Michael R. Lindstrom, Christian Parkinson,
Chuntian Wang, Andrea L. Bertozzi, and Mason A. Porter. 2021. A Multilayer
Network Model of the Coevolution of the Spread of a Disease and Competing
Opinions. arXiv:2107.01713 [cs.SI]
[50] Pekka SÃ¤Ã¤skilahti. 2005. Monopoly pricing of social goods. (2005).
[51] Nate Veldt, Austin R. Benson, and Jon Kleinberg. 2021. The Generalized Mean
Densest Subgraph Problem. In Proceedings of the 27th ACM SIGKDD (Virtual
Event, Singapore) (KDD â€™21). ACM, New York, NY, USA, 1604â€“1614. https:
//doi.org/10.1145/3447548.3467398
[52] Huanhuan Wu, James Cheng, Yi Lu, Yiping Ke, Yuzhen Huang, Da Yan, and
Hejun Wu. 2015. Core decomposition in large temporal graphs. In 2015 IEEE
International Conference on Big Data (Big Data). 649â€“658.
[53] Chun-Xue Zhu, Long-Long Lin, Ping-Peng Yuan, and Hai Jin. 2022. Discovering
cohesive temporal subgraphs with temporal density aware exploration. Journal
of Computer Science and Technology 37, 5 (2022), 1068â€“1085.
1037A Unified Core Structure in Multiplex Networks: From Finding the Densest Subgraph to Modeling User Engagement KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
ğ‘¤=1
w	=10w=10ğ‘£5ğ‘£3ğ‘£7ğ‘£2ğ‘£4ğ‘£8ğ‘£6ğ‘£1
Figure 7: An example of multiplex collaboration network.
A EXAMPLE: HOW LAYER WEIGHT CAN
AFFECT THE CORE STRUCTURES?
Figure 7 shows a multiplex network, where w(ğ‘£,ğ‘™1)=1,w(ğ‘£,ğ‘™2)=
10, and w(ğ‘£,ğ‘™3)=10,âˆ€ğ‘£âˆˆğ‘‰. FirmCore decomposition treats all
relation types equally and ignores the weights of the layers, there-
fore causing missing information. For example, in the multilayer
graph depicted in Figure 7, FirmCore decomposition, while ignoring
weights, finds{ğ‘£1,ğ‘£2,...,ğ‘£ 8}(the union of blue and red nodes) as a
(1,1),(2,1),(1,2),(2,2)-FirmCore and is not able to find any other
subgraph. However, based on weights, the second and third layers
are more important. Therefore, the WFirmCore decomposition finds
{ğ‘£1,ğ‘£2,...,ğ‘£ 5}(red nodes) as a(2,20)-WFirmCore and{ğ‘£1,ğ‘£2,...,ğ‘£ 8}
(the union of blue and red nodes) as a (1,11),(2,11)-WFirmCore.
This means that WFirmCore takes into account the importance of
layers for each node and provides a more diverse solution space.
B PROOFS
B.1 Lemma 1
Proof. First, let w=1andğ‘†(X)=X, then k-S-core is equivalent
to multilayer k-core [ 28]. Also, given a subset of layers Ë†ğ¿âŠ†ğ¿,
letw=1andğ‘†(X)=XË†ğ¿(corresponding elements to Ë†ğ¿), and
k=[ğ‘˜,ğ‘˜,...,ğ‘˜]1Ã—|Ë†ğ¿|then k-S-core is equivalent to CoreCube [ 43].
Moreover, given ğœ†âˆˆN, letw=1andğ‘†(X)=Top-ğœ†(X), then
k-S-core is equivalent to FirmCore [32]. â–¡
B.2 Proposition 1
Proof. Since all subgraphs are k=[0]1Ã—ğ‘‘-S-core, the set of all
coreness vector of each subgraph is non-empty and so the maximal
coreness vector exists. To show that this maximal coreness vector
is unique, we use contradiction. Assume that there are two k=
[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘â‰ kâ€²=[ğ‘˜â€²
ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘such that both are maximal coreness
vector ofğº[ğ¶]. Based on the definition of maximal coreness vector,
there are indices â„“1andâ„“2such thatğ‘˜â„“1>ğ‘˜â€²
â„“1andğ‘˜â€²
â„“2>ğ‘˜â„“2. Now
define Ëœk=[Ëœğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘such that Ëœğ‘˜â„“=max{ğ‘˜â„“,ğ‘˜â€²
â„“}for all 1â‰¤â„“â‰¤
ğ‘‘. Based on the definition of maximal coreness vector, Ëœkis also
coreness vector of ğº[ğ¶], which contradicts the maximality of k=
[ğ‘˜ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘â‰ kâ€²=[ğ‘˜â€²
ğ‘–]1â‰¤ğ‘–â‰¤ğ‘‘. Therefore, the maximal coreness
vector for each S-core exists and is unique. â–¡B.3 Proposition 2
Proof. Suppose that ğº[ğ¶k]andğº[ğ¶â€²
k]are two distinct k-S-
cores ofğº. We know that ğº[ğ¶k]is a maximal subgraph such that
âˆ€ğ‘£âˆˆğº[ğ¶k]:S(degğ¶k(ğ‘£))ğ‘–â‰¥ğ‘˜ğ‘–for all 1â‰¤ğ‘–â‰¤ğ‘‘. Similarly,ğº[ğ¶â€²
k]
is a maximal subgraph with the same property. Then any node
ğ‘£âˆˆğº[ğ¶kâˆªğ¶â€²
k]has been in either ğº[ğ¶k]orğº[ğ¶â€²
k], which means
thatS(degğ¶kâˆªğ¶â€²
k(ğ‘£))ğ‘–â‰¥S(degğ¶k(ğ‘£))ğ‘–â‰¥ğ‘˜ğ‘–. Therefore, ğº[ğ¶kâˆªğ¶â€²
k]
satisfies the S-core conditions, contradicting the maximality of
ğº[ğ¶k]andğº[ğ¶â€²
k]. â–¡
B.4 Proposition 3
Proof. Letğ‘£âˆˆğº[ğ¶k], based on the definition of S-cores, we
have: S(degğ¶k(ğ‘£))â‰¥ kand so S(degğ¶k(ğ‘£))â‰¥ kâ€². This implies that
ğ‘£âˆˆğº[ğ¶kâ€²]and soğº[ğ¶k]âŠ†ğº[ğ¶kâ€²]. â–¡
B.5 Theorem 1
Proof. We prove by contradiction. First, it is clear that ğº[ğ¶]is
([minğ‘¢âˆˆğ¶S(degğ¶(ğ‘¢))ğ‘–]ğ‘‘
ğ‘–=1)-S-core, since for each node ğ‘¢âˆˆğ¶and
ğ‘–=1,...,ğ‘‘ we have: S(degğ¶(ğ‘¢))ğ‘–â‰¥minğ‘£âˆˆğ¶S(degğ¶(ğ‘£))ğ‘–,, which
satisfies the condition of the S-cores. Now let Ë†k=[Ë†ğ‘˜ğ‘–]ğ‘‘
ğ‘–=1be the
maximal SCVindex ofğº[ğ¶]. This means that there is index ğ‘—such
that Ë†ğ‘˜ğ‘—>minğ‘¢âˆˆğ¶S(degğ¶(ğ‘¢))ğ‘—. This contradicts the definition of
S-cores as the node that attains the minğ‘¢âˆˆğ¶S(degğ¶(ğ‘¢))ğ‘—cannot
satisfy S-core conditions for vector Ë†k=[Ë†ğ‘˜ğ‘–]ğ‘‘
ğ‘–=1. â–¡
B.6 Lemma 2
Proof. Givenğœ†, letwâ„“=2â„“for allâ„“âˆˆğ¿andS(X)=Top-ğœ†(X).
If we consider the binary representation of ğœ†, then by finding(ğ‘˜,ğœ†)-
WFirmCore we exactly know what layers are choosen. Accordingly,
givenÎ”in span core, one can consider the set of all values of Î”such
that the summation of layer weights for all possible Î”consecutive
layer is calculated. Let us call this set Î¦. Now(ğ‘˜,ğœ†)-WFirmCore for
ğœ†âˆˆÎ¦is equivalent to span core with parameter Î”. â–¡
B.7 Theorem 2
Proof. To show the NP-hardness of WFirmCore decomposition,
we show that its special case is NP-hard. To this end, we assume
that the weight of each layer is the same across different nodes, i.e.,
w(ğ‘¢,â„“)=w(ğ‘£,â„“)for anyğ‘¢,ğ‘£âˆˆğ‘‰andâ„“âˆˆğ¿. Given a sequence of
layer weights ğ‘¤1,ğ‘¤2,...,ğ‘¤|ğ¿|, the well-known NP-hard problem of
theSubset Sum overğ‘¤1,ğ‘¤2,...,ğ‘¤|ğ¿|can be reduced to the decision
problem of whether there is a non-empty (ğ‘˜,ğœ†)-WFirmCore, as its
YES (resp. NO) instance means there is (resp. is not) a subset of ğ‘¤ğ‘–â€™s
with summation of ğœ†.
Since the weight of each layer is integer, we copy each layer by
its weight. Therefore, the resulted multiplex graph is unweighted.
Now, layer-weighted FirmCore on the original graph is equivalent
to simple FirmCore on the constructed graph and since FirmCore
decomposition has polynomial time complexity, i.e., O(|ğ¸||Ëœğ¿|3+
|ğ‘‰||Ëœğ¿|log|Ëœğ¿|)), WFirmCore decomposition can be done in Pseudo-
polynomial time. Note that here Ëœğ¿is the summation of weights. â–¡
1038KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Farnoosh Hashemi and Ali Behrouz
B.8 Theorem 3
Proof. Assume the case where w(ğ‘¢,â„“)=1for allğ‘¢âˆˆğ‘‰and
â„“âˆˆğ¿. We reduce our problem to the problem of densest common
subgraph [ 34], which is NP-hard and also cannot have approxima-
tion algorithm with a constant factor [ 16]. Without loss of gener-
ality we can assume that there is no node with degree zero in at
least one layer. This is a valid assumption as we can simple add a
dummy node and connected to all existing nodes. Therefore, the
dummy node is always in the densest subgraph, and removing it
cannot affect the subgraph that attains the maximum density. Let
ğº=(ğ‘‰,ğ¸,ğ¿)be an arbitrary instance of the problem of densest
common subgraph, let ğ›½be large enough that forces the objective
function to choose all the layers. In this case, the objective function
is equivalent to the densest common subgraph problem in [ 34].â–¡
B.9 Theorem 4
Proof. For anyğ‘¢âˆˆğ‘†, we let Î”ğ‘¢(ğ‘†)=|ğ‘†|ğœŒ(ğ‘†)âˆ’(|ğ‘†|âˆ’1)ğœŒ(ğ‘†\{ğ‘¢}).
It shows how removing node ğ‘¢can affect the numerator of density
function (note that removing any node affect the denominator in
the same way). Now, let ğ‘†âˆ—be the optimal solution with density
ğ›¾
|ğ‘†âˆ—|, removing a node cannot increase the density so we have:
ğ›¾
|ğ‘†âˆ—|â‰¥ğ›¾âˆ’Î”ğ‘¢(ğ‘†âˆ—)
|ğ‘†âˆ—|âˆ’1â‡’Î”ğ‘¢(ğ‘†âˆ—)â‰¥ğ›¾
|ğ‘†âˆ—|=ğœŒ(ğ‘†âˆ—). (8)
Now note that:
Î”ğ‘¢(ğ‘†)â‰¤max
Ë†ğ¿âŠ†ğ¿min
â„“âˆˆË†ğ¿degâ„“(ğ‘¢)|ğ¿|ğ›½+âˆ‘ï¸
ğ‘£âˆˆğ‘(ğ‘£)|ğ¿|ğ›½â‰¤2|ğ¿|ğ›½min
â„“âˆˆğ¿degâ„“(ğ‘¢).
Now, letğ‘¢=arg minğ‘£âˆˆğ‘†âˆ—min minâ„“âˆˆğ¿degâ„“(ğ‘£), it is simple to see
that(minâ„“âˆˆğ¿degâ„“(ğ‘¢),1)-WFirmCore is not empty and also is con-
sidered in Algorithm 5, which proves the theorem. â–¡
B.10 Proposition 4
Proof. This inequality comes from the definition of the objec-
tive functions. Let ğ¿âˆ—be the selected set of layers in objective of
Galimberti et al. [28], then we have:
ğœŒ(ğº[ğ»])=1
|ğ‘†|âˆ‘ï¸
ğ‘¢âˆˆğ»max
Ë†ğ¿âŠ†ğ¿min
â„“âˆˆË†ğ¿degâ„“(ğ‘¢)Ã—|Ë†ğ¿|ğ›½(9)
â‰¥1
|ğ‘†|âˆ‘ï¸
ğ‘¢âˆˆğ»min
â„“âˆˆğ¿âˆ—degâ„“(ğ‘¢)Ã—|ğ¿âˆ—|ğ›½=ğœŒâˆ—(ğº[ğ»]). (10)
B.11 Theorem 5
Proof. We first show that k-S-core is an equilibrium. To this
end, assume that a user ğ‘¢who has decided to drop out wants to
change their decision. In this case, its new utility in each layer will
be negative. On the other hand, if a user ğ‘¢who has decided to
remain engage wants to change their decision and drop out, then
its utility in each layer will be zero. Accordingly, no user wants
to change their decision. Now, note that since the definition of
k-S-core is the maximal subgraph with this property, the maximal
equilibrium should be the maximal k-S-core. â–¡
C DATASETS
We perform experiments on ten real networks, including social, ge-
netic, co-authorship, financial, brain, and co-purchasing networks.SacchCere and Homo [21] are biological networks concerning dif-
ferent genetic interactions between genes in Homo Sapiens and
Saccharomyces Cerevisiae, respectively. FAO [ 22] represents vari-
ous trade relationships among countries, where layers signify prod-
ucts, nodes represent countries, and edges at each layer depict
import/export connections among countries. Brain [ 4,7] is derived
from the functional magnetic resonance imaging (fMRI) of 520 indi-
viduals using the same methodology as in [ 7]. In this dataset, each
layer represents the brain network of an individual, where nodes
correspond to brain regions, and edges show the statistical correla-
tion between the functionality of these nodes. DBLP [ 19] is a co-
authorship network derived following the methodology in [ 7,28],
where each layer represents topics of papers determined using LDA
topic modeling [ 12]. Nodes correspond to researchers, and edges de-
note co-authorship relationships. Amazon [ 41] is a co-purchasing
network, in which each layer is associated with one of its four
snapshots between March and June 2003. FFTwitter [ 15] is a social
network where layers correspond to interactions on Friendfeed and
Twitter, and nodes represent users registered on both platforms.
Friendfeed [ 15] contains interactions such as commenting, liking,
and following among its users over two months. StackOverflow [ 7]
represents user interactions from the StackExchange website, where
each layer corresponds to interactions during a specific hour of
the day. Google+ [ 30,32] comprises four snapshots from Google+
captured between July and October 2011. ObamaInIsrael [ 48] rep-
resents retweeting, mentioning, and replying among Twitter users,
with a focus on Barack Obamaâ€™s visit to Israel in 2013. Cannes [ 48]
represents retweeting, mentioning, and replying among Twitter
users, with a focus on the Cannes Film Festival in 2013. Finally,
NYClimate [ 48] represents retweeting, mentioning, and replying
among Twitter users, with a focus on the Peopleâ€™s Climate March
in 2014. We use an unsupervised approach to automatically assign
weight to the datasets that do not have layer weights [9].
Figure 8: User Multilayer densest subgraph based on our density in
the DBLP dataset.
C.1 Case Study: DBLP
We report the found densest subgraph by our approach (Left) and
Galimberti et al . [28] (Right) in Figure 8. While both approaches
found the left community as a dense structure, the density measure
proposed by Galimberti et al . [28] misses the other dense structure
as they collaborated in different topics than the left community.
Since this density metric forces all nodes to be active (having high
degree) in a fixed set of layers, it misses this dense structure.
C.2 Full Version, Code, and Datasets
The source code and data have been made available at This link.
See [31] for additional experiments, examples, and proofs.
1039