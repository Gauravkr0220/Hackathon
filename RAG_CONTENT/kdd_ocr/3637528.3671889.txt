Scalable Temporal Motif Densest Subnetwork Discovery
Ilie Sarpe
KTH Royal Institute of Technology
Stockholm, Sweden
ilsarpe@kth.seFabio Vandin
University of Padova
Padova, Italy
fabio.vandin@unipd.itAristides Gionis
KTH Royal Institute of Technology
Stockholm, Sweden
argioni@kth.se
Abstract
Finding dense subnetworks, with density based on edges or more
complex structures, such as subgraphs or ğ‘˜-cliques, is a fundamental
algorithmic problem with many applications. While the problem
has been studied extensively in static networks, much remains to
be explored for temporal networks.
In this work we introduce the novel problem of identifying the
temporal motif densest subnetwork, i.e., the densest subnetwork with
respect to temporal motifs, which are high-order patterns charac-
terizing temporal networks. Identifying temporal motifs is an ex-
tremely challenging task, and thus, efficient methods are required.
To address this challenge, we design two novel randomized ap-
proximation algorithms with rigorous probabilistic guarantees that
provide high-quality solutions. We perform extensive experiments
showing that our methods outperform baselines. Furthermore, our
algorithms scale on networks with up to billions of temporal edges,
while baselines cannot handle such large networks. We use our tech-
niques to analyze a financial network and show that our formula-
tion reveals important network structures, such as bursty temporal
events and communities of users with similar interests.
CCS Concepts
â€¢Theory of computation â†’Graph algorithms analysis; â€¢
Mathematics of computing â†’Probabilistic algorithms.
Keywords
temporal motifs; temporal networks; randomized algorithms
ACM Reference Format:
Ilie Sarpe, Fabio Vandin, and Aristides Gionis. 2024. Scalable Temporal Motif
Densest Subnetwork Discovery. In Proceedings of the 30th ACM SIGKDD
Conference on Knowledge Discovery and Data Mining (KDD â€™24), August
25â€“29, 2024, Barcelona, Spain. ACM, New York, NY, USA, 12 pages. https:
//doi.org/10.1145/3637528.3671889
1 Introduction
Networks (or graphs) are fundamental abstractions for understand-
ing and characterizing complex systems, such as social networks [ 21],
biological systems [ 16], and more [ 32,37]. An important primitive
in graph mining is the discovery of dense subgraphs [25]. Dense-
subgraphs find applications in areas such as visualization [ 61],
anomaly detection [ 15], finance [ 7], and social networks [ 20,29].
The density of a subnetwork is often defined as the total number
This work is licensed under a Creative Commons Attribution-
NonCommercial-ShareAlike International 4.0 License.
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Â©2024 Copyright held by the owner/author(s).
ACM ISBN 979-8-4007-0490-1/24/08
https://doi.org/10.1145/3637528.3671889
ğ‘£1
ğ‘£2
ğ‘£3
ğ‘£4
ğ‘£5
ğ‘£6
ğ‘£7ğ‘¥1 ğ‘¥2
ğ‘¥3ğ‘¡1Temporal Motif ğ‘€
ğ‘¡2 ğ‘¡3
ğœ:âŸ¨ (ğ‘¥1, ğ‘¥2),(ğ‘¥2, ğ‘¥3),(ğ‘¥3, ğ‘¥1) âŸ©1,3Temporal Network ğ‘‡
4
5
6,9
7810 ,1716
15 12 ,13
11 ,202225(a)
ğ‘£1
ğ‘£2
ğ‘£310
ğ‘†11
4
ğ‘£1
ğ‘£2
ğ‘£33
10
ğ‘†24
ğ‘£1
ğ‘£2
ğ‘£33
16
ğ‘†34
ğ‘£1
ğ‘£2
ğ‘£33
17
ğ‘†44
(b)
Figure 1: 1a: Representation of a temporal network ğ‘‡withğ‘›=
7vertices,ğ‘š=18edges (edge labels denote the timings, and
commas denote multiple edges), and a temporal motif ğ‘€with
its ordering ğœ(i.e.,ğœcaptures the temporal dynamics of the
motifğ‘€). 1b: forğ›¿=10only the green sequences ( ğ‘†1,ğ‘†2) are
ğ›¿-instances of ğ‘€inğ‘‡; the red sequences are not ğ›¿-instances,
sinceğ‘†3cannot be mapped on the motif ğ‘€followingğœ, andğ‘†4
exceeds the timing constraint on ğ›¿.
of its edges divided by the number of its vertices, and the densest
subnetwork is the one attaining maximum density. The definition
of density can be extended to higher-order structures, such as ğ‘˜-
cliques orğ‘˜-vertex motifs [19,67,69], leading to subnetworks that
offer a more nuanced characterization of the data, e.g., more tightly-
connected communities in social networks.
Many real-world networks are inherently temporal [31], contain-
ing information about the timing of the interactions [ 48]. Temporal
networks enable the study of novel phenomena not observable
otherwise, such as bursty activities [ 35], dynamic reachability, tem-
poral centrality [52, 60, 68], and more [30, 51].
Temporal motifs are small-size subgraphs with edges having
temporal information and a duration bound [ 34,44,45,75]. The
temporal information on the edges captures the temporal dynamics
of the motif, for example, information can spread on a temporal
pathğ‘¥ğ‘¡1â†’ğ‘§ğ‘¡2â†’ğ‘¤only ifğ‘¡1<ğ‘¡2. In addition, a duration constraint
ensures that relevant events occur sufficiently close in time, e.g.,
ğ‘¡2âˆ’ğ‘¡1is not too large. Temporal motifs are building blocks for tem-
poral networks, finding novel applications, such as cryptocurrency
network analysis [ 3,74], anomaly detection [ 5], and more [ 39,46].
There has been growing interest in developing efficient algo-
rithms to count and enumerate temporal motifs [ 11,44,47,54,56,
 
2536
KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ilie Sarpe, Fabio Vandin, and Aristides Gionis
62,63,73]. Identifying temporal motifs is a challenging task, con-
siderably harder than its counterpart in static networks. In fact,
there are motifs that can be identified in polynomial time in static
networks but their identification becomes NP-hard in temporal
networks [ 44]. Therefore, little has been done in characterizing
temporal subnetworks with respect to temporal motif instances.
In this work we introduce and study the novel problem of discov-
ering the densest temporal subnetwork with respect to a temporal
motif, that is given a large temporal network and a temporal motif,
our goal is to find the temporal-motif densest subnetwork, i.e., the
subnetwork maximizing a density function that accounts for the
number of temporal motif instances normalized by its size.
Example. Consider a financial temporal network and a temporal
triangleğ‘€:ğ‘¥ğ‘¡1â†’ğ‘§ğ‘¡2â†’ğ‘¤ğ‘¡3â†’ğ‘¥as from Figure 1a, where ğ‘€
captures potential money laundering activities occurring between
users in a short duration [ 42,74]. Some users may be known to be
involved in suspicious activities (e.g., they transfer large amount
of money; shown in red in Fig. 1a) while others are not (e.g., no
history is available for their transactions; shown in yellow or blue
in Fig. 1a). By finding the marked densest subnetwork ( {ğ‘£1,...,ğ‘£ 5})
according to motif ğ‘€we can identify a tightly-connected subset
of users potentially involved in suspicious activities. Interestingly,
this subnetwork may contain new suspicious users (in yellow in
Fig. 1a), not previously identified.
Other promising applications captured by our formulation are,
for example, (i) identifying frequent destinations appearing together
from user travel data, i.e., groups of attractions visited following
a specified travel journey captured by a temporal motif [ 39]; and
(ii) detecting dense groups of users and items according to spe-
cific purchase sequences on e-commerce platforms, again captured
trough temporal motifs [ 11,56]. In both scenarios, the temporal
motif-subnetwork densest subnetwork can provide unique insights,
for (i) it can be used to design novel public transport routes or travel
passes; and for (ii) it can be used for personalized advertising or
identifying users with common purchase habits.
Solving the problem we propose requires exact enumeration ofall
temporal motif instances in the input network, which is extremely
inefficient to perform. To address this issue we propose ALDENTE,
a suite of randomized approximation ALgorithms for the tempo-
ral motif DENsest subneTwork problEm. ALDENTE contains two
novel approximation algorithms leveraging a randomized sampling
procedure, which has been successfully employed for temporal mo-
tif counting [ 44,56,62,63]. Our novel algorithms can leverage any
state-of-the-art unbiased sampling algorithm for temporal motif
counting. The first algorithm in ALDENTE peels the vertex set in
batches until it becomes empty (removing vertices participating in
few temporal motif instances), estimating for smallğœ€>0within
(1Â±ğœ€)the different counts needed for peeling. The second algo-
rithm adopts a similar estimated batch-peeling technique but only
for a fixed number of steps. On the remaining vertices it applies
agreedy-peeling approach, where vertices that participate in few
temporal motif instances are peeled one at a time. By carefully com-
bining estimates, our methods output a high-quality solution with
controlled error probability. Both our algorithms avoid exhaustive
enumeration of all temporal motifs in the input network.We show that the problem we study cannot be solved by directly
applying existing techniques tailored to static high-order density
formulations that ignore the information provided by temporal mo-
tifs [14,19,49,67,69,70,72], as this leads to poor quality solutions.
We then embed temporal information in a weighted set of subgraphs,
which can be used to leverage existing techniques for the identifica-
tion ofğ‘˜-vertex Motif Densest Subnetworks ( ğ‘˜-MDS). This results
into three baselines (an exact methods and two approximate ones),
extending previous ideas for static networks [4, 12, 17, 26].
We finally show that the methods in ALDENTE find high-quality
solutions on billion-edge temporal networks in few hundreds of sec-
onds, where all other baselines cannot terminate in hours.
Summarizing, our contributions are as follows:
1.We introduce the Temporal Motif Densest Subnetwork (TMDS)
problem, asking for the densest subnetwork of a temporal network,
where the density considers the number of instances of a temporal
motif. The TMDS problem strongly differs from existing temporal
cohesive subgraph formulations given its temporal motif -based
density formulation. We show that the TMDS problem is not cap-
tured by analogous formulations on static networks ( ğ‘˜-MDS) that
disregard temporal information. We then develop three baselines
extending ideas for ğ‘˜-MDS discovery embedding temporal infor-
mation in a suitable weighted set of subgraphs, unfortunately such
algorithms do not scale on large data.
2.We design ALDENTE, a suite of two novel approximation al-
gorithms based on randomized sampling and peeling techniques,
providing high-quality solutions andscaling on massive networks.
3.We perform experiments on medium- and large-size temporal
networks, with up to billions of edges, validating ALDENTE. We
show that baselines are often inefficient on large datasets. Our
randomized algorithms consistently achieve speedups from Ã—2to
Ã—43, saving hundreds of GBs of memory, and reporting high-quality
solutions. We conclude with a case study on a financial network
discovering interesting temporal motif dense subnetworks.
Details on application scenarios for TMDS are provided in App. A,
and a summary of the notation is found in App. B. The detailed
proofs of all the theoretical results are reported in our extended
version [64]. Our implementation is publicly available.1
2 Preliminaries
Atemporal network is a pairğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğ‘‡), whereğ‘‰ğ‘‡={ğ‘£1,...,ğ‘£ğ‘›}
is a set of vertices and ğ¸ğ‘‡={(ğ‘¢,ğ‘£,ğ‘¡):ğ‘¢,ğ‘£âˆˆğ‘‰ğ‘‡,ğ‘¡âˆˆR+}is a set
oftemporal edges. We let ğ‘›=|ğ‘‰ğ‘‡|be the number of vertices and
ğ‘š=|ğ¸ğ‘‡|be the number of edges. Each edge ğ‘’=(ğ‘¢,ğ‘£,ğ‘¡)âˆˆğ¸ğ‘‡
contains a timestamp ğ‘¡, representing the time of its occurrence.2
Without loss of generality we assume that the edges in ğ¸ğ‘‡are listed
by increasing timestamp and that timestamps are distinct.3
Next we introduce temporal motifs. For concreteness, we adopt
the definition of temporal motifs proposed by Paranjape et al . [53]
that is one of the most commonly used in practice, but our results
can be extended to other definitions of temporal motifs, e.g., the
1https://github.com/iliesarpe/ALDENTE.
2We will denote directed edges by â€œ (...)â€ and undirected edges by â€œ {...}â€.
3In practice priority bits are assigned to enforce a strict total ordering over ğ¸ğ‘‡.
 
2537Scalable Temporal Motif Densest Subnetwork Discovery KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
ones surveyed by Liu et al . [45] .4While we focus on unlabeled
networks, our approach can be also extended to labeled networks.
Definition 2.1 (Paranjape et al . [53] ).Ağ‘˜-vertexâ„“-edge temporal
motif withğ‘˜,â„“â‰¥2is a pairğ‘€=(ğ¾,ğœ), whereğ¾=(ğ‘‰ğ¾,ğ¸ğ¾)
is a directed and weakly-connected (multi-)graph, with |ğ‘‰ğ¾|=ğ‘˜,
|ğ¸ğ¾|=â„“, andğœis an ordering of the â„“edges inğ¸ğ¾.
Ağ‘˜-vertexâ„“-edge temporal motif is also identified by the se-
quenceâŸ¨(ğ‘¥1,ğ‘¦1),...,(ğ‘¥â„“,ğ‘¦â„“)âŸ©ofâ„“edges ofğ¸ğ¾ordered according to ğœ.
An illustration of a temporal motif is shown in Figure 1a.
Definition 2.2 ( ğ›¿-instance of a temporal motif). Given a tempo-
ral network ğ‘‡, a temporal motif ğ‘€, and a value ğ›¿âˆˆR+corre-
sponding to a time-interval length, a time-ordered sequenceğ‘†=
âŸ¨(ğ‘¥â€²
1,ğ‘¦â€²
1,ğ‘¡â€²
1),...,(ğ‘¥â€²
â„“,ğ‘¦â€²
â„“,ğ‘¡â€²
â„“)âŸ©ofâ„“unique temporal edges of ğ‘‡is a
ğ›¿-instance of the temporal motif ğ‘€=âŸ¨(ğ‘¥1,ğ‘¦1),...,(ğ‘¥â„“,ğ‘¦â„“)âŸ©if:
(1) there exists a bijection â„from the vertices appearing in ğ‘†to the
vertices ofğ‘€, withâ„(ğ‘¥â€²
ğ‘–)=ğ‘¥ğ‘–andâ„(ğ‘¦â€²
ğ‘–)=ğ‘¦ğ‘–, andğ‘–âˆˆ[â„“];
(2) the edges of ğ‘†occur within ğ›¿time; i.e.,ğ‘¡â€²
â„“âˆ’ğ‘¡â€²
1â‰¤ğ›¿.
The bijection implies that edges in ğ‘†are mapped onto edges in ğ‘€
in the same ordering ğœ. Additionally, a ğ›¿-instance is not required to
be vertex-induced. An example of Definition 2.2 is shown in Fig. 1b.
LetSğ‘‡={ğ‘†:ğ‘†is ağ›¿-instance of ğ‘€inğ‘‡}be the set ofğ›¿-instances
of a motifğ‘€for a given time-interval length ğ›¿. Computing the set
Sğ‘‡is extremely demanding, first such a set can have size O  ğ‘š
â„“,
and, in general even detecting a single ğ›¿-instance of a temporal
motif is an NP-hard problem [44].
We define a weighting function ğœ:Sğ‘‡â†¦â†’R+that assigns a
non-negative weight to each ğ›¿-instanceğ‘†âˆˆSğ‘‡based on its edges
and vertices, e.g., accounting for importance scores for vertices
and/or edges, or available metadata. Given ğ‘†=âŸ¨(ğ‘¥1,ğ‘¦1,ğ‘¡1),...,
(ğ‘¥â„“,ğ‘¦â„“,ğ‘¡â„“)âŸ©âˆˆSğ‘‡two possible realizations of weighting functions are:
(i) a constant functionğœğ‘:ğœğ‘(ğ‘†)=1, and
(ii) a decaying functionğœğ‘‘:ğœğ‘‘(ğ‘†)=1
â„“âˆ’1Ãâ„“
ğ‘—=2exp(âˆ’ğœ†(ğ‘¡ğ‘—âˆ’ğ‘¡ğ‘—âˆ’1)),
whereğœ†>0controls the time-exponential decay.
In the above, ğœğ‘is a simple weighting function where each ğ›¿-
instance receives a unitary weight, this can be used in most ex-
ploratory analyses where no prior information is known about
the network. The decaying function ğœğ‘‘is inspired from link-decay
models, where the value of ğœ†corresponds to the inverse of the
average inter-time distance of the timestamps in ğ¸ğ‘‡. Therefore, the
functionğœğ‘‘accounts for decaying processes over networks, which
are common in various domains, e.g., email communications, and
spreading of diseases [1, 2, 71].
As an example, considering the instance ğ‘†1from Fig. 1a, then
ğœğ‘(ğ‘†1)=1, while for ğœ†=0.1thenğœğ‘‘(ğ‘†1)=1
2(ğ‘’âˆ’3ğœ†+ğ‘’âˆ’6ğœ†)â‰ˆ0.64.
Givenğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğ‘‡)and a subset of vertices ğ‘ŠâŠ†ğ‘‰ğ‘‡, we denote
withğ‘‡[ğ‘Š]the temporal subnetwork induced byğ‘Šasğ‘‡[ğ‘Š]=
(ğ‘Š,ğ¸ğ‘‡[ğ‘Š]), whereğ¸ğ‘‡[ğ‘Š]={(ğ‘¢,ğ‘£,ğ‘¡):ğ‘¢âˆˆğ‘Š,ğ‘£âˆˆğ‘Š,(ğ‘¢,ğ‘£,ğ‘¡)âˆˆ
ğ¸ğ‘‡}is the set edges from ğ¸ğ‘‡among the vertices in ğ‘Š. Givenğ‘ŠâŠ†
ğ‘‰ğ‘‡, a temporal motif ğ‘€, andğ›¿âˆˆR+, for ease of notation, we
denote withSğ‘Šthe set of all ğ›¿-instances of ğ‘€inğ‘‡[ğ‘Š]. With
these definitions at hand we can now assign weights to the set
4By suitably replacing some of the subroutines of the algorithms in ALDENTE.ofğ›¿-instances of a temporal motif ğ‘€in a temporal subnetwork.
Finally, given ğ‘ŠâŠ†ğ‘‰ğ‘‡and a weighting function ğœwe define the
thetotal weight of the set of ğ›¿-instances of motif ğ‘€inğ‘‡[ğ‘Š]as
ğœ(ğ‘Š)=Ã
ğ‘†âˆˆSğ‘Šğœ(ğ‘†).
As an example, for ğ‘‡andğ‘€as in Fig. 1a, for ğ‘Š={ğ‘£1,ğ‘£2,ğ‘£3},
the constant weight function ğœğ‘, andğ›¿=20, we have ğœ(ğ‘Š)=4.
We are now ready to state the problem we address in this paper.
Problem 1 (Temporal Motif Densest Subnetwork (TMDS)).
Given a temporal network ğ‘‡=(ğ‘‰,ğ¸), a temporal motif ğ‘€, a time-
interval length ğ›¿âˆˆR+, and a weighting function ğœ:Sğ‘‡â†¦â†’R>0, find
a subset of vertices ğ‘Šâˆ—âŠ†ğ‘‰that maximizes the density function
ğœŒ(ğ‘Š)=ğœ(ğ‘Š)
|ğ‘Š|.
The TMDS problem takes in input a temporal motif ğ‘€, a weight-
ing function ğœ, and the time-interval length ğ›¿âˆˆR+. Differently
from existing works in the literature of temporal-networks we are
nottrying to find a time-window to maximize a static (or temporal)
density score. As an example, consider ğ‘‡andğ‘€from Fig. 1a, and
the TMDS problem with constant weighting function ğœğ‘. Fig. 1a
shows the solution obtained with ğ›¿=10, where the optimal solu-
tion isğ‘Šâˆ—={ğ‘£1,ğ‘£2,ğ‘£3,ğ‘£4,ğ‘£5}withğœŒ(ğ‘Šâˆ—)=ğœ(ğ‘Šâˆ—)/|ğ‘Šâˆ—|=6/5.
Note that the timestamps in ğ‘‡[ğ‘Šâˆ—]span an interval length greater
thanğ›¿(i.e.,[1,17]).
Throughout this paper we say that a vertex set ğ‘ŠâŠ†ğ‘‰achieves
anğ›¼-approximation ratio, with ğ›¼â‰¤1, ifğœŒ(ğ‘Š)/OPTâ‰¥ğ›¼, where
OPT=ğœŒ(ğ‘Šâˆ—)is the value of an optimal solution to Problem 1. An
algorithm that returns a solution with an ğ›¼-approximation ratio is
anğ›¼-approximation algorithm.
We conclude the preliminaries with defining the temporal motif
degree of vertexğ‘£âˆˆğ‘‰ğ‘‡byğ‘‘ğœ
ğ‘‰ğ‘‡(ğ‘£)=Ã
ğ‘†âˆˆSğ‘‰ğ‘‡(ğœ(ğ‘†) 1[ğ‘£âˆˆğ‘†]), where
1[ğ‘£âˆˆğ‘†]is an indicator function denoting if the vertex appears at
least once over the edges in the ğ›¿-instanceğ‘†. As an example, if we
considerğ‘‡andğ‘€as in Fig. 1a, ğœğ‘, andğ›¿=10, thenğ‘‘ğœ
ğ‘‰ğ‘‡(ğ‘£4)=2, as
ğ‘£4participates in two ğ›¿-instances of ğ‘€. All the missing proofs are
reported in our extended online version [64].
3 Related work
Densest subgraphs in static networks. Densest-subgraph dis-
covery (DSD) is a widely-studied problem asking to find a subset of
vertices that maximizes edge density [18,25,36,38]. Goldberg [26]
proposed a polynomial-time algorithm for computing the exact
solution using min-cut. Since min-cut algorithms are expensive,
such an algorithm is not practical for large networks. Charikar [12]
developed a faster greedy algorithm achieving a1
2-approximation
ratio. The idea is to iteratively remove the vertex with the smallest
degree, and return the vertex set that maximizes the edge density
over all vertex sets considered. Bahmani et al . [4]proposed methods
trading accuracy for efficiency, including a1
2(1+ğœ‰)-approximation
algorithm, controlled by a parameter ğœ‰>0.
Most related to TMDS are the problems of ğ‘˜-clique, orğ‘˜-motif
densest subgraphs [ 14,19,28,49,67,69,70,72]. Theğ‘˜-clique densest-
subgraph problem modifies the standard density definition by re-
placing edges with the number of ğ‘˜-cliques induced by a vertex
set. This problem is NP-hard. Tsourakakis [70] developed exact and
 
2538KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ilie Sarpe, Fabio Vandin, and Aristides Gionis
approximate algorithms (extending Goldbergâ€™s and Charikarâ€™s algo-
rithm, respectively) for the ğ‘˜-clique and triangle-densest subgraph
problem (ğ‘˜=3), further studied by Wang et al . [72] . High-order
core decomposition has been used to approximate the ğ‘˜-clique and
theğ‘˜-motif densest-subgraph problems, where density is defined
onğ‘˜-vertex subgraphs [ 19]. The techniques proposed by Fang et al .
[19] rely on exact enumeration of ğ‘˜-vertex subgraphs, which in the
case of temporal networks is impractical, especially on large data.
For theğ‘˜-clique densest-subgraph problem, Mitzenmacher et al .
[49] applied sparsification, which requires exhaustive enumeration
of allğ‘˜-cliques. Sun et al . [67] developed convex optimization-based
algorithms and a related sampling approach requiring a subrou-
tine that performs exact enumeration of ğ‘˜-cliques. For TMDS, we
cannot afford listing the set Sğ‘‡as such expensive procedure has
exponential computational cost in general. In our work, we develop
two randomized approximation algorithms that avoid exhaustive
enumeration ofSğ‘‡, significantly differing from existing approaches.
Densest-subgraph discovery in temporal networks. We do
not discuss methods for DSD on temporal networks defined over
snapshots of static graphs. Such a model is used for representing
more coarse-grained temporal data than the fine-grained model we
adopt, and it is less powerful [24, 31].
Several cohesive subgraph models have been studied [ 24], such
as, periodic densest subgraphs [ 57], bursty communities [ 58], dens-
est subgraphs across snapshots [ 65], correlated subgraphs [ 55],
and subgraphs with specific core properties [ 76]. Our work differs
significantly from all these definitions, as it is based on temporal
motifs. Several problems have been proposed to identify the time
frames maximizing specific density scores [ 59] and extensions of
core-numbers to the temporal scenario [ 22,40,50] or temporal
quasi-cliques [ 41]. Again, our problem strongly differs from all
these works (see our extended version [ 64] for more details). We
also note that, for brevity, we do not discuss algorithms for dy-
namic graphs, i.e., static graphs where edges are added or removed
over time. A large literature exists for this model [ 6,17,27], which,
however, differs significantly from the one we consider.
Algorithms for temporal motifs. We briefly discuss relevant
algorithms for finding temporal motifs, as per Def. 2.1. Paranjape
et al. [53] , who introduced such a definition, developed dynamic-
programming algorithms tailored to specific 3-edge and 2- or 3-
vertex temporal motifs. Subsequently, Mackey et al . [47] developed
a backtracking algorithm to enumerate all ğ›¿-instances of an arbi-
trary temporal motif; the complexity of such algorithm is O(ğ‘šâ„“),
i.e., exponential and not practical. Many other exact-counting algo-
rithms exist, usually tailored to specific classes of temporal motifs
such as triangles [ 54] or small motifs [ 11,23]. Since exact counting
is often impractical, many sampling-based algorithms have been
developed [ 44,56,62,63,73]. In our work, when needed, we will use
the state-of-the-art randomized algorithm by Sarpe and Vandin [63]
for estimating the motif count of an arbitrary temporal motif, which
provides(ğœ€,ğœ‚)-approximation guarantees, i.e., it offers an unbiased
estimate Ë†ğœ(ğ‘‰ğ‘‡)for which P[|Ë†ğœ(ğ‘‰ğ‘‡)âˆ’ğœ(ğ‘‰ğ‘‡)|â‰¤ğœ€ğœ(ğ‘‰ğ‘‡)]>1âˆ’ğœ‚
when the constant weighting function is considered, which we
extend to arbitrary non-negative weighting functions ğœ.Algorithm 1: ProbPeel
Input:ğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğ‘‡),ğ‘€,ğ›¿âˆˆR+,ğœ,ğœ‰>0,ğœ€>0,ğœ‚âˆˆ(0,1).
Output:ğ‘Š.
1ğ‘Š1â†ğ‘‰ğ‘‡;ğ‘–â†1;
2whileğ‘Šğ‘–â‰ âˆ…do
3ğ‘Ÿğ‘–â†GetBound(ğ‘Šğ‘–,ğœ€,ğœ‚/2ğ‘–);
4D={ğ‘‡1,...,ğ‘‡ğ‘Ÿğ‘–}â†Ağ‘Ÿğ‘–(ğ‘‡[ğ‘Šğ‘–]);
5 Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤1),..., Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤|ğ‘Šğ‘–|)â† GetEstimates(ğ‘Šğ‘–,D);
6 Ë†ğœ(ğ‘Šğ‘–)â† 1/ğ‘˜Ã
ğ‘¤âˆˆğ‘Šğ‘–Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤);
7ğ¿(ğ‘Šğ‘–)â†n
ğ‘¤âˆˆğ‘Šğ‘–:Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤)â‰¤ğ‘˜(1+ğœ‰)Ë†ğœ(ğ‘Šğ‘–)/|ğ‘Šğ‘–|o
;
8ğ‘Šğ‘–+1â†ğ‘Šğ‘–\ğ¿(ğ‘Šğ‘–);ğ‘–â†ğ‘–+1;
9returnğ‘Š=arg maxğ‘—=1,...,ğ‘–{Ë†ğœ(ğ‘Šğ‘—)/|ğ‘Šğ‘—|};
4 Randomized algorithms
We now introduce the novel randomized approximation algorithms
with tight probabilistic guarantees that we develop in ALDENTE.
The algorithms in ALDENTE will address the TMDS avoiding the
expensive exhaustive enumeration of the set Sğ‘‡, trough which the
TMDS problem can be solved (see discussion in Section 5).
4.1 ProbPeel
The main idea behind ProbPeel is to avoid exhaustive enumeration
ofSğ‘‡by using random sampling and peeling vertices in â€œbatchesâ€
according to an estimate of their temporal-motif degree. ProbPeel
carefully combines highly-accurate probabilistic (1 Â±ğœ€,ğœ€>0) esti-
mates of the temporal motif degrees of all vertices (that are obtained
by suitably leveraging existing algorithms for global temporal motif
estimation [ 63,73]), and peels vertices in batches at each step of
such a schema, similar non-approximate batch-peeling techniques
have been employed successfully in other settings [4, 17, 66].
We briefly introduce some definitions. Let ğ‘‡â€²=(ğ‘‰â€²,ğ¸â€²)âŠ†ğ‘‡=
(ğ‘‰ğ‘‡,ğ¸ğ‘‡), and recall thatSğ‘‡â€²={ğ‘†:ğ‘†is ağ›¿-instance of ğ‘€inğ‘‡â€²}is
the set ofğ›¿-instances fromSğ‘‡computed only on the subnetwork ğ‘‡â€²,
whereğ‘‡â€²isnotrequired to the subnetwork induced by ğ‘‰â€². For a
given vertex ğ‘£âˆˆğ‘‰ğ‘‡, extending our previous notation, let ğ‘‘ğœ
ğ‘‡â€²(ğ‘£)=Ã
ğ‘†âˆˆSğ‘‡â€²ğœ(ğ‘†)be the temporal motif degree of vertex ğ‘£in the sub-
networkğ‘‡â€². Clearly,Ã
ğ‘£âˆˆğ‘‰ğ‘‡ğ‘‘ğœ
ğ‘‡(ğ‘£)=ğ‘˜ğœ(ğ‘‰ğ‘‡).
We assume a sampling algorithm A, which outputs a sample
ğ‘‡â€²=(ğ‘‰â€²,ğ¸â€²)âŠ†ğ‘‡[ğ‘Š]of a subnetwork ğ‘‡[ğ‘Š]. Given a subnetwork
ğ‘‡[ğ‘Š]âŠ†ğ‘‡we will execute the sampling algorithm Ato obtain
ğ‘ŸâˆˆNi.i.d. subnetworks D={ğ‘‡1,...,ğ‘‡ğ‘Ÿ:ğ‘‡ğ‘–=A(ğ‘‡[ğ‘Š]) âŠ†
ğ‘‡[ğ‘Š],ğ‘–âˆˆ[ğ‘Ÿ]}. We use the subnetworks in Dto compute an un-
biased estimator Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤)of the temporal-motif degree for ğ‘¤âˆˆğ‘Š,
and for the correct choice of ğ‘Ÿit holds Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤)âˆˆ( 1Â±ğœ€)ğ‘‘ğœ
ğ‘Š(ğ‘¤), and
combine these estimates to obtain an estimator Ë†ğœ(ğ‘Š)âˆˆ( 1Â±ğœ€)ğœ(ğ‘Š).
A detailed description can be found in our extended version [64].
Algorithm description. We now present ProbPeel (Algorithm 1),
our probabilistic batch-peeling algorithm. The algorithm has three
parameters, ğœ€>0,ğœ‚âˆˆ(0,1)andğœ‰>0. The parameter ğœ€controls
the relative ğœ€-approximation ratio of Ë†ğœ(ğ‘Š)and Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤), andğœ‚con-
trols the failure probability of the algorithm, i.e., the guarantees
ofProbPeel hold with probability >1âˆ’ğœ‚. Last,ğœ‰>0controls
 
2539Scalable Temporal Motif Densest Subnetwork Discovery KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
the number of vertices to be peeled at each iteration, with higher
values ofğœ‰more vertices are peeled, so ProbPeel performs less
iterations, at the price of lower quality solutions (line 2).
First, ProbPeel instantiates the vertex set to be peeled (line 1).
Then it starts the main loop that ends when the vertex set ğ‘‰ğ‘‡be-
comes empty (line 2), and at each iteration ğ‘–>0it computes a
boundğ‘Ÿğ‘–ensuring that with ğ‘Ÿğ‘–it holds Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤)âˆˆ( 1Â±ğœ€)ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤)
with probability >1âˆ’ğœ‚/2ğ‘–simultaneously for eachğ‘¤âˆˆğ‘Šğ‘–, through
the function GetBound (line 3). It then samples ğ‘Ÿğ‘–subnetworks from
ğ‘‡[ğ‘Šğ‘–]using the sampling algorithm A, denoted byAğ‘Ÿğ‘–(ğ‘‡[ğ‘Šğ‘–]), the
samples are stored in D(line 4). Then it computes the estimates
Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤)for eachğ‘¤âˆˆğ‘Šğ‘–(line 5). The algorithm proceeds by peel-
ing vertices in batches according to a threshold that combines the
estimator Ë†ğœ(ğ‘Šğ‘–)(computed in line 6) and Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤),ğ‘¤âˆˆğ‘Šğ‘–andğœ‰>0
(line 7). ProbPeel then updates the vertex set and counter for the
next iteration (line 8). Finally, the algorithm returns the vertex set
maximizing the estimated objective function Ë†ğœ(ğ‘Šğ‘—)/|ğ‘Šğ‘—|over all
the iterations ğ‘—=1,...,O(log1+ğœ‰(ğ‘›))(line 9).
Building the estimator. We briefly describe how to compute
the estimates of the temporal motif degrees ğ‘‘ğœ
ğ‘Š(ğ‘¤)of vertices
ğ‘¤âˆˆğ‘Štrough the function GetEstimates . The general schema
we introduce captures many existing estimators, i.e., [ 44,63,72].
InvokingAon a subnetwork ğ‘‡[ğ‘Š],ğ‘ŠâŠ†ğ‘‰ğ‘‡, we get a sample ğ‘‡â€²=
(ğ‘‰â€²,ğ¸â€²)âŠ†ğ‘‡[ğ‘Š], therefore using such a sample ğ‘‡â€²we compute an
estimate of the degree ğ‘‘ğœ
ğ‘Š(ğ‘¤), for eachğ‘¤âˆˆğ‘Šas
Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤,ğ‘‡â€²)=âˆ‘ï¸
ğ‘†âˆˆSğ‘‡â€²:ğ‘¤âˆˆğ‘†ğœ(ğ‘†)/ğ‘ğ‘†, (1)
whereğ‘ğ‘†is the probability of observing ğ‘†âˆˆSğ‘‡â€²in the sampled
subnetwork ğ‘‡â€²=(ğ‘‰â€²,ğ¸â€²).
Lemma 4.1. For anyğ‘¤âˆˆğ‘Š, the count Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤,ğ‘‡â€²)computed on a
sampled subnetwork ğ‘‡â€²âŠ†ğ‘‡[ğ‘Š]is an unbiased estimate of ğ‘‘ğœ
ğ‘Š(ğ‘¤).
The final estimators Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤)forğ‘¤âˆˆğ‘Šare then computed as the
sample average over all the ğ‘Ÿsampled subnetworks (in line 4) of
Eq.(1), that is Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤)=1/ğ‘ŸÃğ‘Ÿ
ğ‘–=1Ë†ğ‘‘ğœ
ğ‘Š(ğ‘¤,ğ‘‡ğ‘–)for allğ‘¤âˆˆğ‘Š. Note also
that Ë†ğœ(ğ‘Š)(obtained in line 6) is an unbiased estimator of ğœ(ğ‘Š).
Bounding the sample size. Algorithm 1 can employ any unbiased
sampling algorithm A:ğ‘‡â†¦â†’2ğ‘‡as subroutine [ 44,63,72]. We used
PRESTO-A [63] for which the authors provide bounds on the number
of samplesğ‘Ÿfor event â€œ Ë†ğœ(ğ‘Šğ‘–)âˆˆ( 1Â±ğœ€)ğœ(ğ‘Šğ‘–)â€ to hold with arbitrary
probability >1âˆ’ğœ‚forğœ‚âˆˆ(0,1). In our function GetBound we need
a stronger result as we need (1Â±ğœ€)-approximation for alltemporal
motif degree of vertices ğ‘¤âˆˆğ‘Šğ‘–. Hence we bound individually,
for each vertex, the probability that Ë†ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤)âˆ‰(1Â±ğœ€)ğ‘‘ğœ
ğ‘Šğ‘–(ğ‘¤)and
combine such result with a union bound over all vertices.
Guarantees. The next result establishes the quality guarantees of
ProbPeel.
Theorem 4.2. With probability at least 1âˆ’ğœ‚,ProbPeel achieves
a(1âˆ’ğœ€)2
ğ‘˜(1+ğœ‰)(1+ğœ€)2-approximation ratio for the TMDS problem.
Note that if the parameter ğœ€is small (e.g., ğœ€â‰ˆ10âˆ’3), then ProbPeel
outputs a solution with approximation ratio close to1
ğ‘˜(1+ğœ‰).Time complexity. ProbPeel does not require an exhaustive enu-
meration of all ğ›¿-instances in the network ğ‘‡. In fact, it only es-
timates the temporal motif degrees of the vertices in ğ‘Šğ‘–at each
iterationğ‘–of the algorithm. The running time depends on the num-
ber of samples ğ‘Ÿğ‘–collected at each iteration and the time required
to process each sample, which is O(Ë†ğ‘šâ„“)where Ë†ğ‘šdenotes the max-
imum number of edges of ğ¸ğ‘‡in a time-window of length ğ›¿.
Thus, the time complexity is O
ğ‘Ÿmax
Ë†ğ‘šâ„“log1+ğœ‰(ğ‘›)+(1+ğœ‰)ğ‘›
ğœ‰
,
whereğ‘Ÿmax=maxğ‘–{ğ‘Ÿğ‘–}, which depends on ğœ€andğœ‚. Since the algo-
rithm does not require exhaustive enumeration of Sğ‘‡we expect
it to be particularly efficient. In addition, since we only store the
estimates of the various vertices at each iteration we expect also
the algorithm to be memory efficient.
4.2 HybridPeel
In this section we develop a novel probabilistic hybrid-peeling al-
gorithm, denoted by HybridPeel , which combines the randomized
batch-peeling technique of ProbPeel (to overcome full enumera-
tion ofSğ‘‡) with a more refined peeling approach that peels vertices
one at a time, to obtain higher quality solutions (as in [12]).
Algorithm description. The algorithm works as follows: (i) given
temporal network ğ‘‡=(ğ‘‰,ğ¸), it starts by removing nodes in a sim-
ilar fashion to ProbPeel . That is, at each iteration it computes a
(1Â±ğœ€)-approximation of the temporal motif degree of each vertex,
and vertices are removed in â€œbatchesâ€ according to a threshold
controlled by ğœ‰>0. Instead of iterating the process until the ver-
tex set becomes empty, the algorithm executes the randomized
peeling phase for a fixed number of iterations ğ½â‰¥1provided
in input. After such ğ½iterations, HybridPeel considers the ver-
tex setğ‘Šğ½+1and its induced temporal network ğ‘‡[ğ‘Šğ½+1]. Then
it enumerates all temporal motifs on ğ‘‡[ğ‘Šğ½+1](computingSğ‘Šğ½+1)
and peelsğ‘Šğ½+1one vertex at a time according to the minimum
temporal motif degree, storing the vertex set maximizing the ob-
jective function ğœŒ(Â·), among the ones observed. Hence, this second
procedure returns a vertex set ğ‘Šâ€²maximizing ğœŒ(Â·)among the
O(|ğ‘Šğ½+1|âˆ’ğ‘˜)vertex sets explored, and HybridPeel then returns
ğ‘Š=arg max{Ë†ğœ(ğ‘Š1)/|ğ‘Š1|,..., Ë†ğœ(ğ‘Šğ½)/|ğ‘Šğ½|,ğœ(ğ‘Šâ€²)/|ğ‘Šâ€²|}. A detailed
description of HybridPeel is given in our extended version [64].
The design of HybridPeel is motivated by a drawback of Prob-
Peel : even for very accurate estimates of temporal motif degrees
it may provide a sub-optimal solution to TMDS, since even for ğœ€
close to 0, ProbPeel only converges to the approximation ratio of
1
ğ‘˜(1+ğœ‰), while the peeling procedure we apply on ğ‘Šğ½+1provides
denser solutions (close to 1/ğ‘˜). The intuition behind HybridPeel is
that, the first ğ½iterations are used to prune the network sufficiently,
for the algorithm to maintain in ğ‘Šğ½+1a dense subnetwork ğ‘Šâ€²âŠ†
ğ‘Šğ½+1attaining at least a 1/ğ‘˜-approximation ratio. Therefore: (i) the
algorithm is scalable, as it avoids the computation of Sğ‘‡, and (ii) is
expected to output high-quality solutions.
Next we show the approximation ratio of HybridPeel.
Theorem 4.3. With probability at least 1âˆ’ğœ‚,HybridPeel is a
(1âˆ’ğœ€)2
ğ‘˜(1+ğœ‰)(1+ğœ€)2-approximation algorithm for the TMDS problem when
ğ½>1, while forğ½=1it achieves a(1âˆ’ğœ€)2
ğ‘˜(1+ğœ‰)(1+ğœ€)-approximation ratio.
 
2540KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ilie Sarpe, Fabio Vandin, and Aristides Gionis
Time complexity. The time complexity of the algorithm can be
bounded byO(ğ‘…ğ‘‡ProbPeelâˆ’ğ½(ğ‘‡)+ğ‘…ğ‘‡Greedy(ğ‘‡[ğ‘Šğ½+1])), i.e., the
sum of the runtime ( ğ‘…ğ‘‡) of executing ProbPeel forğ½iterations, and
then the peeling procedure that we denote with Greedy onğ‘‡[ğ‘Šğ½+1].
A detailed analysis is reported in our extended manuscript [ 64]. By
noting that there exists a value ğ›¾>1such that|ğ‘Šğ½+1|=O(ğ‘›1/ğ›¾)
the complexity is bounded by O(ğ½ğ‘ŸmaxË†ğ‘šâ„“+ğ›¾âˆ’1ğ‘˜3ğ‘›ğ‘˜/ğ›¾log(ğ‘›)). This
highlights that first peeling the network with the randomized batch
peeling technique enables HybridPeel to work on a significantly
small network, over which to execute a more refined peeling algo-
rithm, affording an exact enumeration of temporal motif instances
onğ‘‡[ğ‘Šğ½+1], leading to an overall scalable and practical algorithm.
5 Temporal information impact and baselines
A natural question is if the temporal information in the temporal
networkğ‘‡is necessary, or if the directed static network associated
toğ‘‡already captures the TMDS problem formulation. Given a
temporal network ğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğ‘‡)theassociated static network of
ğ‘‡isğºğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğº), whereğ¸ğº={{ğ‘¢,ğ‘£}|there exists(ğ‘¢,ğ‘£,ğ‘¡)âˆˆ
ğ¸ğ‘‡or(ğ‘£,ğ‘¢,ğ‘¡)âˆˆğ¸ğ‘‡}. If we keep the edge directions, a static directed
network is denoted by ğ·ğ‘‡.5For a subset of vertices ğ‘ŠâŠ†ğ‘‰we
denote byğºğ‘‡[ğ‘Š]its associated static network.
We first show that even for a very simple temporal motif, the
optimal solution on ğ·ğ‘‡can be arbitrarily bad when evaluated on
the temporal network ğ‘‡. This highlights that Problem 1 cannot be
addressed by existing algorithms for ğ‘˜-MDS on static networks
or aggregations of the input temporal network (i.e., disregarding
temporal information). We then show how to embed temporal
information in a weighted set of subgraphs to solve the TMDS
problem, to obtain our baselines. Computing such a set requires
full enumeration of temporal motif instances on ğ‘‡, which we recall
to be extremely demanding, especially on large temporal networks.
Temporal vs. static. We start by some definitions. For a tem-
poral motif ğ‘€=(ğ¾,ğœ), we useğº[ğ‘€]to denote the undirected
graph associated to ğ¾, i.e.,ğº[ğ‘€]=(ğ‘‰ğ¾,{{ğ‘¢,ğ‘£}:there exists(ğ‘¢,ğ‘£)
or(ğ‘£,ğ‘¢)inğ¸ğ¾}), ignoring directions and multiple edges in ğ¾. We
say that a temporal motif ğ‘€is a2-path ifğ‘€=âŸ¨(ğ‘¢,ğ‘£),(ğ‘£,ğ‘¤)âŸ©, with
ğ‘¢â‰ ğ‘£â‰ ğ‘¤. Given a directed static graph ğ·ğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğ·)we define
the number of static 2-paths (i.e., directed paths of length 2) induced
by a subset of vertices ğ»âŠ†ğ‘‰ğ‘‡as|ğ‘ƒ2(ğ»)|. Therefore, a static ver-
sion of the TMDS problem on temporal networks with ğ‘€being a
2-path, is to consider the aggregated network of ğ‘‡(i.e.,ğ·ğ‘‡) with
the goal of identifying ğ»âˆ—âŠ†ğ‘‰ğ‘‡maximizing ğœŒ2(ğ»)=|ğ‘ƒ2(ğ»)|
|ğ»|. We
refer to this problem as S2DS (Static 2-path Densest Subnetwork).
We can show that an optimal solution to S2DS, computed on ğ·ğ‘‡,
the static network associated to ğ‘‡, can be arbitrarily bad when
evaluated for TMDS on ğ‘‡withğ‘€being a 2-path. Without loss of
generality, we assume the constant weighting function ğœğ‘.
Lemma 5.1. Given a temporal network ğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğ‘‡), and its as-
sociated directed network ğ·ğ‘‡, letğ»âˆ—be a solution to S2DS on ğ·ğ‘‡.
Letğ‘Šâˆ—onğ‘‡be the optimal solution of TMDS, for a 2-path motif,
with fixedğ›¿â‰¥1. Then there exists a temporal network ğ‘‡such that
5The static network of a temporal network ğ‘‡simply ignores the timestamps of ğ‘‡,
collapsing multiple temporal edges on the same static edge.ğœŒ(ğ»âˆ—)=0whileğœŒ(ğ‘Šâˆ—)=O(ğ‘›2). Furthermore, the two solution
setsğ»âˆ—andğ‘Šâˆ—are disjoint.
Embedding temporal information. Since we cannot simply dis-
regard temporal information, we investigate how to compute a
suitable weighted set of static subgraphs embedding temporal in-
formation. Such a set can be used to solve the TMDS problem by
leveraging existing techniques. Given the input to TMDS, we define
H={ğ»:ğ»=(ğ‘‰ğ»,ğ¸ğ») âŠ†ğºğ‘‡,for someğ»â€²âŠ†ğ»it holdsğ»â€²âˆ¼
ğº[ğ‘€], ğœ(ğ‘‰ğ»)>0,and|ğ‘‰ğ»|=ğ‘˜}be the set of ğ‘˜-connected in-
duced subgraphs ( ğ‘˜-CISs) from ğºğ‘‡,6where each ğ‘˜-CIS,ğ»âˆˆH ,
encodes a subgraph containing at least a ğ›¿-instanceğ‘†âˆˆSğ‘‡with
ğœ(ğ‘†)>0, andğ»is induced in ğºğ‘‡, i.e., has all the edges among
the vertices ğ‘‰ğ». The above conditions are ensured by requiring
the existence of ğ»â€²âŠ†ğ»such thatğ»â€²âˆ¼ğº[ğ‘€]andğœ(ğ‘‰ğ»)>0,
whereğº[ğ‘€]is the undirected graph associated to the temporal
motifğ‘€. For example, considering the motif ğ‘€, and the temporal
networkğ‘‡from Fig. 1, and ğ›¿=10, then the corresponding set
HisH={(ğ»1=ğºğ‘‡[{ğ‘£1,ğ‘£2,ğ‘£3}], ğ»2=ğºğ‘‡[{ğ‘£2,ğ‘£3,ğ‘£4}], ğ»3=
ğºğ‘‡[{ğ‘£1,ğ‘£3,ğ‘£5}], ğ»4=ğºğ‘‡[{ğ‘£3,ğ‘£4,ğ‘£5}]}.
Next, we need to define the weight of each subgraph ğ»=(ğ‘‰ğ»,ğ¸ğ»)
inH. This is done by ğœ(ğ‘‰ğ»)=Ã
ğ‘†âˆˆSğ‘‰ğ»ğœ(ğ‘†), i.e., the weight
of the subgraph ğ»is the sum of the weights of the ğ›¿-instances
that occur among the nodes of ğ‘‰ğ»inğ‘‡. As an example, consider
ğ»1=(ğ‘‰ğ»1={ğ‘£1,ğ‘£2,ğ‘£3},{{ğ‘£1,ğ‘£2},{ğ‘£2,ğ‘£3},{ğ‘£3,ğ‘£1}}) âˆˆH from
Fig. 1, then ğœ(ğ‘‰ğ»1)=2under weight ğœğ‘, andğ›¿=10, as there are
twoğ›¿-instances among such nodes. Note that such a construction
is in accordance with Lemma 5.1, as to build, and weight the set
Hwe are exploiting full information about the temporal motif
ğ›¿-instances of ğ‘€inğ‘‡. In Section 6.1 we provide a summary on how
to leverage the set Hto adapt existing techniques for high-order
subgraph discovery to solve TMDS, while a detailed description can
be found in our extended version [ 64]. Such algorithms will be used
as baselines for comparison against ALDENTE in our experimental
evaluation. All resulting baselines, and the algorithms in ALDENTE
that we developed are finally summarized in Table 1.
6 Experimental evaluation
In this section we evaluate the algorithms in ALDENTE against the
baselines. We describe the experimental setup in Section 6.2, and
we compare the solution quality, and runtime of all the algorithms
in Section 6.3. Finally, in Section 6.4 we conduct a case study on a
real-world transaction network from the Venmo platform to sup-
port the usefulness of solving the TMDS problem. In our extended
version [ 64] we report results on parameter sensitivity, memory
usage, and results under decaying weighting function ğœğ‘‘.
6.1 Baseline overview
We give a brief, description of our baselines, that leverage the
construction of the set H(as from Section 5) and that are based on
known ideas in the field, see [64] for more details.
Exact : Exact algorithm embedding the set His a properly weighted
flow network, adapting ideas from [ 19,26,49]. It computes multiple
min-cut solutions on the flow network, the algorithm identifies an
optimal solution to the TMDS problem.
6Symbol â€œâˆ¼â€ denotes standard graph isomorphism.
 
2541Scalable Temporal Motif Densest Subnetwork Discovery KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
Table 1: Baselines and algorithms in ALDENTE. For each algorithm we report: its name, the approximation ratio, its parameters,
the guaranteed probability (â€œ1â€ means deterministic), â€œAvoid Enum.â€: if it avoids computing the set H(and thereforeSğ‘‡), and its
time complexity. The first three algorithms are baselines, while the latter two algorithms are part of ALDENTE (see Section 4).
Name
Approximation Parameters Probability Avoid Enum. Time Complexity
Exact 1
- 1 âœ—O
ğ‘šË†ğ‘šâ„“âˆ’1+ğ‘˜ğ‘›2ğ‘˜log(ğ‘›ğœ(ğ‘‰))
Greedy1
ğ‘˜-
1 âœ—O
ğ‘šË†ğ‘š(â„“âˆ’1)+ğ‘˜3ğ‘›ğ‘˜log(ğ‘›)
Batch1
ğ‘˜(1+ğœ‰)ğœ‰>0 1 âœ—O
ğ‘šË†ğ‘š(â„“âˆ’1)+ğ‘˜3ğ‘›ğ‘˜log(ğ‘›)
ProbPeel(1âˆ’ğœ€)2
ğ‘˜(1+ğœ‰)
(1+ğœ€)2ğœ‰>0,ğœ€,ğœ‚âˆˆ(0,1) >1âˆ’ğœ‚ âœ“O
ğ‘Ÿ(ğœ€,ğœ‚)
Ë†ğ‘šâ„“log1+ğœ‰(ğ‘›)+(1+ğœ‰)ğ‘›
ğœ‰

HybridPeel(1âˆ’ğœ€)2
ğ‘˜(1+ğœ‰)
(1+ğœ€)2ğœ‰>0,ğœ€,ğœ‚âˆˆ(0,1),ğ½>0 >1âˆ’ğœ‚ âœ“O
ğ½ğ‘Ÿ(ğœ€,ğœ‚)Ë†ğ‘šâ„“+ğ›¾âˆ’1ğ‘˜3ğ‘›ğ‘˜/ğ›¾log(ğ‘›)
Table 2: Networks used in our experiments. ğ‘›: vertices,ğ‘š:
temporal edges,|ğ¸ğº|: edges in the undirected static network,
time-interval length ğ›¿: value used for counting ğ›¿-instances.
Netw
ork ğ‘› ğ‘š|ğ¸ğº|Precision Timespan ğ›¿Me
diumSms
44 K 545 K 52 K sec 338 (days) 172.8 K
Facebook 45.8 K 856 K 183 K sec 1561 (days) 86.4 K
Askubuntu 157 K 727 K 455 K sec 2614 (days) 172.8 K
Wikitalk 1 100 K 6 100 K 2 800 K sec 2277 (days) 43.2 KLargeStacko
verflow 2.6 M 47.9 M 28.1 M sec 2774 (days) 172.8 K
Bitcoin 48.1 M 113 M 84.3 M sec 2585 (days) 7.2 K
Reddit 8.4 M 636 M 435.3 M sec 3687 (days) 14.4 K
EquinixChicago 11.2 M 2 300 M 66.8 M ğœ‡-sec 62.0 (mins) 50 K
V
enmo 19.1 K 131 K 18.5 K sec 2091 (days) -
Greedy : A1/ğ‘˜-approximation greedy algorithm that extend the
ideas in [ 12,19]. The algorithm performs O(ğ‘›âˆ’ğ‘˜)iterations where
at each iteration a vertex with minimum temporal motif degree
is removed and the set His updated accordingly. The algorithm
returns the vertex set with maximum density observed.
Batch : A1/(ğ‘˜(1+ğœ‰)),ğœ‰>0greedy approximation algorithm
extending ideas from [ 4,17,69]. At each step the algorithm removes
vertices with small temporal motif degree in â€œbatchesâ€ and updates
the setHreturning the maximum density vertex set observed, the
overall number of iterations is bounded by O(logğ‘›/ğœ‰).
All such baselines require the computation of the set H, and
thereforeSğ‘‡.7Unfortunately, this is extremely inefficient and does
not scale on large data, as we will show next.
6.2 Setup
Implementation details and hardware. All the algorithms are
implemented in C++20 and compiled under Ubuntu 20.04 with gcc
9.4.0 with optimization flags. The experiments are executed sequen-
tially on a 72-core Intel Xeon Gold 5520 @2.2 GHz machine with
1008 GB of RAM memory available. For Exact , we use the algo-
rithm by Boykov and Kolmogorov [9]to compute the(ğ‘ ,ğ‘§)-min cut
on the flow network. For the implementation of the min-heap we
use the data structures provided by the Boost library.8We use the
algorithm of Mackey et al . [47] for exact enumeration of temporal
motifğ›¿-instances. We use PRESTO-A [63], as sampling algorithm
inProbPeel andHybridPeel . At each iteration of ProbPeel (and
HybridPeel ) we setğ‘Ÿğ‘–=ğ‘Ÿ, (i.e., a fixed value for all iterations)
7This holds for most of other existing techniques even based on sampling, see Section 3.
8https://www.boost.org/
M1
M2M3
M4M5
M6M7M8
M9M10ğ‘¡1 ğ‘¡2
ğ‘¡1 ğ‘¡2 ğ‘¡3ğ‘¡1
ğ‘¡2 ğ‘¡3ğ‘¡1
ğ‘¡2
ğ‘¡3ğ‘¡4ğ‘¡1
ğ‘¡2
ğ‘¡3ğ‘¡4
ğ‘¡1, ğ‘¡2
ğ‘¡3, ğ‘¡4ğ‘¡1
ğ‘¡2ğ‘¡3ğ‘¡4
ğ‘¡5ğ‘¡1ğ‘¡2
ğ‘¡3
ğ‘¡4ğ‘¡5ğ‘¡1
ğ‘¡2
ğ‘¡3ğ‘¡4
ğ‘¡5
ğ‘¡6ğ‘¡1
ğ‘¡2ğ‘¡3
ğ‘¡4ğ‘¡5
ğ‘¡6Figure 2: Temporal motifs (M ğ‘–,ğ‘–âˆˆ[10]) used in the exper-
imental evaluation. Motifs with blue vertices are not used
on EquinixChicago since this network is bipartite. For each
motifğ‘¡ğ‘–,ğ‘–=1,...denotes the ordering of its edges in ğœ.
and we set this parameter accordingly for each dataset; we dis-
cuss the sensitivity of the solution to parameter ğ‘Ÿin our extended
version [ 64]. We consider as weighting function ğœthe constant
functionğœğ‘. Our code is available online.9
Datasets and time-interval length. The datasets considered in
this work span medium and large sizes and are reported in Table 2.
For each dataset we set ğ›¿to be some multiple of the respecting
time unit (e.g., for datasets with precision in seconds setting ğ›¿=
7.2K corresponds to two hours). We also select a value of ğ›¿that is
consistent with previous studies and application scenarios [42, 46,
53,54], and large enough to be computationally challenging. More
details on each dataset are reported in [64].
Temporal motifs. The temporal motifs we use are good represen-
tative of a general input to TMDS in most applications, and are
reported in Fig. 2. They represent different topologies, e.g., trian-
gles, squares and more complicated patterns, spanning different
values ofğ‘˜andâ„“, and the largest temporal motifs correspond to
particularly challenging inputs.
6.3 Solution quality and runtime
We now compare the runtime and quality of the solution reported by
the algorithms in ALDENTE (ProbPeel , and HybridPeel ) against
the baselines (Exact, Greedy, and Batch).
9https://github.com/iliesarpe/ALDENTE.
 
2542KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ilie Sarpe, Fabio Vandin, and Aristides Gionis
M1M2M3M4M5M6M7M8M9M100.00.51.0
Stackoverflow =172800
r=4000
r=4000
M1M2M3M4M5M6M7M8M9M100.00.51.0
Bitcoin =7200
r=30000
r=30000
M1M2M3M4M5M6M7M8M9M100.00.51.0
Reddit =14400
r=20000
r=20000
M1M2M4M5M6M90.00.51.0
EquinixChicago =50000
r=1000
r=1000
T emporal Motif(W)/|W|
OPT
Exact Greedy Batch =0.3
 ProbPeel =0.3
 HybridPeel =0.3
M1M2M3M4M5M6M7M8M9M1025005000750010000Stackoverflow =172800
r=4000
r=4000
M1M2M3M4M5M6M7M8M9M1025005000750010000Bitcoin =7200
r=30000
r=30000
M1M2M3M4M5M6M7M8M9M1025005000750010000Reddit =14400
r=20000
r=20000
M1M2M4M5M6M925005000750010000EquinixChicago =50000
r=1000
r=1000
T emporal MotifAverage Runtime (sec)Exact Greedy Batch =0.3
 ProbPeel =0.3
 HybridPeel =0.3
Figure 3: For each configuration we report (top): the quality of the solution compared to the best empirical solution (i.e., Ë†OPT),
and (bottom): the average running times to achieve such solution.
Setup and metrics. For each configuration (dataset, motif, value
ofğ›¿) we run each algorithm five times with a time limit of three
hours and maximum RAM of 150 GB on all datasets but Equinix-
Chicago, on which we set the memory limit to 200 GB. For each
algorithm we compute the average running time over the five runs.
To assess the quality of the solution of the randomized algorithms,
we compute the actual value of the solution in the original temporal
network on the returned vertex set. For each configuration over
all the algorithms that terminate we compute Ë†OPT,10i.e., the best
empirical solution obtained across all algorithms, and we use this
value as reference for comparison of the different algorithms. For all
the deterministic algorithms we show the approximation factor as
ğœ(ğ‘Š)/|ğ‘Š|
Ë†OPT, whereğ‘Šis the solution returned by a given algorithm;
forProbPeel andHybridPeel we show the average approximation
factor over the five runs, and we also report the standard deviation.
We setğœ‰=0.3forBatch over all experiments we performed, as
it provides sufficiently good solutions in most cases (see App. C.2
for a detailed empirical evaluation of such parameter), and use the
same values of ğœ‰forProbPeel andHybridPeel . For HybridPeel
we setğ½=3on large datasets, and ğ½=2otherwise. When an
algorithm does not terminate within the time limit we set its time
to three hours, and its approximation factor to 0. Since our focus is
on scalability we place particular emphasis on large datasets, so we
defer results on medium-size datasets to our extended version [ 64]
as they follow similar trends to the ones we will discuss. We also
discuss results concerning memory usage in App. C.1.
Results. The results are reported in Fig. 3. Concerning the run-
time, we observe different trends on the various datasets. First on
Stackoverflow, most of the motifs require a small runtime, of few
hundreds of seconds, to be counted (even by Exact ), and on such
motifs most algorithms achieve a comparable runtime. While on
some hard motifs, our proposed randomized algorithms achieve a
significant speed-up of more than Ã—4and up toÃ—9over the baselines
10Such value is guaranteed to be the actual optimum OPT only when Exact terminates.(e.g., on motifs M1andM2). On Bitcoin we observe that the runtime
for counting most motifs is prohibitive, and Exact is not able to
complete the execution on any motif on such dataset. Remarkably,
our proposed randomized algorithms achieve a consistent speed-up
of at leastÃ—3up toÃ—8over Greedy andBatch , and more impor-
tantly our algorithms are able to complete their execution even
when the baselines do not scale their computation (e.g., motifs M1
andM2). The scalability aspect becomes more clear on the biggest
datasets that we considered, in fact on Reddit, despite of being con-
sistently more efficient than the baselines, our HybridPeel is the
only one that is able to complete its execution on M10over all tech-
niques considered. Finally, on EquinixChicago (with more than two
billions of temporal edges), our randomized algorithms ( ProbPeel
andHybridPeel ) are the only ones that terminate their execution
in a small amount of time. We observe that ProbPeel is signifi-
cantly more efficient than HybridPeel , at the expense of a slightly
less accurate solution, which we will discuss next. On some of the
configurations all algorithms do not terminate, this is because some
of the motifs are extremely challenging, therefore the timelimit
we set is too strict as a constraint even for randomized algorithms.
Overall these experiments suggest that our randomized algorithms
successfully enable the discovery of temporal motif densest sub-
networks on large temporal networks. This closely matches our
theoretical insights, capturing the superior efficiency and scalability
of our randomized algorithms against baselines.
Concerning the solution quality we observe similar trends on
most datasets. Batch provides solutions with smaller density than
Greedy , and ProbPeel closely matches Batch â€™s results (as captured
by our analysis). Greedy is the deterministic approximation algo-
rithm that mostly often provides the solution with highest density
when it terminates, and our HybridPeel closely matches such re-
sults, so our HybridPeel results accurate, scalable and efficient (as
it is consistently faster than Greedy ). Interestingly on the Equinix-
Chicago dataset, where only our proposed randomized algorithms
are able to terminate in less than three hours ( ProbPeel takes few
 
2543Scalable Temporal Motif Densest Subnetwork Discovery KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
hundreds of seconds), the difference in the quality of the solutions
provided by ProbPeel andHybridPeel is not significantly large,
suggesting that on massive data ProbPeel may be a good candidate
to obtain high-quality solutions in a very short amount of time.
Summary. To summarize, our experiments show that techniques
based on existing ideas do not scale on challenging motifs and
large datasets for TMDS. In contrast, our proposed algorithms in
ALDENTE provide high-quality solutions in a short amount of time
and scale their computation on large datasets, enabling the practical
discovery of temporal motif dense subnetworks.
6.4 Case study
Recently, Liu et al . [43] released a dataset containing a small number
of transactions from the Venmo money-transfer platform, where
each transaction is accompanied by a message. The corresponding
temporal network ğ‘‡=(ğ‘‰ğ‘‡,ğ¸ğ‘‡)is as follows: each temporal edge
is a tuple(ğ‘¢,ğ‘£,ğ‘¡,ğœ™,ğ›¾)âˆˆğ¸ğ‘‡where(ğ‘¢,ğ‘£,ğ‘¡)is the temporal edge as
considered up to now and ğœ™,ğ›¾are metadata: ğœ™âˆˆ{0,1}denotes
if(ğ‘¢,ğ‘£)are friends in the social network and ğ›¾is a text message.
Since the dataset is very small (see Table 2), we computed exact
solutions to Problem 1. We investigated the following question.
Q: What insights about the Venmo platform are captured by
optimal solutions to the TMDS problem according to a temporal
motifğ‘€, and what subnetworks are captured by varying ğ›¿âˆˆR+?
To answer Qwe select motif M5in Fig. 2, a temporal star with
four temporal edges, corresponding to finding groups of users (i.e.,
the vertex at the center of M5) sending many transactions to their
neighbors (i.e., the vertices with no out-edges in M5) in a time-
scale controlled by ğ›¿âˆˆR+. In addition to M5, we provide as input
to TMDS the constant weighting function ğœğ‘andğ›¿1=7 200 (i.e.,
2-hours), to capture short-time scale patterns.
The optimal solution ğ‘‡[ğ‘Šâˆ—
ğ›¿1]has 14 vertices, and we report its
directed static network and its temporal support in Fig. 4 (Left).
Interestingly, this is a star shaped network, with only the central
vertex (ğ‘£1) exchanging money with all the other vertices (not re-
ciprocated), and vertices are not friends. The message associated
to each transaction is identical for all transactions: â€œSorry! Weâ€™re
already sold out for tonight! Feel free to join us this even in the reg-
ular line and pay cover when you get there. Thanks!â€. Even more
interestingly, all events occur really close in time (see Fig. 4 (Left)).
In fact, this corresponds to a bursty event with merchant ğ‘£1over-
booking for a specific event, which is identified by the combination
ofM5and smallğ›¿âˆˆR+. We also observe that such a subnetwork
cannot be captured by the existing formulations for dense temporal
subnetworks (see Section 3) as both ğ‘‡[ğ‘Šâˆ—
ğ›¿1]and its directed static
network have very small edge-density, i.e., 13/14 <1.
We then consider M5but analyze a much larger time-scale, that is
we solve TMDS with ğ›¿2=172 800. Under this settings of parameters
we expect the optimal solution to contain instances of M5with
a longer duration (accounting for more historical user activities).
The optimal subnetwork has 16 vertices and it is shown again in
Fig. 4 (Right). As expected the temporal support of such subnetwork
is significantly long (spanning from Oct. 2018 to Feb. 2021). The
messages over the transactions of such subnetwork are usually
related to food, theatre and social activities, denoting that users
share similar interests. But we also identify transactions that are
v1v2v3v4 v5
v6
v7
v8
v9
v10
v11v12v13v14
2015-05-21 2018-04-01 2021-02-09
Time
v1
v2
v3v4
v5v6v7
v8
v9v10
v11v12
v13v14
v15v16
2015-05-21 2018-04-01 2021-02-09
Time
24681012
T emporal edgesFigure 4: Directed static network of ğ‘‡[ğ‘Šâˆ—
ğ›¿]according to dif-
ferent values of ğ›¿onM5, we color edges according to the
number temporal edges that map on each static edge. Below
each static network we report the temporal support of ğ‘‡[ğ‘Šâˆ—
ğ›¿],
i.e., we place a bar in correspondence of the timings of the
events inğ‘‡[ğ‘Šâˆ—
ğ›¿]over the timespan of observation of the net-
work. (Left): ğ›¿1=7 200. (Right): ğ›¿2=172 800.
likely related to sport gambling. Such suspicious transactions report
terms such as â€œbracket seasonâ€ or emojis of basketballs (in fact,
M5captures such patterns as once a user loses a gamble with its
friends, it usually sends the money using a pattern similar to M5).11
Our findings also support the insights by Liu et al . [43] , who use
temporal motifs to identify poker gamblers on Venmo.
In summary, by solving the TMDS problem for temporal mo-
tifs of interest and different values of the time-window ğ›¿we can
gain precious insights on the network being analyzed not captured
otherwise by previous formulations.
7 Conclusions
We introduced a new problem, requiring to identify the temporal
motif densest subnetwork (TMDS) of a large temporal network. We
developed two novel algorithms based on randomized sampling,
for which we proved a probabilistic approximation ratio and show
experimentally that they are efficient and scalable over large data.
The techniques developed in this work may be useful in other prob-
lems, such as the ğ‘˜-clique problem [ 19,49,69] given the availability
of many sampling algorithms with tight guarantees for estimating
ğ‘˜-clique counts [10, 33].
There are many possible directions for future work, such as
improving the theoretical guarantees offered by our randomized
algorithm through motif-dependent approximation ratios, and un-
derstanding if randomization can be coupled with recent ideas in the
field of densest-subgraph discovery, such as techniques in [8, 13].
Acknowledgments
We thank Matteo Ceccarello for helpful comments on an earlier
version of the current work. This work is supported, in part, by
MUR of Italy, under project PRIN n. 2022TS4Y3N â€œEXPAND: scal-
able algorithms for EXPloratory Analyses of heterogeneous and
dynamic Networked Data", and project â€œNational Centre for HPC,
Big Data and Quantum Computingâ€ (CN00000013). This work is
also supported by the ERC Advanced Grant REBOUND (834862), the
EC H2020 RIA project SoBigData++ (871042), and the Wallenberg
AI, Autonomous Systems and Software Program (WASP) funded
by the Knut and Alice Wallenberg Foundation.
11Further details are discussed in Appendix C.3.
 
2544KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ilie Sarpe, Fabio Vandin, and Aristides Gionis
References
[1]Walid Ahmad, Mason A. Porter, and Mariano Beguerisse-Diaz. 2021. Tie-Decay
Networks in Continuous Time and Eigenvector-Based Centralities. TNSE.
[2]Nesreen K. Ahmed, Nick Duffield, and Ryan A. Rossi. 2021. Online Sampling of
Temporal Networks. TKDD.
[3]Naomi A. Arnold, Peijie Zhong, Cheick Tidiane Ba, Ben Steer, Raul Mondragon,
Felix Cuadrado, Renaud Lambiotte, and Richard G. Clegg. 2024. Insights and
caveats from mining local and global temporal motifs in cryptocurrency transac-
tion networks. arXiv.
[4]Bahman Bahmani, Ravi Kumar, and Sergei Vassilvitskii. 2012. Densest Subgraph
in Streaming and MapReduce. PVLDB.
[5]Caleb Belth, Xinyi Zheng, and Danai Koutra. 2020. Mining Persistent Activity in
Continually Evolving Networks. KDD.
[6]Sayan Bhattacharya, Monika Henzinger, Danupon Nanongkai, and Charalampos
Tsourakakis. 2015. Space- and Time-Efficient Algorithm for Maintaining Dense
Subgraphs on One-Pass Dynamic Streams. STOC.
[7]Vladimir Boginski, Sergiy Butenko, and Panos M. Pardalos. 2003. On Structural
Properties of the Market Graph. Innovations in Financial and Economic Networks.
[8]Digvijay Boob, Yu Gao, Richard Peng, Saurabh Sawlani, Charalampos Tsourakakis,
Di Wang, and Junxing Wang. 2020. Flowless: Extracting Densest Subgraphs
Without Flow Computations. WWW.
[9]Y. Boykov and V. Kolmogorov. 2004. An experimental comparison of min-cut/max-
flow algorithms for energy minimization in vision. TPAMI.
[10] Marco Bressan, Stefano Leucci, and Alessandro Panconesi. 2021. Faster Motif
Counting via Succinct Color Coding and Adaptive Sampling. TKDD.
[11] Xinwei Cai, Xiangyu Ke, Kai Wang, Lu Chen, Tianming Zhang, Qing Liu, and
Yunjun Gao. 2023. Efficient Temporal Butterfly Counting and Enumeration on
Temporal Bipartite Graphs. PVLDB.
[12] Moses Charikar. 2000. Greedy Approximation Algorithms for Finding Dense
Components in a Graph. Approximation Algorithms for Combinatorial Optimiza-
tion.
[13] Chandra Chekuri, Kent Quanrud, and Manuel R. Torres. 2022. Densest Subgraph:
Supermodularity, Iterative Peeling, and Flow. SODA.
[14] Tianyi Chen, Brian Matejek, Michael Mitzenmacher, and Charalampos E.
Tsourakakis. 2023. Algorithmic Tools for Understanding the Motif Structure
of Networks. ECML PKDD.
[15] Tianyi Chen and Charalampos Tsourakakis. 2022. AntiBenford Subgraphs: Un-
supervised Anomaly Detection in Financial Networks. KDD.
[16] S.N. Dorogovtsev and J.F.F. Mendes. 2003. Evolution of Networks. Oxford Univer-
sity Press.
[17] Alessandro Epasto, Silvio Lattanzi, and Mauro Sozio. 2015. Efficient Densest
Subgraph Computation in Evolving Graphs. WWW.
[18] Yixiang Fang, Wensheng Luo, and Chenhao Ma. 2022. Densest subgraph discovery
on large graphs. PVLDB.
[19] Yixiang Fang, Kaiqiang Yu, Reynold Cheng, Laks V. S. Lakshmanan, and Xuemin
Lin. 2019. Efficient algorithms for densest subgraph discovery. PVLDB.
[20] Adriano Fazzone, Tommaso Lanciano, Riccardo Denni, Charalampos E.
Tsourakakis, and Francesco Bonchi. 2022. Discovering Polarization Niches via
Dense Subgraphs with Attractors and Repulsers. PVLDB.
[21] Linton C. Freeman. 2004. The development of social network analysis. Empirical
Press.
[22] Edoardo Galimberti, Martino Ciaperoni, Alain Barrat, Francesco Bonchi, Ciro
Cattuto, and Francesco Gullo. 2020. Span-core Decomposition for Temporal
Networks. TKDD.
[23] Zhongqiang Gao, Chuanqi Cheng, Yanwei Yu, Lei Cao, Chao Huang, and Junyu
Dong. 2022. Scalable Motif Counting for Large-scale Temporal Graphs. ICDE.
[24] Aristides Gionis, Lutz Oettershagen, and Ilie Sarpe. 2024. Mining Temporal
Networks. WWW.
[25] Aristides Gionis and Charalampos E. Tsourakakis. 2015. Dense Subgraph Discov-
ery.KDD.
[26] A. V. Goldberg. 1984. Finding a Maximum Density Subgraph. Technical Report.
[27] Kathrin Hanauer, Monika Henzinger, and Christian Schulz. 2021. Recent Ad-
vances in Fully Dynamic Graph Algorithms. Journal of Experimental Algorithmics.
[28] Yizhang He, Kai Wang, Wenjie Zhang, Xuemin Lin, and Ying Zhang. 2023. Scaling
Upğ‘˜-Clique Densest Subgraph Detection. PACMMOD.
[29] Nathalie Henry, Jean-Daniel Fekete, and Michael J. McGuffin. 2007. NodeTrix: a
Hybrid Visualization of Social Networks. TVCG.
[30] Petter Holme and Jari SaramÃ¤ki. 2019. Temporal Network Theory. Springer
International Publishing.
[31] Petter Holme and Jari SaramÃ¤ki. 2012. Temporal networks. Physics Reports.
[32] Ryan Huebsch, Joseph M. Hellerstein, Nick Lanham, Boon Thau Loo, Scott
Shenker, and Ion Stoica. 2003. Querying the Internet with PIER. PVLDB.
[33] Shweta Jain and C. Seshadhri. 2017. A Fast and Provable Method for Estimating
Clique Counts Using TurÃ¡n's Theorem. WWW.
[34] Lauri Kovanen, MÃ¡rton Karsai, Kimmo Kaski, JÃ¡nos KertÃ©sz, and Jari SaramÃ¤ki.
2011. Temporal motifs in time-dependent networks. JSTAT.[35] Renaud Lambiotte, Lionel Tabourier, and Jean-Charles Delvenne. 2013. Burstiness
and spreading on temporal networks. The European Physical Journal B.
[36] Tommaso Lanciano, Atsushi Miyauchi, Adriano Fazzone, and Francesco Bonchi.
2023. A Survey on the Densest Subgraph Problem and its Variants. Computing
Surveys.
[37] Jinsoo Lee, Wook-Shin Han, Romans Kasperovics, and Jeong-Hoon Lee. 2012. An
in-depth Comparison of Subgraph Isomorphism Algorithms in Graph Databases.
PVLDB.
[38] Victor E. Lee, Ning Ruan, Ruoming Jin, and Charu Aggarwal. 2010. A Survey of
Algorithms for Dense Subgraph Discovery. Managing and Mining Graph Data.
[39] Da Lei, Xuewu Chen, Long Cheng, Lin Zhang, Satish V. Ukkusuri, and Frank
Witlox. 2020. Inferring Temporal Motifs for Travel Pattern Analysis using Large
Scale Smart Card Data. Transportation Research Part C: Emerging Technologies.
[40] Rong-Hua Li, Jiao Su, Lu Qin, Jeffrey Xu Yu, and Qiangqiang Dai. 2018. Persistent
Community Search in Temporal Networks. ICDE.
[41] Longlong Lin, Pingpeng Yuan, Rong-Hua Li, Jifei Wang, Ling Liu, and Hai Jin.
2022. Mining Stable Quasi-Cliques on Temporal Networks. Transactions on
Systems, Man, and Cybernetics: Systems.
[42] Jieli Liu, Jinze Chen, Jiajing Wu, Zhiying Wu, Junyuan Fang, and Zibin Zheng.
2024. Fishing for Fraudsters: Uncovering Ethereum Phishing Gangs With
Blockchain Data. Transactions on Information Forensics and Security.
[43] Penghang Liu, Rupam Acharyya, Robert E. Tillman, Shunya Kimura, Naoki Ma-
suda, and Ahmet Erdem SarÄ±yÃ¼ce. 2023. Temporal Motifs for Financial Networks:
A Study on Mercari, JPMC, and Venmo Platforms. arXiv.
[44] Paul Liu, Austin R. Benson, and Moses Charikar. 2019. Sampling Methods for
Counting Temporal Motifs. WSDM.
[45] Penghang Liu, Valerio Guarrasi, and A. Erdem Sariyuce. 2021. Temporal Network
Motifs: Models, Limitations, Evaluation. TKDE.
[46] Penghang Liu and Ahmet Erdem SariyÃ¼ce. 2023. Using Motif Transitions for
Temporal Graph Generation. KDD.
[47] Patrick Mackey, Katherine Porterfield, Erin Fitzhenry, Sutanay Choudhury, and
George Chin. 2018. A Chronological Edge-Driven Approach to Temporal Sub-
graph Isomorphism. International Conference on Big Data.
[48] Naoki Masuda and Renaud Lambiotte. 2016. A Guide to Temporal Networks. World
Scientific (Europe).
[49] Michael Mitzenmacher, Jakub Pachocki, Richard Peng, Charalampos Tsourakakis,
and Shen Chen Xu. 2015. Scalable Large Near-Clique Detection in Large-Scale
Networks via Sampling. KDD.
[50] Lutz Oettershagen, Athanasios L. Konstantinidis, and Giuseppe F. Italiano. 2023.
Temporal Network Core Decomposition and Community Search. arXiv.
[51] Lutz Oettershagen, Nils M. Kriege, and Petra Mutzel. 2023. A Higher-Order
Temporal H-Index for Evolving Networks. KDD.
[52] Lutz Oettershagen and Petra Mutzel. 2020. Efficient Top-k Temporal Closeness
Calculation in Temporal Networks. ICDM.
[53] Ashwin Paranjape, Austin R. Benson, and Jure Leskovec. 2017. Motifs in Temporal
Networks. WSDM.
[54] Noujan Pashanasangi and C. Seshadhri. 2021. Faster and Generalized Temporal
Triangle Counting, via Degeneracy Ordering. KDD.
[55] Giulia Preti, Polina Rozenshtein, Aristides Gionis, and Yannis Velegrakis. 2021.
Discovering Dense Correlated Subgraphs in Dynamic Networks. Advances in
Knowledge Discovery and Data Mining.
[56] Jiaxi Pu, Yanhao Wang, Yuchen Li, and Xuan Zhou. 2023. Sampling Algorithms
for Butterfly Counting on Temporal Bipartite Graphs. arXiv.
[57] Hongchao Qin, Rong-Hua Li, Ye Yuan, Yongheng Dai, and Guoren Wang. 2023.
Densest Periodic Subgraph Mining on Large Temporal Graphs. TKDE.
[58] Hongchao Qin, Rong-Hua Li, Ye Yuan, Guoren Wang, Lu Qin, and Zhiwei Zhang.
2022. Mining Bursting Core in Large Temporal Graphs. PVLDB.
[59] Polina Rozenshtein, Francesco Bonchi, Aristides Gionis, Mauro Sozio, and Nikolaj
Tatti. 2019. Finding events in temporal networks: segmentation meets densest
subgraph discovery. Knowledge and Information Systems.
[60] Diego Santoro and Ilie Sarpe. 2022. ONBRA: Rigorous Estimation of the Temporal
Betweenness Centrality in Temporal Networks. WWW.
[61] Ahmet Erdem Sariyuce, C. Seshadhri, Ali Pinar, and Umit V. Catalyurek. 2015.
Finding the Hierarchy of Dense Subgraphs using Nucleus Decompositions.
WWW.
[62] Ilie Sarpe and Fabio Vandin. 2021. odeN: Simultaneous Approximation of Multiple
Motif Counts in Large Temporal Networks. CIKM.
[63] Ilie Sarpe and Fabio Vandin. 2021. PRESTO: Simple and Scalable Sampling
Techniques for the Rigorous Approximation of Temporal Motif Counts. SDM.
[64] Ilie Sarpe, Fabio Vandin, and Aristides Gionis. 2024. Scalable Temporal Motif
Densest Subnetwork Discovery. arXiv.
[65] Konstantinos Semertzidis, Evaggelia Pitoura, Evimaria Terzi, and Panayiotis
Tsaparas. 2018. Finding lasting dense subgraphs. Data Mining and Knowledge
Discovery.
[66] Bintao Sun, T.-H. Hubert Chan, and Mauro Sozio. 2020. Fully Dynamic Approxi-
mate k-Core Decomposition in Hypergraphs. TKDD.
[67] Bintao Sun, Maximilien Danisch, T-H. Hubert Chan, and Mauro Sozio. 2020.
KClist++: a simple algorithm for finding ğ‘˜-clique densest subgraphs in large
 
2545Scalable Temporal Motif Densest Subnetwork Discovery KDD â€™24, August 25â€“29, 2024, Barcelona, Spain
graphs. PVLDB.
[68] John Tang, Mirco Musolesi, Cecilia Mascolo, and Vito Latora. 2010. Character-
ising temporal distance and reachability in mobile and online social networks.
SIGCOMM.
[69] Charalampos Tsourakakis. 2015. The K-clique Densest Subgraph Problem. In
WWW.
[70] Charalampos E. Tsourakakis. 2014. A Novel Approach to Finding Near-Cliques:
The Triangle-Densest Subgraph Problem. arXiv.
[71] Alexei Vazquez, BalÃ¡zs RÃ¡cz, AndrÃ¡s LukÃ¡cs, and Albert-LÃ¡szlÃ³ BarabÃ¡si. 2007.
Impact of Non-Poissonian Activity Patterns on Spreading Processes. Physical
Review Letters.
[72] Jiabing Wang, Rongjie Wang, Jia Wei, Qianli Ma, and Guihua Wen. 2020. Finding
dense subgraphs with maximum weighted triangle density. Information Sciences.
[73] Jingjing Wang, Yanhao Wang, Wenjun Jiang, Yuchen Li, and Kian-Lee Tan. 2020.
Efficient Sampling Algorithms for Approximate Temporal Motif Counting. CIKM.
[74] Jiajing Wu, Jieli Liu, Weili Chen, Huawei Huang, Zibin Zheng, and Yan Zhang.
2022. Detecting Mixing Services via Mining Bitcoin Transaction Network With
Hybrid Motifs. Transactions on Systems, Man, and Cybernetics: Systems.
[75] Qiankun Zhao, Yuan Tian, Qi He, Nuria Oliver, Ruoming Jin, and Wang-Chien
Lee. 2010. Communication motifs. CIKM.
[76] Ming Zhong, Junyong Yang, Yuanyuan Zhu, Tieyun Qian, Mengchi Liu, and
Jeffrey Xu Yu. 2024. A Unified and Scalable Algorithm Framework of User-
Defined Temporal(ğ‘˜,X)-Core Query. TKDE.
A Application scenarios for the TMDS problem
While we study the TMDS problem in its general form, in this
section we discuss more in depth two possible applications of our
novel problem formulation, showing that the TMDS is a really
versatile and powerful tool for temporal network analysis. We will
discuss how the Temporal Motif Densest Subnetwork (TMDS) can
be used to discover important insights from (i) travel networks and
(ii) e-commerce networks capturing online platforms.
(i) A travel network can be modeled as a temporal network
ğ‘‡=(ğ‘‰,ğ¸)withğ‘‰being the set of vertices corresponding to Points
Of Interest (POIs) or particular geographic areas of a city [ 39], and
edges of the form (ğ‘¢,ğ‘£,ğ‘¡)âˆˆğ¸represent trips by user that travel
from pointğ‘¢âˆˆğ‘‰to pointğ‘£âˆˆğ‘‰at timeğ‘¡. A temporal motif ğ‘€on
such network captures therefore travel patterns and their dynamics.
As an example a temporal motif ğ‘€:ğ‘¥ğ‘¡1â†’ğ‘¦ğ‘¡2â†’ğ‘¥occurring within
one day often corresponds to a round trip by a user from ğ‘¥being the
home location, to ğ‘¦being the work location. The TMDS problem
formulation, in such a scenario can provide unique insights on the
POIs appearing frequently together in the various travel patterns
(isomorphic to ğ‘€) of the various users. Furthermore, analyzing
different time-scales as captured by the temporal motif duration, can
yield unique insights about daily vs. weekly vs. monthly patterns.
As for our Figure 1 in the TMDS several POIs often coexist, and
such information can be used to improve connections between POIs
that are not well connected by public transport, or for the design of
travel passes for specific areas of a city with specific time-duration,
based on POIs that are often visited together in the various trips.
(ii) E-commerce online platforms can be modeled as temporal
bipartite networks ğ‘‡=(ğ‘‰,ğ¸), where the set of vertices is parti-
tioned in two layers ğ‘‰=ğ‘ˆâˆªğ‘ƒ, withğ‘ˆbeing the set of users (i.e.,
customers that purchase online products), and ğ‘ƒthe set of prod-
ucts available for purchase. A temporal edge ğ‘’=(ğ‘¢,ğ‘,ğ‘¡)on such
a network captures that user ğ‘¢âˆˆğ‘ˆpurchased product ğ‘âˆˆğ‘ƒat a
given timeğ‘¡. As an example a temporal motif ğ‘€â€²:ğ‘¥ğ‘¡1â†’ğ‘¦,ğ‘¥ğ‘¡2â†’ğ‘§
occurring within a time-limit corresponds to a pair of products
i.e.,ğ‘¦andğ‘§that userğ‘¥buys at distance of at most the provided
time-limit, note also that ğ‘§is purchased after ğ‘¦. A temporal motif
ğ‘€therefore captures specific purchase habits of users within aTable 3: Notation table.
Symb
ol Description
ğ‘‡=(ğ‘‰ğ‘‡,
ğ¸ğ‘‡) Temporal network
ğ‘‡[ğ‘Š],ğ‘ŠâŠ†ğ‘‰ğ‘‡ Induced temporal sub-network by ğ‘Š
ğ‘›,ğ‘š Number of nodes and temporal edges of ğ‘‡
ğ·ğ‘‡,ğºğ‘‡ Directed and undirected static network of ğ‘‡
ğ‘€=(ğ¾,ğœ)ğ‘˜-vertexâ„“-edge temporal motif
ğ¾=(ğ‘‰ğ¾,ğ¸ğ¾) Multi-graph of the temporal motif ğ‘€
ğœ Ordering of the edges of ğ¸ğ¾in a motif
ğ›¿ Time window-length of a temporal motif instance
Sğ‘‡â€² Set ofğ›¿-instances of ğ‘€in the network ğ‘‡â€²
Sğ‘Š,ğ‘ŠâŠ†ğ‘‰ğ‘‡ Set ofğ›¿-instances of ğ‘€in the network ğ‘‡[ğ‘Š]
ğœ Weighting function over Sğ‘‡
ğœ(ğ‘Š),ğ‘ŠâŠ†ğ‘‰ğ‘‡ Total weight of the ğ›¿-instances inSğ‘Š
ğœŒ(Â·) TMDS objective function
ğº[ğ‘€] Undirected graph associated to ğ¾
H Set ofğ‘˜-CIS overğºğ‘‡
ğ‘‘ğœ
ğ‘Š(ğ‘£),ğ‘ŠâŠ†ğ‘‰ğ‘‡Temporal motif degree of vertex ğ‘£inğ‘‡[ğ‘Š]
ğ‘‘ğœ
ğ‘‡â€²(ğ‘£),ğ‘‡â€²âŠ†ğ‘‡ Temporal motif degree of vertex ğ‘£inğ‘‡â€²
ğœ‰>0 Threshold for batch peeling
ğœ€,ğœ‚ Accuracy and confidence parameters
ğ‘Ÿ Sample size in ProbPeel, HybridPeel
Ë†ğ‘‘ğœ
ğ‘Š(ğ‘£) Estimate of the temporal motif degree of ğ‘£inğ‘‡[ğ‘Š]
Ë†ğ‘š Maximum edges from ğ¸ğ‘‡in a window length of ğ›¿
ğ‘ Parameter of the subroutine PRESTO-A [63]
limited time-limit (as again controlled by the duration parameter
of the temporal motif). The optimal TMDS can be used to collect
a set of users (and items) that frequently co-occur. In particular,
the TMDS can contain several vertices (i.e., users) with similar
purchase sequences or buying habits, this enables the design of
personalized advertisement for those users in the TMDS (e.g., by
leveraging the history of other users in the TMDS), furthermore
this can be studied at different time-scales. Note also that this is
more powerful than only considering products that are frequently
co-purchased together (e.g., consider ğ‘€â€², then the products ğ‘¦andğ‘§
are purchased in different moments), for which many techniques
already exist.
B Notation
A summary of the notation used throughout the paper is reported
in Table 3.
C Additional experimental results
C.1 Memory usage
We measured the peak RAM memory over one single execution
of each algorithm on the configurations of Section 6.3. We show
the results in Figure 5 â€” recall that the memory limit was set to
150 GB on all datasets but EquinixChicago where the limit was set
to 200 GB. We do not report data for algorithms that do not finish
within three hours.
Overall, the memory usage of the different algorithms strongly
depends on the temporal motif considered, and in general motifs
M1,M2andM5require much more memory that other motifs on
almost all datasets. We observe that on such motifs ProbPeel and
HybridPeel use much less memory compared to the baselines,
 
2546KDD â€™24, August 25â€“29, 2024, Barcelona, Spain Ilie Sarpe, Fabio Vandin, and Aristides Gionis
M1M2M3M4M5M6M7M8M9M100255075100125
Stackoverflow =172800
r=4000
r=4000
M1M2M3M4M5M6M7M8M9M1012141618
Bitcoin =7200
r=30000
r=30000
M1M2M3M4M5M6M7M8M9M10405060
Reddit =14400
r=20000
r=20000
M1M2M4M5M6M9150160170
EquinixChicago =50000
r=1000
r=1000
T emporal MotifPeak RAM (GB)Exact Greedy Batch =0.3
ProbPeel =0.3
HybridPeel =0.3
Figure 5: Peak RAM memory in GB over one execution.
0.0 0.5 1.00.600.801.00
M1
0.0 0.5 1.00.600.801.00
M2
0.0 0.5 1.00.901.00 M3
0.0 0.5 1.00.500.751.00
M4
0.0 0.5 1.00.801.00
M7
0.0 0.5 1.00.500.751.00
M8
0.0 0.5 1.00.500.751.00
M9
0.0 0.5 1.00.600.801.00
M10
Value of 
(WBatch)/|WBatch|
OPT
Askubuntu =172800
0.0 0.5 1.00.500.751.00
M1
0.0 0.5 1.00.801.00M2
0.0 0.5 1.00.951.001.05
M3
0.0 0.5 1.00.600.801.00
M4
0.0 0.5 1.00.801.00M7
0.0 0.5 1.00.951.001.05
M8
0.0 0.5 1.00.801.00
M9
0.0 0.5 1.00.951.001.05
M10
Value of 
(WBatch)/|WBatch|
OPT
Sms =172800
Figure 6: Approximation ratio of Batch for varying ğœ‰.
saving on M2more than 100 GB on datasets Stackoverflow and
Bitcoin and about 90 GB on the Reddit dataset. This is due to the
fact that, differently from all other algorithms, our randomized
algorithms do not store the set Hofğ‘˜-CIS (see Table 1). This
supports that the algorithms in ALDENTE are very practical and
scalable on large datasets.
C.2 Varying ğœ‰
We show how the solution obtained by Batch varies according to
the value of ğœ‰, this setting is used to understand the best possible
solution that can be obtained by ProbPeel according to various val-
ues ofğœ‰(i.e., whenğœ€â‰ˆ0then ProbPeel converges to the solution
provided by Batch ). We will use datasets Askubuntu and Sms con-
sidering the motifs of Fig. 2 (excluding M5andM6given their high
running time). In particular, we start from ğœ‰=10âˆ’3and increase it
with a step of 5Â·10âˆ’3until it reaches 1 and we execute Batch with
yarg
bracketla
foodyuhyoafil
chickthanksbackpizzaagainyargagas
chrissybirdietaco
maintenance:uber:
Words024681012FrequencyTop K=20 words and their frequencyFigure 7: Histogram associated to the words inside messages
collected on the edges of ğ‘‡[ğ‘Šâˆ—]on the Venmo dataset, for M5
andğ›¿=172800 (i.e, two days). See Section 6.4 for more details,
and Figure 4 for a representation of the optimal subnetwork.
each different value of such parameter. We then compare each solu-
tion obtained by Batch to the optimal solution obtained by Exact .
The results are shown in Fig. 6. We see that in general smaller
values ofğœ‰correspond to solutions with better approximation ratio
obtained by Batch . On some instances by varying ğœ‰the solution
may vary significantly (e.g., M2on Askubuntu). In general the algo-
rithm achieves satisfactory approximations on most configurations
forğœ‰<0.75, given that for such range the value of the solution
obtained by Batch is often within 80% of the optimal solution found
with Exact . We also observe that in some settings the algorithm
never outputs solutions with optimal densities (e.g., motif M2,M8
on Askubuntu or M1on Sms). This supports the design of Hybrid-
Peel , since for ProbPeel it may often be infeasible to converge to
an optimal solution, as its guarantees are with respect to Batch
(see Theorem 4.2). In our extended online version [ 64] we show
additional results on the convergence of ProbPeel toBatch by
varying the parameter ğ‘Ÿwhich controls the sample size, used to
compute the approximate temporal motif degrees of the various
vertices.
C.3 Case study
We report in Figure 7 the frequencies of top-20 words over the
transactions associated to the optimal subnetwork from Figure 4
(right). We observe terms related to social activities (i.e., food, pizza,
etc.), and terms that may be related to gambling (e.g., bracket, yarg),
we removed emojis from the histogram for ease of visualization.
 
2547